#!/usr/bin/env python3
import subprocess
import os
import json
import requests
import re
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor

class VulnerabilityAssessment:
    def __init__(self, target, logger):
        self.target = target
        self.logger = logger
        self.findings = {
            "cve_analysis": {},
            "exploit_research": {},
            "vulnerability_scanning": {},
            "diagnostic_analysis": {}
        }
        self.output_dir = f"reports/vuln_assessment_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Load information gathering results if available
        self.info_gathering_results = self._load_info_gathering_results()

    def _load_info_gathering_results(self):
        """Load results from information gathering stage"""
        try:
            info_gathering_dir = max([d for d in os.listdir("reports") if d.startswith("info_gathering_")])
            with open(f"reports/{info_gathering_dir}/findings.json", 'r') as f:
                return json.load(f)
        except Exception as e:
            self.logger.error(f"Failed to load information gathering results: {str(e)}")
            return None

    def run(self):
        """Run all vulnerability assessment tasks"""
        self.logger.info("Starting Vulnerability Assessment phase...")
        
        # 1. CVE Analysis
        self.logger.info("Performing CVE analysis...")
        self.findings["cve_analysis"] = self.cve_analysis()
        
        # 2. Exploit Research
        self.logger.info("Performing exploit research...")
        self.findings["exploit_research"] = self.exploit_research()
        
        # 3. Vulnerability Scanning
        self.logger.info("Performing vulnerability scanning...")
        self.findings["vulnerability_scanning"] = self.vulnerability_scanning()
        
        # 4. Diagnostic Analysis
        self.logger.info("Performing diagnostic analysis...")
        self.findings["diagnostic_analysis"] = self.diagnostic_analysis()
        
        # Save findings to JSON for other stages
        self._save_findings()
        
        return self.findings

    def _save_findings(self):
        """Save findings to JSON file for use in other stages"""
        output_file = f"{self.output_dir}/findings.json"
        with open(output_file, 'w') as f:
            json.dump(self.findings, f, indent=4)
        self.logger.info(f"Findings saved to {output_file}")

    def run_command(self, command, capture_output=True):
        """Run a system command and return the output"""
        try:
            if isinstance(command, list):
                result = subprocess.run(command, capture_output=capture_output, text=True)
            else:
                result = subprocess.run(command, capture_output=capture_output, text=True, shell=True)
                
            if result.returncode != 0:
                self.logger.error(f"Command failed: {result.stderr}")
                return None
                
            return result.stdout if capture_output else "Command executed successfully"
            
        except Exception as e:
            self.logger.error(f"Error executing command: {str(e)}")
            return None

    def cve_analysis(self):
        """Perform CVE analysis using multiple sources"""
        results = {}
        
        # 1. NVD API Analysis
        self.logger.info("Checking NVD database...")
        nvd_results = self._check_nvd()
        results["nvd"] = nvd_results
        
        # 2. Vulners API Analysis
        self.logger.info("Checking Vulners database...")
        vulners_results = self._check_vulners()
        results["vulners"] = vulners_results
        
        # 3. CVEDetails Analysis
        self.logger.info("Checking CVEDetails...")
        cvedetails_results = self._check_cvedetails()
        results["cvedetails"] = cvedetails_results
        
        return results

    def _check_nvd(self):
        """Check National Vulnerability Database"""
        results = {}
        
        if self.info_gathering_results and "services" in self.info_gathering_results:
            for service, version in self._extract_versions():
                try:
                    url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch={service} {version}"
                    response = requests.get(url)
                    if response.status_code == 200:
                        results[f"{service}_{version}"] = response.json()
                except Exception as e:
                    self.logger.error(f"NVD API check failed for {service} {version}: {str(e)}")
                    
        return results

    def _check_vulners(self):
        """Check Vulners database"""
        results = {}
        
        if self.info_gathering_results and "services" in self.info_gathering_results:
            for service, version in self._extract_versions():
                try:
                    vulners_cmd = f"vulners -s {service} -v {version} -o {self.output_dir}/vulners_{service}.json"
                    vulners_result = self.run_command(vulners_cmd)
                    if vulners_result:
                        results[f"{service}_{version}"] = vulners_result
                except Exception as e:
                    self.logger.error(f"Vulners check failed for {service} {version}: {str(e)}")
                    
        return results

    def _check_cvedetails(self):
        """Check CVEDetails database"""
        results = {}
        
        if self.info_gathering_results and "services" in self.info_gathering_results:
            for service, version in self._extract_versions():
                try:
                    cvedetails_cmd = f"cvedetails -s {service} -v {version} -o {self.output_dir}/cvedetails_{service}.json"
                    cvedetails_result = self.run_command(cvedetails_cmd)
                    if cvedetails_result:
                        results[f"{service}_{version}"] = cvedetails_result
                except Exception as e:
                    self.logger.error(f"CVEDetails check failed for {service} {version}: {str(e)}")
                    
        return results

    def _extract_versions(self):
        """Extract service versions from information gathering results"""
        versions = []
        if self.info_gathering_results and "services" in self.info_gathering_results:
            for service_info in self.info_gathering_results["services"].get("versions", {}).get("nmap", "").split("\n"):
                if "open" in service_info.lower():
                    match = re.search(r"(\d+\.\d+\.\d+)", service_info)
                    if match:
                        service_name = service_info.split()[2] if len(service_info.split()) > 2 else "unknown"
                        versions.append((service_name, match.group(1)))
        return versions

    def exploit_research(self):
        """Research available exploits for identified vulnerabilities"""
        results = {}
        
        # 1. Exploit-DB Search
        self.logger.info("Searching Exploit-DB...")
        exploitdb_results = self._search_exploitdb()
        results["exploitdb"] = exploitdb_results
        
        # 2. Packet Storm Security Search
        self.logger.info("Searching Packet Storm Security...")
        packetstorm_results = self._search_packetstorm()
        results["packetstorm"] = packetstorm_results
        
        # 3. Metasploit Module Search
        self.logger.info("Searching Metasploit modules...")
        metasploit_results = self._search_metasploit()
        results["metasploit"] = metasploit_results
        
        return results

    def _search_exploitdb(self):
        """Search Exploit-DB for exploits"""
        results = {}
        
        if self.info_gathering_results and "services" in self.info_gathering_results:
            for service, version in self._extract_versions():
                searchsploit_cmd = f"searchsploit {service} {version} -j -o {self.output_dir}/searchsploit_{service}.json"
                searchsploit_result = self.run_command(searchsploit_cmd)
                if searchsploit_result:
                    results[f"{service}_{version}"] = searchsploit_result
                    
        return results

    def _search_packetstorm(self):
        """Search Packet Storm Security for exploits"""
        results = {}
        
        if self.info_gathering_results and "services" in self.info_gathering_results:
            for service, version in self._extract_versions():
                packetstorm_cmd = f"packetstorm-search {service} {version} -o {self.output_dir}/packetstorm_{service}.json"
                packetstorm_result = self.run_command(packetstorm_cmd)
                if packetstorm_result:
                    results[f"{service}_{version}"] = packetstorm_result
                    
        return results

    def _search_metasploit(self):
        """Search Metasploit modules"""
        results = {}
        
        if self.info_gathering_results and "services" in self.info_gathering_results:
            for service, version in self._extract_versions():
                msf_cmd = f"msfconsole -q -x 'search type:exploit {service} {version}; exit'"
                msf_result = self.run_command(msf_cmd)
                if msf_result:
                    results[f"{service}_{version}"] = msf_result
                    
        return results

    def vulnerability_scanning(self):
        """Perform comprehensive vulnerability scanning"""
        results = {}
        
        # 1. Nmap Vulnerability Scripts
        self.logger.info("Running Nmap vulnerability scripts...")
        nmap_results = self._run_nmap_vuln_scripts()
        results["nmap"] = nmap_results
        
        # 2. OpenVAS Scan
        self.logger.info("Running OpenVAS scan...")
        openvas_results = self._run_openvas_scan()
        results["openvas"] = openvas_results
        
        # 3. Custom Vulnerability Checks
        self.logger.info("Running custom vulnerability checks...")
        custom_results = self._run_custom_checks()
        results["custom"] = custom_results
        
        return results

    def _run_nmap_vuln_scripts(self):
        """Run Nmap vulnerability scripts"""
        results = {}
        
        # Run all vulnerability scripts
        nmap_cmd = f"nmap -sV --script vuln -oN {self.output_dir}/nmap_vuln.txt {self.target}"
        nmap_result = self.run_command(nmap_cmd)
        if nmap_result:
            results["all_vuln"] = nmap_result
            
        # Run specific vulnerability scripts based on services
        if self.info_gathering_results and "services" in self.info_gathering_results:
            for service in self._get_services():
                script_cmd = f"nmap -sV --script {service}-* -oN {self.output_dir}/nmap_{service}_vuln.txt {self.target}"
                script_result = self.run_command(script_cmd)
                if script_result:
                    results[f"{service}_vuln"] = script_result
                    
        return results

    def _run_openvas_scan(self):
        """Run OpenVAS vulnerability scan"""
        results = {}
        
        # Create and run OpenVAS scan
        openvas_cmd = f"omp -u admin -w admin --xml='<create_task><name>Scan {self.target}</name><target><hosts>{self.target}</hosts></target><scanner>OpenVAS Default</scanner></create_task>'"
        openvas_result = self.run_command(openvas_cmd)
        if openvas_result:
            results["scan"] = openvas_result
            
        return results

    def _run_custom_checks(self):
        """Run custom vulnerability checks"""
        results = {}
        
        # Check for common misconfigurations
        self.logger.info("Checking for common misconfigurations...")
        misconfig_cmd = f"nmap -sV --script default,auth,vuln -oN {self.output_dir}/misconfig.txt {self.target}"
        misconfig_result = self.run_command(misconfig_cmd)
        if misconfig_result:
            results["misconfigurations"] = misconfig_result
            
        return results

    def _get_services(self):
        """Get list of services from information gathering results"""
        services = []
        if self.info_gathering_results and "services" in self.info_gathering_results:
            for service_info in self.info_gathering_results["services"].get("versions", {}).get("nmap", "").split("\n"):
                if "open" in service_info.lower():
                    service_name = service_info.split()[2] if len(service_info.split()) > 2 else "unknown"
                    services.append(service_name)
        return services

    def diagnostic_analysis(self):
        """Perform diagnostic analysis of identified vulnerabilities"""
        results = {}
        
        # 1. Vulnerability Verification
        self.logger.info("Verifying identified vulnerabilities...")
        verification_results = self._verify_vulnerabilities()
        results["verification"] = verification_results
        
        # 2. Impact Analysis
        self.logger.info("Analyzing vulnerability impact...")
        impact_results = self._analyze_impact()
        results["impact"] = impact_results
        
        # 3. Exploitability Assessment
        self.logger.info("Assessing exploitability...")
        exploitability_results = self._assess_exploitability()
        results["exploitability"] = exploitability_results
        
        return results

    def _verify_vulnerabilities(self):
        """Verify identified vulnerabilities"""
        results = {}
        
        # Verify each identified vulnerability
        for vuln in self.findings.get("vulnerability_scanning", {}).get("nmap", {}).get("all_vuln", "").split("\n"):
            if "VULNERABLE" in vuln:
                vuln_name = vuln.split(":")[0].strip()
                verify_cmd = f"nmap -sV --script {vuln_name} -oN {self.output_dir}/verify_{vuln_name}.txt {self.target}"
                verify_result = self.run_command(verify_cmd)
                if verify_result:
                    results[vuln_name] = verify_result
                    
        return results

    def _analyze_impact(self):
        """Analyze impact of identified vulnerabilities"""
        results = {}
        
        # Analyze CVSS scores and impact
        for cve in self.findings.get("cve_analysis", {}).get("nvd", {}):
            try:
                cvss_score = cve.get("metrics", {}).get("cvssMetricV31", [{}])[0].get("cvssData", {}).get("baseScore")
                if cvss_score:
                    results[cve.get("cve", {}).get("id")] = {
                        "cvss_score": cvss_score,
                        "impact": "High" if cvss_score >= 7.0 else "Medium" if cvss_score >= 4.0 else "Low"
                    }
            except Exception as e:
                self.logger.error(f"Failed to analyze impact for CVE: {str(e)}")
                
        return results

    def _assess_exploitability(self):
        """Assess exploitability of identified vulnerabilities"""
        results = {}
        
        # Assess exploit availability and complexity
        for vuln, exploits in self.findings.get("exploit_research", {}).get("exploitdb", {}).items():
            results[vuln] = {
                "exploit_available": bool(exploits),
                "exploit_complexity": self._determine_exploit_complexity(exploits),
                "metasploit_module": bool(self.findings.get("exploit_research", {}).get("metasploit", {}).get(vuln))
            }
            
        return results

    def _determine_exploit_complexity(self, exploits):
        """Determine complexity of available exploits"""
        if not exploits:
            return "Unknown"
            
        # Simple heuristic based on exploit characteristics
        if any("remote" in str(exploit).lower() for exploit in exploits):
            return "Low"
        elif any("local" in str(exploit).lower() for exploit in exploits):
            return "Medium"
        else:
            return "High" 