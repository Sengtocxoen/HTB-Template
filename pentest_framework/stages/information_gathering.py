#!/usr/bin/env python3
import subprocess
import os
import json
import requests
import socket
import nmap
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
import re

class InformationGathering:
    def __init__(self, target, logger, tool_manager=None, execution_engine=None, credentials=None):
        self.target = target
        self.logger = logger
        self.tool_manager = tool_manager
        self.execution_engine = execution_engine
        self.credentials = credentials or {}
        self.output_dir = "reports/information_gathering"
        self.findings = {}
        
        # Create output directory if it doesn't exist
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)
            
    def run(self):
        """Main method to run all information gathering tasks"""
        self.logger.info(f"Starting information gathering for {self.target}")
        
        try:
            # Run all information gathering tasks
            self.findings = {
                "port_scan": self.run_port_scan(),
                "service_enumeration": self.run_service_enumeration(),
                "web_enumeration": self.run_web_enumeration(),
                "os_detection": self.run_os_detection(),
                "vulnerability_scan": self.run_vulnerability_scan()
            }
            
            # Save findings to file
            self._save_findings()
            
            return self.findings
            
        except Exception as e:
            self.logger.error(f"Error during information gathering: {str(e)}")
            return {}
            
    def _save_findings(self):
        """Save findings to JSON file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = f"{self.output_dir}/findings_{self.target}_{timestamp}.json"
        
        with open(output_file, 'w') as f:
            json.dump(self.findings, f, indent=4)
            
        self.logger.info(f"Findings saved to {output_file}")
        
    def run_port_scan(self):
        """Perform initial port scan"""
        self.logger.info("Running port scan...")
        
        try:
            # Initialize nmap scanner
            nm = nmap.PortScanner()
            
            # Run quick scan first
            nm.scan(self.target, arguments='-sS -sV -F --version-intensity 5')
            
            # Get detailed scan of open ports
            open_ports = []
            for host in nm.all_hosts():
                for proto in nm[host].all_protocols():
                    ports = nm[host][proto].keys()
                    for port in ports:
                        service = nm[host][proto][port]
                        open_ports.append({
                            'port': port,
                            'protocol': proto,
                            'state': service['state'],
                            'name': service['name'],
                            'product': service.get('product', ''),
                            'version': service.get('version', '')
                        })
            
            # Save port scan results
            port_scan_file = f"{self.output_dir}/port_scan_{self.target}.json"
            with open(port_scan_file, 'w') as f:
                json.dump(open_ports, f, indent=4)
                
            return open_ports
            
        except Exception as e:
            self.logger.error(f"Error during port scan: {str(e)}")
            return []
            
    def run_service_enumeration(self):
        """Enumerate services on open ports"""
        self.logger.info("Enumerating services...")
        
        services = {}
        try:
            # Check common services
            common_ports = {
                21: 'ftp',
                22: 'ssh',
                23: 'telnet',
                25: 'smtp',
                80: 'http',
                443: 'https',
                445: 'smb',
                3306: 'mysql',
                3389: 'rdp'
            }
            
            for port, service in common_ports.items():
                try:
                    if service == 'http' or service == 'https':
                        self._check_web_service(port, service, services)
                    elif service == 'ftp':
                        self._check_ftp_service(port, services)
                    elif service == 'smb':
                        self._check_smb_service(port, services)
                    # Add more service checks as needed
                except Exception as e:
                    self.logger.error(f"Error checking {service} on port {port}: {str(e)}")
            
            # Save service enumeration results
            service_file = f"{self.output_dir}/services_{self.target}.json"
            with open(service_file, 'w') as f:
                json.dump(services, f, indent=4)
                
            return services
            
        except Exception as e:
            self.logger.error(f"Error during service enumeration: {str(e)}")
            return {}
            
    def run_web_enumeration(self):
        """Enumerate web services"""
        self.logger.info("Enumerating web services...")
        
        web_findings = {}
        try:
            # Check for web services on common ports
            web_ports = [80, 443, 8080, 8443]
            
            for port in web_ports:
                try:
                    protocol = 'https' if port in [443, 8443] else 'http'
                    url = f"{protocol}://{self.target}:{port}"
                    
                    # Check if service is running
                    response = requests.get(url, verify=False, timeout=5)
                    
                    if response.status_code < 400:
                        web_findings[port] = {
                            'url': url,
                            'status_code': response.status_code,
                            'server': response.headers.get('Server', ''),
                            'technologies': self._detect_web_technologies(response),
                            'directories': self._enumerate_directories(url)
                        }
                except:
                    continue
            
            # Save web enumeration results
            web_file = f"{self.output_dir}/web_enum_{self.target}.json"
            with open(web_file, 'w') as f:
                json.dump(web_findings, f, indent=4)
                
            return web_findings
            
        except Exception as e:
            self.logger.error(f"Error during web enumeration: {str(e)}")
            return {}
            
    def run_os_detection(self):
        """Detect operating system"""
        self.logger.info("Detecting operating system...")
        
        try:
            # Initialize nmap scanner
            nm = nmap.PortScanner()
            
            # Run OS detection scan
            nm.scan(self.target, arguments='-O')
            
            os_info = {
                'os_family': nm[self.target]['osmatch'][0]['osclass'][0]['osfamily'] if 'osmatch' in nm[self.target] else 'Unknown',
                'os_details': nm[self.target]['osmatch'][0]['name'] if 'osmatch' in nm[self.target] else 'Unknown',
                'accuracy': nm[self.target]['osmatch'][0]['accuracy'] if 'osmatch' in nm[self.target] else '0'
            }
            
            # Save OS detection results
            os_file = f"{self.output_dir}/os_detection_{self.target}.json"
            with open(os_file, 'w') as f:
                json.dump(os_info, f, indent=4)
                
            return os_info
            
        except Exception as e:
            self.logger.error(f"Error during OS detection: {str(e)}")
            return {}
            
    def run_vulnerability_scan(self):
        """Perform initial vulnerability scan"""
        self.logger.info("Running vulnerability scan...")
        
        vuln_findings = {}
        try:
            # Run nmap vulnerability scripts
            nm = nmap.PortScanner()
            nm.scan(self.target, arguments='-sV --script vuln')
            
            # Process vulnerability findings
            for host in nm.all_hosts():
                for proto in nm[host].all_protocols():
                    ports = nm[host][proto].keys()
                    for port in ports:
                        if 'script' in nm[host][proto][port]:
                            vuln_findings[f"{proto}/{port}"] = nm[host][proto][port]['script']
            
            # Save vulnerability scan results
            vuln_file = f"{self.output_dir}/vuln_scan_{self.target}.json"
            with open(vuln_file, 'w') as f:
                json.dump(vuln_findings, f, indent=4)
                
            return vuln_findings
            
        except Exception as e:
            self.logger.error(f"Error during vulnerability scan: {str(e)}")
            return {}
            
    def _check_web_service(self, port, service, services):
        """Check web service details"""
        try:
            protocol = 'https' if port in [443, 8443] else 'http'
            url = f"{protocol}://{self.target}:{port}"
            
            response = requests.get(url, verify=False, timeout=5)
            services[port] = {
                'type': service,
                'status_code': response.status_code,
                'server': response.headers.get('Server', ''),
                'title': self._extract_title(response.text)
            }
        except:
            pass
            
    def _check_ftp_service(self, port, services):
        """Check FTP service details"""
        try:
            # Use ftp command to check service
            ftp_cmd = f"ftp -n {self.target} {port}"
            result = subprocess.run(ftp_cmd.split(), capture_output=True, text=True)
            
            if "Connected" in result.stdout:
                services[port] = {
                    'type': 'ftp',
                    'banner': result.stdout.split('\n')[0]
                }
        except:
            pass
            
    def _check_smb_service(self, port, services):
        """Check SMB service details"""
        try:
            # Use smbclient to check service
            smb_cmd = f"smbclient -L //{self.target} -p {port} -N"
            result = subprocess.run(smb_cmd.split(), capture_output=True, text=True)
            
            if "Sharename" in result.stdout:
                services[port] = {
                    'type': 'smb',
                    'shares': self._parse_smb_shares(result.stdout)
                }
        except:
            pass
            
    def _detect_web_technologies(self, response):
        """Detect web technologies from response"""
        technologies = []
        
        # Check common headers
        headers = response.headers
        if 'Server' in headers:
            technologies.append(headers['Server'])
        if 'X-Powered-By' in headers:
            technologies.append(headers['X-Powered-By'])
            
        # Check for common technologies in response
        content = response.text.lower()
        if 'wordpress' in content:
            technologies.append('WordPress')
        if 'drupal' in content:
            technologies.append('Drupal')
        if 'joomla' in content:
            technologies.append('Joomla')
            
        return technologies
        
    def _enumerate_directories(self, url):
        """Enumerate web directories"""
        directories = []
        common_dirs = ['admin', 'login', 'wp-admin', 'administrator', 'backup', 'db', 'sql']
        
        for directory in common_dirs:
            try:
                response = requests.get(f"{url}/{directory}", verify=False, timeout=5)
                if response.status_code < 400:
                    directories.append({
                        'path': directory,
                        'status_code': response.status_code
                    })
            except:
                continue
                
        return directories
        
    def _extract_title(self, html):
        """Extract page title from HTML"""
        match = re.search('<title>(.*?)</title>', html, re.IGNORECASE)
        return match.group(1) if match else ''
        
    def _parse_smb_shares(self, output):
        """Parse SMB shares from smbclient output"""
        shares = []
        for line in output.split('\n'):
            if 'Disk' in line:
                share = line.split()[0]
                shares.append(share)
        return shares