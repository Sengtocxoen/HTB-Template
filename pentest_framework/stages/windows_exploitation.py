#!/usr/bin/env python3
import os
import json
import subprocess
import requests
from datetime import datetime
from ..utils.htb_utils import HTBUtils

class WindowsExploitation:
    def __init__(self, target, logger, tool_manager=None, execution_engine=None, credentials=None):
        self.target = target
        self.logger = logger
        self.tool_manager = tool_manager
        self.execution_engine = execution_engine
        self.credentials = credentials or {}
        self.output_dir = "reports/windows_exploitation"
        self.htb_utils = HTBUtils(logger)
        
        # Create output directory if it doesn't exist
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)
            
    def run(self):
        """Main method to run Windows exploitation scenarios"""
        self.logger.info(f"Starting Windows exploitation for {self.target}")
        
        try:
            # Check if target is domain controller
            is_dc = self._check_domain_controller()
            
            if is_dc:
                return self._exploit_domain_controller()
            else:
                return self._exploit_standalone_server()
                
        except Exception as e:
            self.logger.error(f"Error during Windows exploitation: {str(e)}")
            return {}
            
    def _check_domain_controller(self):
        """Check if target is a domain controller"""
        try:
            # Check for DC ports
            dc_ports = [88, 389, 636, 445, 3268, 3269]
            nm = nmap.PortScanner()
            nm.scan(self.target, arguments=f'-p {",".join(map(str, dc_ports))}')
            
            open_ports = []
            for port in dc_ports:
                if str(port) in nm[self.target]['tcp'] and nm[self.target]['tcp'][str(port)]['state'] == 'open':
                    open_ports.append(port)
                    
            # If all DC ports are open, likely a domain controller
            return len(open_ports) >= 4
        except Exception as e:
            self.logger.error(f"Error checking domain controller: {str(e)}")
            return False
            
    def _exploit_domain_controller(self):
        """Exploit domain controller scenarios"""
        findings = {
            'domain_info': self._gather_domain_info(),
            'certificate_services': self._check_certificate_services(),
            'smb_shares': self._check_smb_shares(),
            'ldap_enumeration': self._enumerate_ldap()
        }
        
        # Save findings
        self._save_findings(findings, 'domain_controller')
        return findings
        
    def _exploit_standalone_server(self):
        """Exploit standalone Windows server scenarios"""
        findings = {
            'local_auth': self._check_local_auth(),
            'service_vulns': self._check_service_vulnerabilities(),
            'web_apps': self._check_web_applications(),
            'database_services': self._check_database_services()
        }
        
        # Save findings
        self._save_findings(findings, 'standalone_server')
        return findings
        
    def _gather_domain_info(self):
        """Gather domain information using enum4linux"""
        findings = {}
        
        try:
            # Run enum4linux
            cmd = f"enum4linux -a {self.target}"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['enum4linux_output'] = result.stdout
                
            # Extract domain information
            domain_info = {}
            for line in result.stdout.split('\n'):
                if 'Domain Name:' in line:
                    domain_info['name'] = line.split(':')[1].strip()
                elif 'Domain SID:' in line:
                    domain_info['sid'] = line.split(':')[1].strip()
                    
            findings['domain_info'] = domain_info
        except Exception as e:
            self.logger.error(f"Error gathering domain info: {str(e)}")
            
        return findings
        
    def _check_certificate_services(self):
        """Check for certificate services"""
        findings = {}
        
        try:
            # Check for ADCS web enrollment
            urls = [
                f"http://{self.target}/certsrv/",
                f"https://{self.target}/certsrv/",
                f"http://{self.target}/ADCertificateServices/",
                f"https://{self.target}/ADCertificateServices/"
            ]
            
            for url in urls:
                try:
                    response = requests.get(url, verify=False, timeout=5)
                    if response.status_code < 400:
                        findings['web_enrollment'] = {
                            'url': url,
                            'status_code': response.status_code
                        }
                except:
                    continue
                    
            # Check for certipy
            cmd = f"certipy find -u '' -p '' -dc-ip {self.target}"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['certipy_output'] = result.stdout
        except Exception as e:
            self.logger.error(f"Error checking certificate services: {str(e)}")
            
        return findings
        
    def _check_smb_shares(self):
        """Check SMB shares and permissions"""
        findings = {}
        
        try:
            # Check for anonymous access
            cmd = f"smbclient -L //{self.target} -N"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['anonymous_access'] = True
                findings['shares'] = self._parse_smb_shares(result.stdout)
                
            # Check share permissions
            cmd = f"smbmap -H {self.target}"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['share_permissions'] = result.stdout
        except Exception as e:
            self.logger.error(f"Error checking SMB shares: {str(e)}")
            
        return findings
        
    def _enumerate_ldap(self):
        """Enumerate LDAP directory"""
        findings = {}
        
        try:
            # Basic LDAP enumeration
            cmd = f"ldapsearch -x -H ldap://{self.target} -b '' -s base"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['ldap_base'] = result.stdout
                
            # Enumerate users
            cmd = f"ldapsearch -x -H ldap://{self.target} -b 'DC=domain,DC=com' 'objectClass=user'"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['users'] = result.stdout
        except Exception as e:
            self.logger.error(f"Error enumerating LDAP: {str(e)}")
            
        return findings
        
    def _check_local_auth(self):
        """Check local authentication"""
        findings = {}
        
        try:
            # Check for null sessions
            cmd = f"netexec smb {self.target} -u '' -p ''"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['null_session'] = True
                
            # Enumerate local users
            cmd = f"netexec smb {self.target} --users"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['local_users'] = result.stdout
        except Exception as e:
            self.logger.error(f"Error checking local auth: {str(e)}")
            
        return findings
        
    def _check_service_vulnerabilities(self):
        """Check for service vulnerabilities"""
        findings = {}
        
        try:
            # Run nmap vulnerability scripts
            nm = nmap.PortScanner()
            nm.scan(self.target, arguments='-sV --script vuln')
            
            for host in nm.all_hosts():
                for proto in nm[host].all_protocols():
                    ports = nm[host][proto].keys()
                    for port in ports:
                        if 'script' in nm[host][proto][port]:
                            findings[f"{proto}/{port}"] = nm[host][proto][port]['script']
        except Exception as e:
            self.logger.error(f"Error checking service vulnerabilities: {str(e)}")
            
        return findings
        
    def _check_web_applications(self):
        """Check web applications"""
        findings = {}
        
        try:
            # Check for IIS
            cmd = f"whatweb {self.target}"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['web_technologies'] = result.stdout
                
            # Check for common web vulnerabilities
            cmd = f"nikto -h {self.target}"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['nikto_scan'] = result.stdout
        except Exception as e:
            self.logger.error(f"Error checking web applications: {str(e)}")
            
        return findings
        
    def _check_database_services(self):
        """Check database services"""
        findings = {}
        
        try:
            # Check for SQL Server
            cmd = f"nmap -p 1433 --script ms-sql-* {self.target}"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['sql_server'] = result.stdout
                
            # Check for MySQL
            cmd = f"nmap -p 3306 --script mysql-* {self.target}"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['mysql'] = result.stdout
        except Exception as e:
            self.logger.error(f"Error checking database services: {str(e)}")
            
        return findings
        
    def _parse_smb_shares(self, output):
        """Parse SMB shares from output"""
        shares = []
        for line in output.split('\n'):
            if 'Disk' in line:
                share = line.split()[0]
                shares.append(share)
        return shares
        
    def _save_findings(self, findings, scenario):
        """Save exploitation findings to file"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = f"{self.output_dir}/{scenario}_{self.target}_{timestamp}.json"
            
            with open(output_file, 'w') as f:
                json.dump(findings, f, indent=4)
                
            self.logger.info(f"Exploitation findings saved to {output_file}")
        except Exception as e:
            self.logger.error(f"Error saving findings: {str(e)}") 