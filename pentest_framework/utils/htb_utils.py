#!/usr/bin/env python3
import os
import json
import requests
import subprocess
from datetime import datetime

class HTBUtils:
    def __init__(self, logger):
        self.logger = logger
        self.htb_api_url = "https://www.hackthebox.com/api/v4"
        self.htb_token = os.getenv("HTB_TOKEN")
        self.output_dir = "reports/htb"
        
        # Create output directory if it doesn't exist
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)
            
    def get_machine_info(self, machine_id):
        """Get machine information from HTB API"""
        try:
            headers = {
                "Authorization": f"Bearer {self.htb_token}",
                "User-Agent": "HTB-Framework"
            }
            response = requests.get(f"{self.htb_api_url}/machine/{machine_id}", headers=headers)
            return response.json()
        except Exception as e:
            self.logger.error(f"Error getting machine info: {str(e)}")
            return None
            
    def get_machine_ip(self, machine_id):
        """Get machine IP from HTB API"""
        try:
            headers = {
                "Authorization": f"Bearer {self.htb_token}",
                "User-Agent": "HTB-Framework"
            }
            response = requests.get(f"{self.htb_api_url}/machine/{machine_id}/ip", headers=headers)
            return response.json().get("ip")
        except Exception as e:
            self.logger.error(f"Error getting machine IP: {str(e)}")
            return None
            
    def save_machine_info(self, machine_id, info):
        """Save machine information to file"""
        try:
            output_file = f"{self.output_dir}/machine_{machine_id}_info.json"
            with open(output_file, 'w') as f:
                json.dump(info, f, indent=4)
            self.logger.info(f"Machine info saved to {output_file}")
        except Exception as e:
            self.logger.error(f"Error saving machine info: {str(e)}")
            
    def detect_os(self, target):
        """Detect operating system of target"""
        try:
            # Use nmap for OS detection
            nm = nmap.PortScanner()
            nm.scan(target, arguments='-O')
            
            if 'osmatch' in nm[target]:
                return {
                    'os_family': nm[target]['osmatch'][0]['osclass'][0]['osfamily'],
                    'os_details': nm[target]['osmatch'][0]['name'],
                    'accuracy': nm[target]['osmatch'][0]['accuracy']
                }
            return None
        except Exception as e:
            self.logger.error(f"Error detecting OS: {str(e)}")
            return None
            
    def check_common_ports(self, target):
        """Check common ports for initial reconnaissance"""
        try:
            nm = nmap.PortScanner()
            nm.scan(target, arguments='-sS -sV -F')
            
            open_ports = []
            for host in nm.all_hosts():
                for proto in nm[host].all_protocols():
                    ports = nm[host][proto].keys()
                    for port in ports:
                        service = nm[host][proto][port]
                        open_ports.append({
                            'port': port,
                            'protocol': proto,
                            'state': service['state'],
                            'name': service['name'],
                            'product': service.get('product', ''),
                            'version': service.get('version', '')
                        })
            return open_ports
        except Exception as e:
            self.logger.error(f"Error checking ports: {str(e)}")
            return []
            
    def check_web_services(self, target, ports):
        """Check for web services on specified ports"""
        web_services = {}
        for port in ports:
            try:
                # Try HTTP
                response = requests.get(f"http://{target}:{port}", timeout=5)
                if response.status_code < 400:
                    web_services[port] = {
                        'protocol': 'http',
                        'status_code': response.status_code,
                        'server': response.headers.get('Server', ''),
                        'title': self._extract_title(response.text)
                    }
            except:
                try:
                    # Try HTTPS
                    response = requests.get(f"https://{target}:{port}", timeout=5, verify=False)
                    if response.status_code < 400:
                        web_services[port] = {
                            'protocol': 'https',
                            'status_code': response.status_code,
                            'server': response.headers.get('Server', ''),
                            'title': self._extract_title(response.text)
                        }
                except:
                    continue
        return web_services
        
    def _extract_title(self, html):
        """Extract page title from HTML"""
        import re
        match = re.search('<title>(.*?)</title>', html, re.IGNORECASE)
        return match.group(1) if match else ''
        
    def check_smb_shares(self, target):
        """Check SMB shares on target"""
        try:
            # Use smbclient to list shares
            cmd = f"smbclient -L //{target} -N"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            shares = []
            for line in result.stdout.split('\n'):
                if 'Disk' in line:
                    share = line.split()[0]
                    shares.append(share)
            return shares
        except Exception as e:
            self.logger.error(f"Error checking SMB shares: {str(e)}")
            return []
            
    def check_ftp_anonymous(self, target):
        """Check for anonymous FTP access"""
        try:
            # Use ftp command to check anonymous access
            cmd = f"ftp -n {target}"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if "Anonymous access granted" in result.stdout:
                return True
            return False
        except Exception as e:
            self.logger.error(f"Error checking FTP anonymous access: {str(e)}")
            return False
            
    def check_ssh_version(self, target):
        """Check SSH version and configuration"""
        try:
            # Use nmap to check SSH version
            nm = nmap.PortScanner()
            nm.scan(target, arguments='-p 22 -sV')
            
            if '22' in nm[target]['tcp']:
                return {
                    'version': nm[target]['tcp'][22]['version'],
                    'product': nm[target]['tcp'][22].get('product', ''),
                    'state': nm[target]['tcp'][22]['state']
                }
            return None
        except Exception as e:
            self.logger.error(f"Error checking SSH version: {str(e)}")
            return None 