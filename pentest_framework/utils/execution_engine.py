#!/usr/bin/env python3
import logging
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Dict, List, Any, Callable, Optional
from dataclasses import dataclass
import subprocess

@dataclass
class Task:
    name: str
    function: Callable
    args: tuple
    kwargs: dict
    priority: int = 0

class ExecutionEngine:
    def __init__(self, max_workers: int = 10, logger: Optional[logging.Logger] = None):
        self.max_workers = max_workers
        self.logger = logger or logging.getLogger(__name__)
        self.tasks: List[Task] = []
        self.results: Dict[str, Any] = {}
    
    def add_task(self, name: str, function: Callable, *args, priority: int = 0, **kwargs) -> None:
        """Add a task to the execution queue"""
        self.tasks.append(Task(name, function, args, kwargs, priority))
    
    def run_parallel(self) -> Dict[str, Any]:
        """Execute all tasks in parallel with proper error handling"""
        self.logger.info(f"Starting parallel execution with {self.max_workers} workers")
        
        # Sort tasks by priority (higher priority first)
        sorted_tasks = sorted(self.tasks, key=lambda x: x.priority, reverse=True)
        
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            # Submit all tasks
            future_to_task = {
                executor.submit(task.function, *task.args, **task.kwargs): task
                for task in sorted_tasks
            }
            
            # Process results as they complete
            for future in as_completed(future_to_task):
                task = future_to_task[future]
                try:
                    result = future.result()
                    self.results[task.name] = result
                    self.logger.info(f"Task '{task.name}' completed successfully")
                except Exception as e:
                    self.results[task.name] = {"error": str(e)}
                    self.logger.error(f"Task '{task.name}' failed: {str(e)}")
        
        return self.results
    
    def get_results(self) -> Dict[str, Any]:
        """Get the results of all executed tasks"""
        return self.results
    
    def clear_tasks(self) -> None:
        """Clear all tasks and results"""
        self.tasks.clear()
        self.results.clear()
    
    def optimize_port_scanning(self, target: str, quick_scan_cmd: str, detailed_scan_cmd: str) -> Dict[str, Any]:
        """Two-phase port scanning for efficiency"""
        results = {}
        
        # Phase 1: Quick scan for common ports
        self.logger.info("Performing quick port scan...")
        quick_results = self.run_command(quick_scan_cmd)
        if quick_results:
            results["quick_scan"] = quick_results
            
            # Parse active hosts from quick scan
            active_hosts = self._parse_active_hosts(quick_results)
            if active_hosts:
                # Phase 2: Detailed scan only on hosts with open ports
                self.logger.info("Performing detailed scan on active hosts...")
                detailed_scan_cmd = detailed_scan_cmd.format(targets=" ".join(active_hosts))
                detailed_results = self.run_command(detailed_scan_cmd)
                if detailed_results:
                    results["detailed_scan"] = detailed_results
        
        return results
    
    def _parse_active_hosts(self, scan_output: str) -> List[str]:
        """Parse active hosts from scan output"""
        active_hosts = []
        for line in scan_output.split("\n"):
            if "Nmap scan report for" in line:
                # Extract IP address or hostname
                host = line.split("for")[-1].strip()
                active_hosts.append(host)
        return active_hosts
    
    def run_command(self, command: str) -> Optional[str]:
        """Run a system command and return the output"""
        try:
            result = subprocess.run(command.split(), capture_output=True, text=True)
            if result.returncode != 0:
                self.logger.error(f"Command failed: {result.stderr}")
                return None
            return result.stdout
        except Exception as e:
            self.logger.error(f"Error executing command: {str(e)}")
            return None 