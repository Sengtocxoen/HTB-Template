#!/usr/bin/env python3
import subprocess
import os
import json
import requests
import dns.resolver
import whois
import socket
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor

class InformationGathering:
    def __init__(self, target, logger, tool_manager=None, execution_engine=None, use_headers=False, custom_headers=None):
        self.target = target
        self.logger = logger
        self.tool_manager = tool_manager
        self.execution_engine = execution_engine
        self.use_headers = use_headers
        self.custom_headers = custom_headers or {
            "User-Agent": "Mozilla/5.0 (compatible; SecurityScanner/1.0)",
            "Accept": "*/*"
        }
        self.findings = {
            "osint": {},
            "infrastructure": {},
            "services": {},
            "hosts": {}
        }
        self.output_dir = f"reports/info_gathering_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        os.makedirs(self.output_dir, exist_ok=True)

    def _get_header_string(self):
        """Get header string for command line tools"""
        if not self.use_headers:
            return ""
        header_str = " ".join([f"--header='{k}: {v}'" for k, v in self.custom_headers.items()])
        return header_str

    def run(self):
        """Run all information gathering tasks"""
        self.logger.info("Starting Information Gathering phase...")
        
        # 1. Open Source Intelligence (OSINT)
        self.logger.info("Performing OSINT gathering...")
        self.findings["osint"] = self.run_osint()
        
        # 2. Infrastructure Enumeration
        self.logger.info("Performing infrastructure enumeration...")
        self.findings["infrastructure"] = self.run_infrastructure_enumeration()
        
        # 3. Service Enumeration
        self.logger.info("Performing service enumeration...")
        self.findings["services"] = self.run_service_enumeration()
        
        # 4. Host Enumeration
        self.logger.info("Performing host enumeration...")
        self.findings["hosts"] = self.run_host_enumeration()
        
        # Save findings to JSON for other stages
        self._save_findings()
        
        return self.findings

    def _save_findings(self):
        """Save findings to JSON file for use in other stages"""
        output_file = f"{self.output_dir}/findings.json"
        with open(output_file, 'w') as f:
            json.dump(self.findings, f, indent=4)
        self.logger.info(f"Findings saved to {output_file}")

    def run_command(self, command, capture_output=True):
        """Run a system command and return the output"""
        if self.tool_manager:
            return self.tool_manager.run_tool(command.split()[0], command, capture_output)
        else:
            try:
                result = subprocess.run(command.split(), capture_output=capture_output, text=True)
                if result.returncode != 0:
                    self.logger.error(f"Command failed: {result.stderr}")
                    return None
                return result.stdout
            except Exception as e:
                self.logger.error(f"Error executing command: {str(e)}")
                return None

    def run_osint(self):
        """Perform OSINT gathering"""
        self.logger.info("Starting OSINT gathering...")
        
        # Add tasks to execution engine if available
        if self.execution_engine:
            # Basic WHOIS and DNS checks first
            self.execution_engine.add_task("whois", self.run_command, f"whois {self.target}", priority=1)
            self.execution_engine.add_task("dns", self.run_command, f"dig +short {self.target}", priority=2)
            
            # Run initial tasks
            initial_results = self.execution_engine.run_parallel()
            self.findings["osint"].update(initial_results)
            
            # Clear tasks for next batch
            self.execution_engine.clear_tasks()
            
            # More intensive scans if initial checks succeed
            if initial_results.get("dns"):
                self.execution_engine.add_task("subfinder", self.run_command, 
                    f"subfinder -d {self.target} -silent -t 100", priority=3)
                self.execution_engine.add_task("amass", self.run_command, 
                    f"amass enum -passive -d {self.target} -timeout 5", priority=4)
                self.execution_engine.add_task("theharvester", self.run_command, 
                    f"theHarvester -d {self.target} -b all -l 100", priority=5)
                
                # Run secondary tasks
                secondary_results = self.execution_engine.run_parallel()
                self.findings["osint"].update(secondary_results)
        else:
            # Fallback to sequential execution with timeouts
            self.findings["osint"]["whois"] = self.run_command(f"whois {self.target}")
            self.findings["osint"]["dns"] = self.run_command(f"dig +short {self.target}")
            
            if self.findings["osint"].get("dns"):
                self.findings["osint"]["subfinder"] = self.run_command(
                    f"subfinder -d {self.target} -silent -t 100")
                self.findings["osint"]["amass"] = self.run_command(
                    f"amass enum -passive -d {self.target} -timeout 5")
                self.findings["osint"]["theharvester"] = self.run_command(
                    f"theHarvester -d {self.target} -b all -l 100")

    def run_infrastructure_enumeration(self):
        """Perform infrastructure enumeration"""
        self.logger.info("Starting infrastructure enumeration...")
        
        # Custom headers for scanning
        headers = {
            "User-Agent": "Mozilla/5.0 (compatible; SecurityScanner/1.0)",
            "Accept": "*/*"
        }
        
        # Add tasks to execution engine if available
        if self.execution_engine:
            # Quick scan first
            self.execution_engine.add_task("nmap_quick", self.run_command, 
                f"nmap -sV -sC -T4 --max-retries 2 --max-rtt-timeout 500ms {self.target}", priority=1)
            
            # Run quick scan
            quick_results = self.execution_engine.run_parallel()
            self.findings["infrastructure"].update(quick_results)
            
            # Clear tasks for next batch
            self.execution_engine.clear_tasks()
            
            # Full scan only if quick scan found open ports
            if quick_results.get("nmap_quick"):
                self.execution_engine.add_task("nmap_full", self.run_command, 
                    f"nmap -p- -T4 --max-retries 2 --max-rtt-timeout 500ms {self.target}", priority=2)
                
                # Run full scan
                full_results = self.execution_engine.run_parallel()
                self.findings["infrastructure"].update(full_results)
        else:
            # Fallback to sequential execution
            self.findings["infrastructure"]["nmap_quick"] = self.run_command(
                f"nmap -sV -sC -T4 --max-retries 2 --max-rtt-timeout 500ms {self.target}")
            
            if self.findings["infrastructure"].get("nmap_quick"):
                self.findings["infrastructure"]["nmap_full"] = self.run_command(
                    f"nmap -p- -T4 --max-retries 2 --max-rtt-timeout 500ms {self.target}")

    def run_service_enumeration(self):
        """Perform service enumeration"""
        self.logger.info("Starting service enumeration...")
        
        # Add tasks to execution engine if available
        if self.execution_engine:
            header_str = self._get_header_string()
            self.execution_engine.add_task("whatweb", self.run_command, 
                f"whatweb -v {header_str} {self.target}", priority=1)
            
            # Run all tasks in parallel
            results = self.execution_engine.run_parallel()
            self.findings["services"] = results
        else:
            # Fallback to sequential execution
            header_str = self._get_header_string()
            self.findings["services"]["whatweb"] = self.run_command(
                f"whatweb -v {header_str} {self.target}")

    def run_host_enumeration(self):
        """Perform host enumeration"""
        self.logger.info("Starting host enumeration...")
        
        # Add tasks to execution engine if available
        if self.execution_engine:
            # Quick OS detection first
            self.execution_engine.add_task("nmap_os", self.run_command, 
                f"nmap -O --osscan-limit --max-os-tries 1 -T4 {self.target}", priority=1)
            
            # Run OS detection
            os_results = self.execution_engine.run_parallel()
            self.findings["hosts"].update(os_results)
            
            # Clear tasks for next batch
            self.execution_engine.clear_tasks()
            
            # Vulnerability scan only if OS detection succeeded
            if os_results.get("nmap_os"):
                self.execution_engine.add_task("nmap_vuln", self.run_command, 
                    f"nmap --script vuln --script-timeout 2m -T4 {self.target}", priority=2)
                
                # Run vulnerability scan
                vuln_results = self.execution_engine.run_parallel()
                self.findings["hosts"].update(vuln_results)
        else:
            # Fallback to sequential execution
            self.findings["hosts"]["nmap_os"] = self.run_command(
                f"nmap -O --osscan-limit --max-os-tries 1 -T4 {self.target}")
            
            if self.findings["hosts"].get("nmap_os"):
                self.findings["hosts"]["nmap_vuln"] = self.run_command(
                    f"nmap --script vuln --script-timeout 2m -T4 {self.target}")

    def osint_gathering(self):
        """Perform Open Source Intelligence gathering"""
        results = {}
        
        # 1. WHOIS Information
        self.logger.info("Gathering WHOIS information...")
        try:
            whois_info = whois.whois(self.target)
            results["whois"] = whois_info
        except Exception as e:
            self.logger.error(f"WHOIS lookup failed: {str(e)}")
        
        # 2. DNS Enumeration
        self.logger.info("Performing DNS enumeration...")
        dns_records = self._enumerate_dns()
        results["dns"] = dns_records
        
        # 3. Subdomain Enumeration
        self.logger.info("Enumerating subdomains...")
        subdomains = self._enumerate_subdomains()
        results["subdomains"] = subdomains
        
        # 4. Social Media and Web Presence
        self.logger.info("Checking social media and web presence...")
        web_presence = self._check_web_presence()
        results["web_presence"] = web_presence
        
        return results

    def _enumerate_dns(self):
        """Enumerate DNS records"""
        results = {}
        record_types = ['A', 'AAAA', 'MX', 'NS', 'TXT', 'SOA']
        
        for record_type in record_types:
            try:
                answers = dns.resolver.resolve(self.target, record_type)
                results[record_type] = [str(rdata) for rdata in answers]
            except Exception as e:
                self.logger.error(f"DNS {record_type} lookup failed: {str(e)}")
                
        return results

    def _enumerate_subdomains(self):
        """Enumerate subdomains using various tools"""
        results = {}
        
        # Using subfinder
        self.logger.info("Running subfinder...")
        subfinder_cmd = f"subfinder -d {self.target} -o {self.output_dir}/subfinder.txt"
        subfinder_result = self.run_command(subfinder_cmd)
        if subfinder_result:
            results["subfinder"] = subfinder_result
            
        # Using amass
        self.logger.info("Running amass...")
        amass_cmd = f"amass enum -passive -d {self.target} -o {self.output_dir}/amass.txt"
        amass_result = self.run_command(amass_cmd)
        if amass_result:
            results["amass"] = amass_result
            
        return results

    def _check_web_presence(self):
        """Check web presence and social media"""
        results = {}
        
        # Using theHarvester
        self.logger.info("Running theHarvester...")
        harvester_cmd = f"theHarvester -d {self.target} -b all -l 500 -o {self.output_dir}/harvester.txt"
        harvester_result = self.run_command(harvester_cmd)
        if harvester_result:
            results["harvester"] = harvester_result
            
        return results

    def infrastructure_enumeration(self):
        """Enumerate infrastructure information"""
        results = {}
        
        # 1. Network Range Discovery
        self.logger.info("Discovering network ranges...")
        network_info = self._discover_network_ranges()
        results["network_ranges"] = network_info
        
        # 2. ASN Information
        self.logger.info("Gathering ASN information...")
        asn_info = self._gather_asn_info()
        results["asn"] = asn_info
        
        # 3. Cloud Infrastructure Detection
        self.logger.info("Detecting cloud infrastructure...")
        cloud_info = self._detect_cloud_infrastructure()
        results["cloud"] = cloud_info
        
        return results

    def _discover_network_ranges(self):
        """Discover network ranges"""
        results = {}
        
        # Using nmap for network discovery
        self.logger.info("Running nmap network discovery...")
        nmap_cmd = f"nmap -sn {self.target}/24 -oN {self.output_dir}/network_discovery.txt"
        nmap_result = self.run_command(nmap_cmd)
        if nmap_result:
            results["nmap"] = nmap_result
            
        return results

    def _gather_asn_info(self):
        """Gather ASN information"""
        results = {}
        
        # Using asnlookup
        self.logger.info("Running asnlookup...")
        asn_cmd = f"asnlookup -o {self.output_dir}/asn.txt {self.target}"
        asn_result = self.run_command(asn_cmd)
        if asn_result:
            results["asnlookup"] = asn_result
            
        return results

    def _detect_cloud_infrastructure(self):
        """Detect cloud infrastructure"""
        results = {}
        
        # Using cloudlist
        self.logger.info("Running cloudlist...")
        cloud_cmd = f"cloudlist -d {self.target} -o {self.output_dir}/cloud.txt"
        cloud_result = self.run_command(cloud_cmd)
        if cloud_result:
            results["cloudlist"] = cloud_result
            
        return results

    def service_enumeration(self):
        """Enumerate services"""
        results = {}
        
        # 1. Port Scanning
        self.logger.info("Performing port scanning...")
        port_scan = self._perform_port_scan()
        results["ports"] = port_scan
        
        # 2. Service Version Detection
        self.logger.info("Detecting service versions...")
        service_versions = self._detect_service_versions()
        results["versions"] = service_versions
        
        # 3. Web Technology Detection
        self.logger.info("Detecting web technologies...")
        web_tech = self._detect_web_technologies()
        results["web_tech"] = web_tech
        
        return results

    def _perform_port_scan(self):
        """Perform comprehensive port scanning"""
        results = {}
        
        # Using nmap for port scanning
        self.logger.info("Running nmap port scan...")
        nmap_cmd = f"nmap -p- -sV -sC -oN {self.output_dir}/port_scan.txt {self.target}"
        nmap_result = self.run_command(nmap_cmd)
        if nmap_result:
            results["nmap"] = nmap_result
            
        # Using masscan for quick port scanning
        self.logger.info("Running masscan...")
        masscan_cmd = f"masscan {self.target} -p1-65535 --rate=1000 -oJ {self.output_dir}/masscan.json"
        masscan_result = self.run_command(masscan_cmd)
        if masscan_result:
            results["masscan"] = masscan_result
            
        return results

    def _detect_service_versions(self):
        """Detect service versions"""
        results = {}
        
        # Using nmap service detection
        self.logger.info("Running nmap service detection...")
        nmap_cmd = f"nmap -sV -sC -oN -A {self.output_dir}/service_versions.txt {self.target}"
        nmap_result = self.run_command(nmap_cmd)
        if nmap_result:
            results["nmap"] = nmap_result
            
        return results

    def _detect_web_technologies(self):
        """Detect web technologies"""
        results = {}
        
        # Using whatweb
        self.logger.info("Running whatweb...")
        header_str = self._get_header_string()
        whatweb_cmd = f"whatweb -v {header_str} {self.target} -o {self.output_dir}/whatweb.txt"
        whatweb_result = self.run_command(whatweb_cmd)
        if whatweb_result:
            results["whatweb"] = whatweb_result
            
        # Using wappy
        self.logger.info("Running wappy...")
        wappy_cmd = f"wappy  -u {self.target} -wf {self.output_dir}/wappy.txt"
        wappy_result = self.run_command(wappy_cmd)
        if wappy_result:
            results["wappy"] = wappy_result
            
        return results

    def host_enumeration(self):
        """Enumerate host information"""
        results = {}
        
        # 1. Operating System Detection
        self.logger.info("Detecting operating system...")
        os_info = self._detect_os()
        results["os"] = os_info
        
        # 2. Host Discovery
        self.logger.info("Performing host discovery...")
        host_info = self._discover_hosts()
        results["hosts"] = host_info
        
        # 3. Vulnerability Scanning
        self.logger.info("Performing vulnerability scanning...")
        vuln_info = self._scan_vulnerabilities()
        results["vulnerabilities"] = vuln_info
        
        return results

    def _detect_os(self):
        """Detect operating system"""
        results = {}
        
        # Using nmap OS detection
        self.logger.info("Running nmap OS detection...")
        nmap_cmd = f"nmap -O -oN {self.output_dir}/os_detection.txt {self.target}"
        nmap_result = self.run_command(nmap_cmd)
        if nmap_result:
            results["nmap"] = nmap_result
            
        return results

    def _discover_hosts(self):
        """Discover hosts"""
        results = {}
        
        # Using nmap host discovery
        self.logger.info("Running nmap host discovery...")
        nmap_cmd = f"nmap -sn -PR -PS22,25,80,443,3389 -PA21,23,80,3389 -PE -PP -oN {self.output_dir}/host_discovery.txt {self.target}/24"
        nmap_result = self.run_command(nmap_cmd)
        if nmap_result:
            results["nmap"] = nmap_result
            
        return results

    def _scan_vulnerabilities(self):
        """Scan for vulnerabilities"""
        results = {}
        
        # Using nmap vulnerability scripts
        self.logger.info("Running nmap vulnerability scripts...")
        nmap_cmd = f"nmap -sV --script vuln -oN {self.output_dir}/vulnerability_scan.txt {self.target}"
        nmap_result = self.run_command(nmap_cmd)
        if nmap_result:
            results["nmap"] = nmap_result
            
        return results 