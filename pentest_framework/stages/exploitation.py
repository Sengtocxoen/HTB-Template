#!/usr/bin/env python3
import subprocess
import os
import json
import logging
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass

@dataclass
class AttackVector:
    name: str
    description: str
    cvss_score: float
    complexity: str  # "Easy", "Medium", "Hard"
    probability_of_success: int  # 1-10
    probability_of_damage: int  # 1-10
    requires_local_testing: bool
    poc_available: bool
    poc_location: Optional[str]
    target_service: str
    target_version: str

class BaseExploitation:
    def __init__(self, target, logger, config):
        self.target = target
        self.logger = logger
        self.config = config
        self.tools_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'tools')
        self.output_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'reports', 'scans')
        self.attack_vectors = []
        self.findings = []
        
        # Create output directory if it doesn't exist
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)
            
    def _run_command(self, command: str) -> str:
        """Execute a command and return its output."""
        try:
            result = subprocess.run(
                command.split(),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            if result.returncode != 0:
                if self.logger:
                    self.logger.error(f"Command failed: {command}")
                    self.logger.error(f"Error: {result.stderr}")
                return ""
            return result.stdout
        except Exception as e:
            if self.logger:
                self.logger.error(f"Error executing command {command}: {str(e)}")
            return ""

    def _save_findings(self, findings: List[Dict], filename: str):
        """Save findings to a JSON file."""
        os.makedirs('reports', exist_ok=True)
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        output_file = f'reports/{filename}_{timestamp}.json'
        
        with open(output_file, 'w') as f:
            json.dump(findings, f, indent=4)
        
        if self.logger:
            self.logger.info(f"Findings saved to {output_file}")

    def _save_output(self, content, filename):
        """Save output to file"""
        try:
            output_path = os.path.join(self.output_dir, filename)
            with open(output_path, 'w') as f:
                f.write(content)
            self.logger.info(f"Output saved to {output_path}")
            return output_path
        except Exception as e:
            self.logger.error(f"Error saving output: {str(e)}")
            return None

    def run_initial_scan(self):
        """Run initial port scan"""
        self.logger.info(f"Running initial scan on {self.target}")
        
        try:
            # Run masscan for quick port discovery
            masscan_cmd = f"masscan {self.target} -p1-65535 --rate=1000 -oJ {os.path.join(self.output_dir, 'masscan.json')}"
            self.logger.info(f"Running masscan: {masscan_cmd}")
            subprocess.run(masscan_cmd.split(), check=True)
            
            # Run nmap for detailed service scan
            nmap_cmd = f"nmap -sV -sC -p- {self.target} -oN {os.path.join(self.output_dir, 'nmap.txt')} -oX {os.path.join(self.output_dir, 'nmap.xml')}"
            self.logger.info(f"Running nmap: {nmap_cmd}")
            subprocess.run(nmap_cmd.split(), check=True)
            
            # Run default nmap scripts
            nmap_scripts_cmd = f"nmap -sC -sV -p- {self.target} -oN {os.path.join(self.output_dir, 'nmap_scripts.txt')}"
            self.logger.info(f"Running nmap scripts: {nmap_scripts_cmd}")
            subprocess.run(nmap_scripts_cmd.split(), check=True)
            
            return {
                'masscan': os.path.join(self.output_dir, 'masscan.json'),
                'nmap': os.path.join(self.output_dir, 'nmap.txt'),
                'nmap_xml': os.path.join(self.output_dir, 'nmap.xml'),
                'nmap_scripts': os.path.join(self.output_dir, 'nmap_scripts.txt')
            }
        except Exception as e:
            self.logger.error(f"Error during initial scan: {str(e)}")
            return {}

    def run(self):
        """Base run method to be implemented by subclasses"""
        raise NotImplementedError("Subclasses must implement run() method")

class WindowsExploitation(BaseExploitation):
    def __init__(self, target, logger, config):
        super().__init__(target, logger, config)
        self.os_type = "windows"

    def check_domain_controller(self):
        """Check if target is a domain controller"""
        self.logger.info("Checking for domain controller...")
        
        try:
            # Check common DC ports
            ports = [88, 389, 636, 445, 3268, 3269]
            results = {}
            
            for port in ports:
                nmap_cmd = f"nmap -p{port} -sV {self.target} -oN {os.path.join(self.output_dir, f'dc_port_{port}.txt')}"
                self.logger.info(f"Checking port {port}: {nmap_cmd}")
                subprocess.run(nmap_cmd.split(), check=True)
                results[f'port_{port}'] = os.path.join(self.output_dir, f'dc_port_{port}.txt')
            
            # Run enum4linux
            enum_cmd = f"enum4linux -a {self.target} -o {os.path.join(self.output_dir, 'enum4linux.txt')}"
            self.logger.info(f"Running enum4linux: {enum_cmd}")
            subprocess.run(enum_cmd.split(), check=True)
            results['enum4linux'] = os.path.join(self.output_dir, 'enum4linux.txt')
            
            return results
        except Exception as e:
            self.logger.error(f"Error checking domain controller: {str(e)}")
            return {}

    def exploit_domain_controller(self):
        """Exploit domain controller scenario."""
        if not self.check_domain_controller():
            return

        # Domain information gathering with enum4linux
        enum_cmd = f"enum4linux -a {self.target}"
        enum_output = self._run_command(enum_cmd)
        
        if enum_output:
            self.findings.append({
                "type": "domain_enumeration",
                "details": "Domain information gathered",
                "data": enum_output
            })

        # Certificate services assessment
        cert_cmd = f"certipy find -u '' -p '' -dc-ip {self.target}"
        cert_output = self._run_command(cert_cmd)
        
        if cert_output:
            self.findings.append({
                "type": "certificate_services",
                "details": "Certificate services assessment",
                "data": cert_output
            })

        # LDAP enumeration
        ldap_cmd = f"ldapsearch -x -h {self.target} -b 'dc=domain,dc=com'"
        ldap_output = self._run_command(ldap_cmd)
        
        if ldap_output:
            self.findings.append({
                "type": "ldap_enumeration",
                "details": "LDAP enumeration successful",
                "data": ldap_output
            })

        # RPC enumeration
        rpc_cmd = f"rpcclient -U '' -N {self.target}"
        rpc_output = self._run_command(rpc_cmd)
        
        if rpc_output:
            self.findings.append({
                "type": "rpc_enumeration",
                "details": "RPC enumeration results",
                "data": rpc_output
            })

        # Kerberos enumeration
        kerbrute_cmd = f"kerbrute userenum --dc {self.target} -d domain.com /usr/share/wordlists/SecLists/Usernames/Names/names.txt"
        kerbrute_output = self._run_command(kerbrute_cmd)
        
        if kerbrute_output:
            self.findings.append({
                "type": "kerberos_enumeration",
                "details": "Kerberos user enumeration results",
                "data": kerbrute_output
            })

        # BloodHound data collection
        bloodhound_cmd = f"bloodhound-python -d domain.com -u '' -p '' -ns {self.target} -c all"
        bloodhound_output = self._run_command(bloodhound_cmd)
        
        if bloodhound_output:
            self.findings.append({
                "type": "bloodhound_collection",
                "details": "BloodHound data collection results",
                "data": bloodhound_output
            })

        # Check for AS-REP Roasting
        asrep_cmd = f"GetNPUsers.py domain.com/ -no-pass -dc-ip {self.target}"
        asrep_output = self._run_command(asrep_cmd)
        
        if asrep_output:
            self.findings.append({
                "type": "asrep_roasting",
                "details": "AS-REP Roasting check results",
                "data": asrep_output
            })

        # Check for Kerberoasting
        kerberoast_cmd = f"GetUserSPNs.py domain.com/ -no-pass -dc-ip {self.target}"
        kerberoast_output = self._run_command(kerberoast_cmd)
        
        if kerberoast_output:
            self.findings.append({
                "type": "kerberoasting",
                "details": "Kerberoasting check results",
                "data": kerberoast_output
            })

    def exploit_standalone_server(self):
        """Exploit standalone server scenario."""
        # SMB enumeration
        smb_cmd = f"smbclient -L //{self.target} -N"
        smb_output = self._run_command(smb_cmd)
        
        if smb_output:
            self.findings.append({
                "type": "smb_enumeration",
                "details": "SMB shares discovered",
                "data": smb_output
            })

        # Check for common Windows services
        nmap_cmd = f"nmap -p 445,3389,5985,5986 -sV {self.target}"
        nmap_output = self._run_command(nmap_cmd)
        
        if nmap_output:
            self.findings.append({
                "type": "service_enumeration",
                "details": "Windows services discovered",
                "data": nmap_output
            })

        # Try to enumerate users
        enum_cmd = f"enum4linux -a {self.target}"
        enum_output = self._run_command(enum_cmd)
        
        if enum_output:
            self.findings.append({
                "type": "user_enumeration",
                "details": "User enumeration results",
                "data": enum_output
            })

        # Check for Exchange server
        exchange_cmd = f"nmap -p 443 --script http-title {self.target}"
        exchange_output = self._run_command(exchange_cmd)
        
        if "Outlook" in exchange_output or "Exchange" in exchange_output:
            self.findings.append({
                "type": "exchange_server",
                "details": "Exchange server detected",
                "data": exchange_output
            })

        # WinRM enumeration
        winrm_cmd = f"crackmapexec winrm {self.target} -u '' -p ''"
        winrm_output = self._run_command(winrm_cmd)
        
        if winrm_output:
            self.findings.append({
                "type": "winrm_enumeration",
                "details": "WinRM enumeration results",
                "data": winrm_output
            })

        # MSSQL enumeration
        mssql_cmd = f"crackmapexec mssql {self.target} -u '' -p ''"
        mssql_output = self._run_command(mssql_cmd)
        
        if mssql_output:
            self.findings.append({
                "type": "mssql_enumeration",
                "details": "MSSQL enumeration results",
                "data": mssql_output
            })

        # Run PowerUp.ps1 for privilege escalation
        powerup_path = os.path.join(self.tools_dir, 'PowerUp.ps1')
        if os.path.exists(powerup_path):
            powerup_cmd = f"powershell -ExecutionPolicy Bypass -File {powerup_path} -Command 'Invoke-AllChecks'"
            powerup_output = self._run_command(powerup_cmd)
            
            if powerup_output:
                self.findings.append({
                    "type": "privilege_escalation",
                    "details": "PowerUp privilege escalation check",
                    "data": powerup_output
                })

        # Check for common Windows vulnerabilities
        windows_vuln_cmd = f"nmap -p 445 --script smb-vuln* {self.target}"
        windows_vuln_output = self._run_command(windows_vuln_cmd)
        
        if windows_vuln_output:
            self.findings.append({
                "type": "windows_vulnerabilities",
                "details": "Windows vulnerability scan results",
                "data": windows_vuln_output
            })

        # Check for RDP vulnerabilities
        rdp_cmd = f"nmap -p 3389 --script rdp-* {self.target}"
        rdp_output = self._run_command(rdp_cmd)
        
        if rdp_output:
            self.findings.append({
                "type": "rdp_vulnerabilities",
                "details": "RDP vulnerability scan results",
                "data": rdp_output
            })

    def run(self):
        """Run Windows exploitation"""
        self.logger.info("Starting Windows exploitation...")
        
        try:
            # Run initial scan
            scan_results = self.run_initial_scan()
            self.findings.append({
                "type": "initial_scan",
                "details": "Initial port scan results",
                "data": scan_results
            })
            
            # Check for domain controller
            dc_results = self.check_domain_controller()
            if dc_results:
                self.findings.append({
                    "type": "domain_controller",
                    "details": "Domain controller checks",
                    "data": dc_results
                })
                # Run domain controller exploitation
                self.exploit_domain_controller()
            else:
                # Run standalone server exploitation
                self.exploit_standalone_server()
            
            return {
                "findings": self.findings,
                "attack_vectors": self.attack_vectors
            }
            
        except Exception as e:
            self.logger.error(f"Error during Windows exploitation: {str(e)}")
            return {
                "error": str(e),
                "findings": self.findings,
                "attack_vectors": self.attack_vectors
            }

class LinuxExploitation(BaseExploitation):
    def __init__(self, target, logger, config):
        super().__init__(target, logger, config)
        self.os_type = "linux"

    def check_web_server(self) -> bool:
        """Check if target is a web server."""
        nmap_cmd = f"nmap -p 80,443,8080,8443 -sV {self.target}"
        output = self._run_command(nmap_cmd)
        
        if "80/tcp" in output or "443/tcp" in output:
            self.findings.append({
                "type": "web_server",
                "details": "Web server detected",
                "ports": [80, 443, 8080, 8443]
            })
            return True
        return False

    def exploit_web_server(self):
        """Exploit web server scenario."""
        if not self.check_web_server():
            return

        # Web technology identification
        whatweb_cmd = f"whatweb -a 3 http://{self.target}"
        whatweb_output = self._run_command(whatweb_cmd)
        
        if whatweb_output:
            self.findings.append({
                "type": "web_technology",
                "details": "Web technology identification",
                "data": whatweb_output
            })

        # Nikto scan
        nikto_cmd = f"nikto -h http://{self.target}"
        nikto_output = self._run_command(nikto_cmd)
        
        if nikto_output:
            self.findings.append({
                "type": "nikto_scan",
                "details": "Nikto vulnerability scan results",
                "data": nikto_output
            })

        # Directory enumeration
        gobuster_cmd = f"gobuster dir -u http://{self.target} -w /usr/share/wordlists/dirb/common.txt"
        gobuster_output = self._run_command(gobuster_cmd)
        
        if gobuster_output:
            self.findings.append({
                "type": "directory_enumeration",
                "details": "Directory enumeration results",
                "data": gobuster_output
            })

        # SQL injection check
        sqlmap_cmd = f"sqlmap -u http://{self.target} --batch --random-agent"
        sqlmap_output = self._run_command(sqlmap_cmd)
        
        if sqlmap_output:
            self.findings.append({
                "type": "sql_injection",
                "details": "SQL injection test results",
                "data": sqlmap_output
            })

        # XSS check
        xss_cmd = f"xsser --url http://{self.target} --auto"
        xss_output = self._run_command(xss_cmd)
        
        if xss_output:
            self.findings.append({
                "type": "xss_vulnerability",
                "details": "XSS vulnerability test results",
                "data": xss_output
            })

        # Check for common web vulnerabilities
        wapiti_cmd = f"wapiti -u http://{self.target} -m all"
        wapiti_output = self._run_command(wapiti_cmd)
        
        if wapiti_output:
            self.findings.append({
                "type": "web_vulnerabilities",
                "details": "Wapiti vulnerability scan results",
                "data": wapiti_output
            })

        # Check for file inclusion vulnerabilities
        ffuf_cmd = f"ffuf -u http://{self.target}/FUZZ -w /usr/share/wordlists/SecLists/Fuzzing/LFI/LFI-Jhaddix.txt"
        ffuf_output = self._run_command(ffuf_cmd)
        
        if ffuf_output:
            self.findings.append({
                "type": "file_inclusion",
                "details": "File inclusion vulnerability check",
                "data": ffuf_output
            })

        # Check for command injection
        commix_cmd = f"commix -u http://{self.target} --batch"
        commix_output = self._run_command(commix_cmd)
        
        if commix_output:
            self.findings.append({
                "type": "command_injection",
                "details": "Command injection vulnerability check",
                "data": commix_output
            })

    def exploit_standard_server(self):
        """Exploit standard Linux server scenario."""
        # Check for common Linux services
        nmap_cmd = f"nmap -p 21,22,23,25,3306,5432 -sV {self.target}"
        nmap_output = self._run_command(nmap_cmd)
        
        if nmap_output:
            self.findings.append({
                "type": "service_enumeration",
                "details": "Linux services discovered",
                "data": nmap_output
            })

        # SSH version check
        ssh_cmd = f"nc -v {self.target} 22"
        ssh_output = self._run_command(ssh_cmd)
        
        if ssh_output:
            self.findings.append({
                "type": "ssh_enumeration",
                "details": "SSH service information",
                "data": ssh_output
            })

        # Run LinPEAS for privilege escalation
        linpeas_output = self._run_linpeas()
        
        if linpeas_output:
            self.findings.append({
                "type": "privilege_escalation",
                "details": "LinPEAS privilege escalation check",
                "data": linpeas_output
            })

        # Run LinEnum for system enumeration
        linenum_cmd = f"linenum -h {self.target}"
        linenum_output = self._run_command(linenum_cmd)
        
        if linenum_output:
            self.findings.append({
                "type": "system_enumeration",
                "details": "LinEnum system enumeration",
                "data": linenum_output
            })

        # Check for common misconfigurations
        pspy_cmd = f"pspy -h {self.target}"
        pspy_output = self._run_command(pspy_cmd)
        
        if pspy_output:
            self.findings.append({
                "type": "process_monitoring",
                "details": "Process monitoring results",
                "data": pspy_output
            })

        # Check for SUID binaries
        find_cmd = f"find / -perm -4000 -type f -exec ls -la {{}} \\;"
        suid_output = self._run_command(find_cmd)
        
        if suid_output:
            self.findings.append({
                "type": "suid_binaries",
                "details": "SUID binaries found",
                "data": suid_output
            })

        # Check for world-writable files
        find_cmd = f"find / -perm -2 -type f -not -path '/proc/*' -exec ls -la {{}} \\;"
        writable_output = self._run_command(find_cmd)
        
        if writable_output:
            self.findings.append({
                "type": "world_writable_files",
                "details": "World-writable files found",
                "data": writable_output
            })

        # Check for kernel vulnerabilities
        kernel_cmd = f"uname -a"
        kernel_output = self._run_command(kernel_cmd)
        
        if kernel_output:
            self.findings.append({
                "type": "kernel_info",
                "details": "Kernel version information",
                "data": kernel_output
            })

        # Check for Docker containers
        docker_cmd = f"docker ps -a"
        docker_output = self._run_command(docker_cmd)
        
        if docker_output:
            self.findings.append({
                "type": "docker_containers",
                "details": "Docker container enumeration",
                "data": docker_output
            })

        # Check for common Linux vulnerabilities
        linux_vuln_cmd = f"nmap --script vuln -oA nmap_linux_vuln {self.target}"
        linux_vuln_output = self._run_command(linux_vuln_cmd)
        
        if linux_vuln_output:
            self.findings.append({
                "type": "linux_vulnerabilities",
                "details": "Linux vulnerability scan results",
                "data": linux_vuln_output
            })

    def _run_linpeas(self):
        """Run LinPEAS for privilege escalation checks"""
        self.logger.info("Running LinPEAS...")
        
        try:
            linpeas_path = os.path.join(self.tools_dir, 'linpeas.sh')
            if not os.path.exists(linpeas_path):
                self.logger.error("LinPEAS script not found")
                return None
                
            # Make script executable
            os.chmod(linpeas_path, 0o755)
            
            # Run LinPEAS with various options
            output_file = os.path.join(self.output_dir, 'linpeas_output.txt')
            linpeas_cmd = f"{linpeas_path} -a -s -t -P -p -c -i -l -e -n -o {output_file}"
            self.logger.info(f"Running LinPEAS: {linpeas_cmd}")
            subprocess.run(linpeas_cmd.split(), check=True)
            
            return output_file
        except Exception as e:
            self.logger.error(f"Error running LinPEAS: {str(e)}")
            return None

    def run(self):
        """Run Linux exploitation"""
        self.logger.info("Starting Linux exploitation...")
        
        try:
            # Run initial scan
            scan_results = self.run_initial_scan()
            self.findings.append({
                "type": "initial_scan",
                "details": "Initial port scan results",
                "data": scan_results
            })
            
            # Check for web server
            if self.check_web_server():
                self.exploit_web_server()
            else:
                self.exploit_standard_server()
            
            return {
                "findings": self.findings,
                "attack_vectors": self.attack_vectors
            }
            
        except Exception as e:
            self.logger.error(f"Error during Linux exploitation: {str(e)}")
            return {
                "error": str(e),
                "findings": self.findings,
                "attack_vectors": self.attack_vectors
            }

def get_exploitation_class(os_type: str):
    """Factory function to get the appropriate exploitation class."""
    if os_type.lower() == "windows":
        return WindowsExploitation
    elif os_type.lower() == "linux":
        return LinuxExploitation
    else:
        raise ValueError(f"Unsupported OS type: {os_type}") 