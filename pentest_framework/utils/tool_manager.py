#!/usr/bin/env python3
import subprocess
import logging
import shutil
from typing import Dict, List, Optional

class ToolManager:
    def __init__(self, logger: Optional[logging.Logger] = None):
        self.tools: Dict[str, bool] = {}
        self.logger = logger or logging.getLogger(__name__)
        self.required_tools = {
            "nmap": "nmap",
            "masscan": "masscan",
            "whatweb": "whatweb",
            "subfinder": "subfinder",
            "amass": "amass",
            "theharvester": "theHarvester",
            "dig": "dig",
            "whois": "whois",
            "wappy": "wappy"
        }
        self.verify_installations()
    
    def verify_installations(self) -> None:
        """Verify that required tools are installed before testing begins"""
        self.logger.info("Verifying required tool installations...")
        
        for tool, command in self.required_tools.items():
            try:
                # Use which/where to find the executable
                if shutil.which(command):
                    self.tools[tool] = True
                    self.logger.info(f"✓ {tool} is installed")
                else:
                    self.tools[tool] = False
                    self.logger.warning(f"✗ {tool} is not installed or not in PATH")
            except Exception as e:
                self.tools[tool] = False
                self.logger.error(f"Error checking {tool}: {str(e)}")
    
    def get_installed_tools(self) -> List[str]:
        """Get list of installed tools"""
        return [tool for tool, installed in self.tools.items() if installed]
    
    def get_missing_tools(self) -> List[str]:
        """Get list of missing tools"""
        return [tool for tool, installed in self.tools.items() if not installed]
    
    def is_tool_installed(self, tool_name: str) -> bool:
        """Check if a specific tool is installed"""
        return self.tools.get(tool_name, False)
    
    def run_tool(self, tool_name: str, command: str, capture_output: bool = True) -> Optional[str]:
        """Run a tool command with proper error handling"""
        # Extract the base command (first word)
        base_command = command.split()[0]
        
        # Check if the tool is installed
        if not self.is_tool_installed(tool_name):
            self.logger.error(f"Cannot run {tool_name}: Tool not installed")
            return None
            
        try:
            # Run the command
            result = subprocess.run(command, shell=True, capture_output=capture_output, text=True)
            if result.returncode != 0:
                self.logger.error(f"Error running {tool_name}: {result.stderr}")
                return None
            return result.stdout if capture_output else "Command executed successfully"
        except Exception as e:
            self.logger.error(f"Error executing {tool_name}: {str(e)}")
            return None 