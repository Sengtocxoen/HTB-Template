#!/usr/bin/env python3
import subprocess
import os
import json
import requests
import re
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor

class VulnerabilityAssessment:
    def __init__(self, target, logger, tool_manager=None, execution_engine=None):
        self.target = target
        self.logger = logger
        self.tool_manager = tool_manager
        self.execution_engine = execution_engine
        self.findings = {
            "descriptive_analysis": {
                "service_identification": {},
                "version_detection": {},
                "configuration_analysis": {},
                "behavioral_patterns": {}
            },
            "diagnostic_analysis": {
                "vulnerability_causes": {},
                "interaction_analysis": {},
                "correlation_findings": {},
                "root_causes": {}
            },
            "predictive_analysis": {
                "trend_analysis": {},
                "probability_assessment": {},
                "risk_prediction": {},
                "future_impact": {}
            },
            "prescriptive_analysis": {
                "remediation_actions": {},
                "prevention_measures": {},
                "mitigation_steps": {},
                "security_recommendations": {}
            }
        }
        self.output_dir = f"reports/vuln_assessment_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Load information gathering results if available
        self.info_gathering_results = self._load_info_gathering_results()

    def _load_info_gathering_results(self):
        """Load results from information gathering stage"""
        try:
            info_gathering_dir = max([d for d in os.listdir("reports") if d.startswith("info_gathering_")])
            with open(f"reports/{info_gathering_dir}/findings.json", 'r') as f:
                return json.load(f)
        except Exception as e:
            self.logger.error(f"Failed to load information gathering results: {str(e)}")
            return None

    def run(self):
        """Run all vulnerability assessment tasks"""
        self.logger.info("Starting Vulnerability Assessment phase...")
        
        # 1. Descriptive Analysis
        self.logger.info("Performing descriptive analysis...")
        self.findings["descriptive_analysis"] = self.perform_descriptive_analysis()
        
        # 2. Diagnostic Analysis
        self.logger.info("Performing diagnostic analysis...")
        self.findings["diagnostic_analysis"] = self.perform_diagnostic_analysis()
        
        # 3. Predictive Analysis
        self.logger.info("Performing predictive analysis...")
        self.findings["predictive_analysis"] = self.perform_predictive_analysis()
        
        # 4. Prescriptive Analysis
        self.logger.info("Performing prescriptive analysis...")
        self.findings["prescriptive_analysis"] = self.perform_prescriptive_analysis()
        
        # Save findings to JSON for other stages
        self._save_findings()
        
        return self.findings

    def _save_findings(self):
        """Save findings to JSON file for use in other stages"""
        output_file = f"{self.output_dir}/findings.json"
        with open(output_file, 'w') as f:
            json.dump(self.findings, f, indent=4)
        self.logger.info(f"Findings saved to {output_file}")

    def run_command(self, command, capture_output=True):
        """Run a system command and return the output"""
        if self.tool_manager:
            return self.tool_manager.run_tool(command.split()[0], command, capture_output)
        else:
            try:
                result = subprocess.run(command.split(), capture_output=capture_output, text=True)
                if result.returncode != 0:
                    self.logger.error(f"Command failed: {result.stderr}")
                    return None
                return result.stdout
            except Exception as e:
                self.logger.error(f"Error executing command: {str(e)}")
                return None

    def perform_descriptive_analysis(self):
        """Perform descriptive analysis of the target"""
        results = {
            "service_identification": {},
            "version_detection": {},
            "configuration_analysis": {},
            "behavioral_patterns": {}
        }
        
        if self.execution_engine:
            # Service and version detection
            self.execution_engine.add_task("nmap_service_detection", self.run_command,
                f"nmap -sV -sC -T4 --version-intensity 9 {self.target}", priority=1)
            
            # Configuration analysis
            self.execution_engine.add_task("nmap_config_analysis", self.run_command,
                f"nmap -sV --script default,auth -T4 {self.target}", priority=2)
            
            # Run tasks
            scan_results = self.execution_engine.run_parallel()
            
            # Process results
            if "nmap_service_detection" in scan_results:
                results["service_identification"] = self._parse_service_info(scan_results["nmap_service_detection"])
                results["version_detection"] = self._parse_version_info(scan_results["nmap_service_detection"])
            
            if "nmap_config_analysis" in scan_results:
                results["configuration_analysis"] = self._parse_config_info(scan_results["nmap_config_analysis"])
                results["behavioral_patterns"] = self._analyze_behavioral_patterns(scan_results["nmap_config_analysis"])
        
        return results

    def perform_diagnostic_analysis(self):
        """Perform diagnostic analysis to understand vulnerability causes"""
        results = {
            "vulnerability_causes": {},
            "interaction_analysis": {},
            "correlation_findings": {},
            "root_causes": {}
        }
        
        if self.execution_engine:
            # Vulnerability scanning
            self.execution_engine.add_task("nmap_vuln_scan", self.run_command,
                f"nmap -sV --script vuln -T4 {self.target}", priority=1)
            
            # Service interaction analysis
            self.execution_engine.add_task("nmap_interaction", self.run_command,
                f"nmap -sV --script auth,default -T4 {self.target}", priority=2)
            
            # Run tasks
            scan_results = self.execution_engine.run_parallel()
            
            # Process results
            if "nmap_vuln_scan" in scan_results:
                results["vulnerability_causes"] = self._analyze_vulnerability_causes(scan_results["nmap_vuln_scan"])
                results["root_causes"] = self._identify_root_causes(scan_results["nmap_vuln_scan"])
            
            if "nmap_interaction" in scan_results:
                results["interaction_analysis"] = self._analyze_service_interactions(scan_results["nmap_interaction"])
                results["correlation_findings"] = self._correlate_findings(scan_results["nmap_interaction"])
        
        return results

    def perform_predictive_analysis(self):
        """Perform predictive analysis to assess future risks"""
        results = {
            "trend_analysis": {},
            "probability_assessment": {},
            "risk_prediction": {},
            "future_impact": {}
        }
        
        # Analyze historical data and current findings
        if self.info_gathering_results:
            results["trend_analysis"] = self._analyze_trends()
            results["probability_assessment"] = self._assess_probabilities()
            results["risk_prediction"] = self._predict_risks()
            results["future_impact"] = self._assess_future_impact()
        
        return results

    def perform_prescriptive_analysis(self):
        """Perform prescriptive analysis to recommend actions"""
        results = {
            "remediation_actions": {},
            "prevention_measures": {},
            "mitigation_steps": {},
            "security_recommendations": {}
        }
        
        # Generate recommendations based on all previous analyses
        if self.findings["descriptive_analysis"] and self.findings["diagnostic_analysis"]:
            results["remediation_actions"] = self._generate_remediation_actions()
            results["prevention_measures"] = self._suggest_prevention_measures()
            results["mitigation_steps"] = self._propose_mitigation_steps()
            results["security_recommendations"] = self._provide_security_recommendations()
        
        return results

    def _parse_service_info(self, nmap_output):
        """Parse service information from nmap output"""
        services = {}
        for line in nmap_output.split('\n'):
            if 'open' in line and 'tcp' in line:
                parts = line.split()
                if len(parts) >= 4:
                    port = parts[0].split('/')[0]
                    service = parts[2]
                    services[port] = service
        return services

    def _parse_version_info(self, nmap_output):
        """Parse version information from nmap output"""
        versions = {}
        for line in nmap_output.split('\n'):
            if 'open' in line and 'tcp' in line:
                parts = line.split()
                if len(parts) >= 4:
                    port = parts[0].split('/')[0]
                    version = ' '.join(parts[3:])
                    versions[port] = version
        return versions

    def _parse_config_info(self, nmap_output):
        """Parse configuration information from nmap output"""
        configs = {}
        current_port = None
        for line in nmap_output.split('\n'):
            if 'open' in line and 'tcp' in line:
                current_port = line.split()[0].split('/')[0]
                configs[current_port] = []
            elif current_port and '|' in line:
                configs[current_port].append(line.strip())
        return configs

    def _analyze_behavioral_patterns(self, nmap_output):
        """Analyze behavioral patterns from nmap output"""
        patterns = {}
        for line in nmap_output.split('\n'):
            if 'open' in line and 'tcp' in line:
                port = line.split()[0].split('/')[0]
                patterns[port] = {
                    'response_time': self._extract_response_time(line),
                    'service_behavior': self._analyze_service_behavior(line)
                }
        return patterns

    def _analyze_vulnerability_causes(self, nmap_output):
        """Analyze causes of identified vulnerabilities"""
        causes = {}
        current_vuln = None
        for line in nmap_output.split('\n'):
            if 'VULNERABLE' in line:
                current_vuln = line.split(':')[0].strip()
                causes[current_vuln] = []
            elif current_vuln and '|' in line:
                causes[current_vuln].append(line.strip())
        return causes

    def _identify_root_causes(self, nmap_output):
        """Identify root causes of vulnerabilities"""
        root_causes = {}
        for vuln, details in self._analyze_vulnerability_causes(nmap_output).items():
            root_causes[vuln] = self._determine_root_cause(details)
        return root_causes

    def _analyze_service_interactions(self, nmap_output):
        """Analyze how services interact with each other"""
        interactions = {}
        for line in nmap_output.split('\n'):
            if 'open' in line and 'tcp' in line:
                port = line.split()[0].split('/')[0]
                interactions[port] = self._determine_service_interactions(line)
        return interactions

    def _correlate_findings(self, nmap_output):
        """Correlate different findings to identify patterns"""
        correlations = {}
        # Implement correlation logic based on nmap output
        return correlations

    def _analyze_trends(self):
        """Analyze trends in vulnerabilities and configurations"""
        trends = {}
        # Implement trend analysis logic
        return trends

    def _assess_probabilities(self):
        """Assess probabilities of various security scenarios"""
        probabilities = {}
        # Implement probability assessment logic
        return probabilities

    def _predict_risks(self):
        """Predict potential future risks"""
        risks = {}
        # Implement risk prediction logic
        return risks

    def _assess_future_impact(self):
        """Assess potential future impact of current findings"""
        impacts = {}
        # Implement future impact assessment logic
        return impacts

    def _generate_remediation_actions(self):
        """Generate specific remediation actions"""
        actions = {}
        # Implement remediation action generation logic
        return actions

    def _suggest_prevention_measures(self):
        """Suggest prevention measures"""
        measures = {}
        # Implement prevention measures suggestion logic
        return measures

    def _propose_mitigation_steps(self):
        """Propose mitigation steps"""
        steps = {}
        # Implement mitigation steps proposal logic
        return steps

    def _provide_security_recommendations(self):
        """Provide comprehensive security recommendations"""
        recommendations = {}
        # Implement security recommendations logic
        return recommendations

    def _extract_response_time(self, line):
        """Extract response time from nmap output line"""
        # Implement response time extraction logic
        return "unknown"

    def _analyze_service_behavior(self, line):
        """Analyze service behavior from nmap output line"""
        # Implement service behavior analysis logic
        return "unknown"

    def _determine_service_interactions(self, line):
        """Determine how a service interacts with others"""
        # Implement service interaction determination logic
        return "unknown"

    def _determine_root_cause(self, details):
        """Determine the root cause of a vulnerability"""
        # Implement root cause determination logic
        return "unknown"

    def _get_services(self):
        """Get list of services from information gathering results"""
        services = []
        if self.info_gathering_results and "services" in self.info_gathering_results:
            for service_info in self.info_gathering_results["services"].get("versions", {}).get("nmap", "").split("\n"):
                if "open" in service_info.lower():
                    service_name = service_info.split()[2] if len(service_info.split()) > 2 else "unknown"
                    services.append(service_name)
        return services 