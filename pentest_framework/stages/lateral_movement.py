#!/usr/bin/env python3
import subprocess
import os
import json
import logging
import socket
import struct
import time
import shutil
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

class EvasionLevel(Enum):
    EVASIVE = "evasive"
    HYBRID = "hybrid"
    NON_EVASIVE = "non_evasive"

@dataclass
class NetworkHost:
    ip: str
    hostname: str
    os: str
    services: List[str]
    users: List[str]
    shares: List[str]
    credentials: List[Dict]
    vulnerabilities: List[Dict]

class LateralMovement:
    def __init__(self, target, logger, tool_manager=None, execution_engine=None, evasion_level=EvasionLevel.EVASIVE):
        self.target = target
        self.logger = logger
        self.tool_manager = tool_manager
        self.execution_engine = execution_engine
        self.evasion_level = evasion_level
        self.findings = {
            "pivoting": {
                "established_tunnels": [],
                "failed_tunnels": [],
                "active_routes": []
            },
            "evasion_results": {
                "detected_actions": [],
                "undetected_actions": [],
                "security_measures": {}
            },
            "network_discovery": {
                "hosts": [],
                "subnets": [],
                "services": {},
                "users": {}
            },
            "vulnerability_assessment": {
                "internal_vulnerabilities": [],
                "misconfigurations": [],
                "weak_permissions": []
            },
            "exploitation_attempts": {
                "successful": [],
                "failed": [],
                "credentials_reused": []
            },
            "post_exploitation": {
                "compromised_hosts": [],
                "extracted_data": [],
                "persistence_established": []
            }
        }
        self.output_dir = f"reports/lateral_movement_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        os.makedirs(self.output_dir, exist_ok=True)
        
        # Load post-exploitation results
        self.post_exploitation_results = self._load_post_exploitation_results()
        
        # Initialize network hosts
        self.network_hosts = []

    def _load_post_exploitation_results(self):
        """Load results from post-exploitation stage"""
        try:
            post_exploitation_dir = max([d for d in os.listdir("reports") if d.startswith("post_exploitation_")])
            with open(f"reports/{post_exploitation_dir}/findings.json", 'r') as f:
                return json.load(f)
        except Exception as e:
            self.logger.error(f"Failed to load post-exploitation results: {str(e)}")
            return None

    def run(self):
        """Run the lateral movement phase"""
        self.logger.info("Starting Lateral Movement phase...")
        
        # 1. Establish pivoting
        self.logger.info("Establishing pivoting...")
        self.establish_pivoting()
        
        # 2. Discover network
        self.logger.info("Discovering network...")
        self.discover_network()
        
        # 3. Assess vulnerabilities
        self.logger.info("Assessing vulnerabilities...")
        self.assess_vulnerabilities()
        
        # 4. Attempt exploitation
        self.logger.info("Attempting exploitation...")
        self.attempt_exploitation()
        
        # 5. Perform post-exploitation
        self.logger.info("Performing post-exploitation...")
        self.perform_post_exploitation()
        
        # Save findings
        self._save_findings()
        
        return self.findings

    def establish_pivoting(self):
        """Establish pivoting to internal network"""
        # Check if we have necessary tools
        if not self._check_pivoting_tools():
            self.logger.error("Required pivoting tools not available")
            return
        
        # Establish SSH tunnel
        if self._establish_ssh_tunnel():
            self.findings["pivoting"]["established_tunnels"].append({
                "type": "ssh",
                "status": "active",
                "timestamp": datetime.now().isoformat()
            })
        
        # Establish SOCKS proxy
        if self._establish_socks_proxy():
            self.findings["pivoting"]["established_tunnels"].append({
                "type": "socks",
                "status": "active",
                "timestamp": datetime.now().isoformat()
            })
        
        # Update routing table
        self._update_routing()

    def discover_network(self):
        """Discover network from internal perspective"""
        if self.execution_engine:
            # Network discovery
            self.execution_engine.add_task("network_scan", self.run_command,
                "nmap -sn -PR -PS22,25,80,135,139,445,1433,3306,3389,8080 -PA21,23,80,3389 -PE -PP -PM -PO 10.0.0.0/8", priority=1)
            
            # Service enumeration
            self.execution_engine.add_task("service_enum", self.run_command,
                "nmap -sV -sC -T4 -p- --min-rate=1000 10.0.0.0/8", priority=2)
            
            # User enumeration
            self.execution_engine.add_task("user_enum", self.run_command,
                "enum4linux -a 10.0.0.0/8", priority=3)
            
            # Run tasks
            results = self.execution_engine.run_parallel()
            
            # Process results
            self._process_network_discovery(results)

    def assess_vulnerabilities(self):
        """Assess vulnerabilities from internal perspective"""
        for host in self.network_hosts:
            try:
                # Check for misconfigurations
                misconfigs = self._check_misconfigurations(host)
                if misconfigs:
                    self.findings["vulnerability_assessment"]["misconfigurations"].extend(misconfigs)
                
                # Check for weak permissions
                weak_perms = self._check_weak_permissions(host)
                if weak_perms:
                    self.findings["vulnerability_assessment"]["weak_permissions"].extend(weak_perms)
                
                # Check for internal vulnerabilities
                vulns = self._check_internal_vulnerabilities(host)
                if vulns:
                    self.findings["vulnerability_assessment"]["internal_vulnerabilities"].extend(vulns)
            except Exception as e:
                self.logger.error(f"Failed to assess vulnerabilities for {host.ip}: {str(e)}")

    def attempt_exploitation(self):
        """Attempt exploitation of discovered vulnerabilities"""
        for host in self.network_hosts:
            for vuln in host.vulnerabilities:
                try:
                    if self._is_safe_to_exploit(vuln):
                        result = self._attempt_exploitation(host, vuln)
                        if result["success"]:
                            self.findings["exploitation_attempts"]["successful"].append({
                                "host": host.ip,
                                "vulnerability": vuln,
                                "method": result["method"],
                                "timestamp": datetime.now().isoformat()
                            })
                        else:
                            self.findings["exploitation_attempts"]["failed"].append({
                                "host": host.ip,
                                "vulnerability": vuln,
                                "reason": result["reason"],
                                "timestamp": datetime.now().isoformat()
                            })
                except Exception as e:
                    self.logger.error(f"Failed to exploit {vuln} on {host.ip}: {str(e)}")

    def perform_post_exploitation(self):
        """Perform post-exploitation on compromised hosts"""
        for host in self.network_hosts:
            if self._is_host_compromised(host):
                try:
                    # Gather system information
                    sys_info = self._gather_system_info(host)
                    
                    # Extract sensitive data
                    sensitive_data = self._extract_sensitive_data(host)
                    
                    # Establish persistence
                    persistence = self._establish_persistence(host)
                    
                    self.findings["post_exploitation"]["compromised_hosts"].append({
                        "host": host.ip,
                        "system_info": sys_info,
                        "sensitive_data": sensitive_data,
                        "persistence": persistence,
                        "timestamp": datetime.now().isoformat()
                    })
                except Exception as e:
                    self.logger.error(f"Failed to perform post-exploitation on {host.ip}: {str(e)}")

    def _check_pivoting_tools(self) -> bool:
        """Check if required pivoting tools are available"""
        required_tools = ["ssh", "socat", "chisel"]
        for tool in required_tools:
            if not shutil.which(tool):
                self.logger.error(f"Required tool {tool} not found")
                return False
        return True

    def _establish_ssh_tunnel(self) -> bool:
        """Establish SSH tunnel for pivoting"""
        try:
            # Create SSH tunnel
            self.run_command(f"ssh -fN -D 9050 {self.target}")
            return True
        except Exception as e:
            self.logger.error(f"Failed to establish SSH tunnel: {str(e)}")
            return False

    def _establish_socks_proxy(self) -> bool:
        """Establish SOCKS proxy for pivoting"""
        try:
            # Create SOCKS proxy
            self.run_command(f"socat TCP-LISTEN:1080,fork SOCKS4A:127.0.0.1:10.0.0.0/8,port=9050")
            return True
        except Exception as e:
            self.logger.error(f"Failed to establish SOCKS proxy: {str(e)}")
            return False

    def _update_routing(self):
        """Update routing table for pivoting"""
        try:
            # Add route through pivot
            self.run_command(f"route add -net 10.0.0.0/8 gw {self.target}")
            self.findings["pivoting"]["active_routes"].append({
                "network": "10.0.0.0/8",
                "gateway": self.target,
                "timestamp": datetime.now().isoformat()
            })
        except Exception as e:
            self.logger.error(f"Failed to update routing: {str(e)}")

    def _process_network_discovery(self, results: Dict):
        """Process network discovery results"""
        if "network_scan" in results:
            hosts = self._parse_network_scan(results["network_scan"])
            self.findings["network_discovery"]["hosts"].extend(hosts)
        
        if "service_enum" in results:
            services = self._parse_service_enum(results["service_enum"])
            self.findings["network_discovery"]["services"].update(services)
        
        if "user_enum" in results:
            users = self._parse_user_enum(results["user_enum"])
            self.findings["network_discovery"]["users"].update(users)

    def _check_misconfigurations(self, host: NetworkHost) -> List[Dict]:
        """Check for misconfigurations on a host"""
        misconfigs = []
        
        # Check service configurations
        for service in host.services:
            if self._is_service_misconfigured(service):
                misconfigs.append({
                    "host": host.ip,
                    "service": service,
                    "type": "misconfiguration",
                    "description": "Service misconfigured"
                })
        
        return misconfigs

    def _check_weak_permissions(self, host: NetworkHost) -> List[Dict]:
        """Check for weak permissions on a host"""
        weak_perms = []
        
        # Check share permissions
        for share in host.shares:
            if self._has_weak_permissions(share):
                weak_perms.append({
                    "host": host.ip,
                    "share": share,
                    "type": "weak_permission",
                    "description": "Share has weak permissions"
                })
        
        return weak_perms

    def _check_internal_vulnerabilities(self, host: NetworkHost) -> List[Dict]:
        """Check for internal vulnerabilities on a host"""
        vulns = []
        
        # Check for known vulnerabilities
        for service in host.services:
            if self._is_service_vulnerable(service):
                vulns.append({
                    "host": host.ip,
                    "service": service,
                    "type": "vulnerability",
                    "description": "Service has known vulnerability"
                })
        
        return vulns

    def _is_safe_to_exploit(self, vulnerability: Dict) -> bool:
        """Check if it's safe to exploit a vulnerability"""
        if self.evasion_level == EvasionLevel.NON_EVASIVE:
            return True
        
        # Check if vulnerability is likely to be detected
        high_visibility_vulns = ["remote_code_execution", "denial_of_service"]
        if vulnerability["type"] in high_visibility_vulns and self.evasion_level == EvasionLevel.EVASIVE:
            return False
        
        return True

    def _attempt_exploitation(self, host: NetworkHost, vulnerability: Dict) -> Dict:
        """Attempt to exploit a vulnerability"""
        # Implement exploitation attempt
        return {
            "success": False,
            "method": None,
            "reason": "Not implemented"
        }

    def _is_host_compromised(self, host: NetworkHost) -> bool:
        """Check if a host is compromised"""
        return any(attempt["host"] == host.ip for attempt in self.findings["exploitation_attempts"]["successful"])

    def _gather_system_info(self, host: NetworkHost) -> Dict:
        """Gather system information from a compromised host"""
        # Implement system information gathering
        return {}

    def _extract_sensitive_data(self, host: NetworkHost) -> List[Dict]:
        """Extract sensitive data from a compromised host"""
        # Implement sensitive data extraction
        return []

    def _establish_persistence(self, host: NetworkHost) -> Dict:
        """Establish persistence on a compromised host"""
        # Implement persistence establishment
        return {}

    def _save_findings(self):
        """Save findings to JSON file"""
        output_file = f"{self.output_dir}/findings.json"
        with open(output_file, 'w') as f:
            json.dump(self.findings, f, indent=4)
        self.logger.info(f"Findings saved to {output_file}")

    def run_command(self, command, capture_output=True):
        """Run a system command and return the output"""
        if self.tool_manager:
            return self.tool_manager.run_tool(command.split()[0], command, capture_output)
        else:
            try:
                result = subprocess.run(command.split(), capture_output=capture_output, text=True)
                if result.returncode != 0:
                    self.logger.error(f"Command failed: {result.stderr}")
                    return None
                return result.stdout
            except Exception as e:
                self.logger.error(f"Error executing command: {str(e)}")
                return None 