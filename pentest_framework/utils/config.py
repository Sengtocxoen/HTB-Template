#!/usr/bin/env python3
import os
import json
import yaml
import subprocess
from typing import Dict, Any, Optional
from pathlib import Path

class Config:
    def __init__(self, config_dir: str = "config"):
        self.config_dir = config_dir
        self.tools_config = {}
        self.scan_config = {}
        self.exploit_config = {}
        self.post_exploit_config = {}
        
        # Create config directory if it doesn't exist
        if not os.path.exists(config_dir):
            os.makedirs(config_dir)
            
        # Load configurations
        self._load_configs()
        
    def _load_configs(self):
        """Load all configuration files"""
        config_files = {
            'tools': 'tools.yaml',
            'scan': 'scan.yaml',
            'exploit': 'exploit.yaml',
            'post_exploit': 'post_exploit.yaml'
        }
        
        for config_type, filename in config_files.items():
            config_path = os.path.join(self.config_dir, filename)
            if os.path.exists(config_path):
                try:
                    with open(config_path, 'r') as f:
                        if filename.endswith('.yaml'):
                            config = yaml.safe_load(f)
                        else:
                            config = json.load(f)
                            
                    setattr(self, f"{config_type}_config", config)
                except Exception as e:
                    print(f"Error loading {filename}: {str(e)}")
            else:
                # Create default config if it doesn't exist
                self._create_default_config(config_type, config_path)
                
    def _create_default_config(self, config_type: str, config_path: str):
        """Create default configuration file"""
        default_configs = {
            'tools': {
                'nmap': {
                    'path': 'nmap',
                    'args': '-sV -sC -oA {output} {target}'
                },
                'gobuster': {
                    'path': 'gobuster',
                    'args': 'dir -u {target} -w {wordlist} -o {output}'
                },
                'hydra': {
                    'path': 'hydra',
                    'args': '-V -f -l {user} -P {passlist} {target} {service}'
                }
            },
            'scan': {
                'ports': {
                    'common': [21, 22, 23, 25, 53, 80, 443, 445, 3306, 3389, 8080],
                    'web': [80, 443, 8080, 8443],
                    'database': [1433, 3306, 5432, 6379, 27017]
                },
                'timeouts': {
                    'connect': 5,
                    'read': 10
                }
            },
            'exploit': {
                'windows': {
                    'services': ['smb', 'rdp', 'winrm', 'iis'],
                    'vulnerabilities': ['eternalblue', 'bluekeep', 'petitpotam']
                },
                'linux': {
                    'services': ['ssh', 'ftp', 'apache', 'nginx'],
                    'vulnerabilities': ['dirtycow', 'shellshock', 'heartbleed']
                }
            },
            'post_exploit': {
                'windows': {
                    'commands': {
                        'system_info': 'systeminfo',
                        'users': 'net user',
                        'network': 'ipconfig /all',
                        'processes': 'tasklist /v'
                    }
                },
                'linux': {
                    'commands': {
                        'system_info': 'uname -a',
                        'users': 'cat /etc/passwd',
                        'network': 'ifconfig -a',
                        'processes': 'ps aux'
                    }
                }
            }
        }
        
        config = default_configs.get(config_type, {})
        try:
            with open(config_path, 'w') as f:
                if config_path.endswith('.yaml'):
                    yaml.dump(config, f, default_flow_style=False)
                else:
                    json.dump(config, f, indent=4)
                    
            setattr(self, f"{config_type}_config", config)
        except Exception as e:
            print(f"Error creating default {config_type} config: {str(e)}")
            
    def get_tool_config(self, tool_name: str) -> Optional[Dict[str, Any]]:
        """Get configuration for a specific tool"""
        return self.tools_config.get(tool_name)
        
    def get_scan_config(self, config_type: str) -> Optional[Dict[str, Any]]:
        """Get scan configuration"""
        return self.scan_config.get(config_type)
        
    def get_exploit_config(self, os_type: str) -> Optional[Dict[str, Any]]:
        """Get exploitation configuration for specific OS"""
        return self.exploit_config.get(os_type)
        
    def get_post_exploit_config(self, os_type: str) -> Optional[Dict[str, Any]]:
        """Get post-exploitation configuration for specific OS"""
        return self.post_exploit_config.get(os_type)
        
    def run_tool(self, tool_name: str, args: str, capture_output: bool = True) -> Optional[str]:
        """Run a tool with specified arguments"""
        tool_config = self.get_tool_config(tool_name)
        if not tool_config:
            print(f"Tool {tool_name} not found in configuration")
            return None
            
        try:
            # Construct command
            cmd = f"{tool_config['path']} {args}"
            
            # Run command
            result = subprocess.run(
                cmd.split(),
                capture_output=capture_output,
                text=True
            )
            
            if result.returncode != 0:
                print(f"Error running {tool_name}: {result.stderr}")
                return None
                
            return result.stdout if capture_output else None
            
        except Exception as e:
            print(f"Error executing {tool_name}: {str(e)}")
            return None
            
    def update_config(self, config_type: str, updates: Dict[str, Any]):
        """Update configuration"""
        config_attr = f"{config_type}_config"
        if not hasattr(self, config_attr):
            print(f"Invalid config type: {config_type}")
            return
            
        current_config = getattr(self, config_attr)
        current_config.update(updates)
        setattr(self, config_attr, current_config)
        
        # Save updated config
        config_path = os.path.join(self.config_dir, f"{config_type}.yaml")
        try:
            with open(config_path, 'w') as f:
                yaml.dump(current_config, f, default_flow_style=False)
        except Exception as e:
            print(f"Error saving updated {config_type} config: {str(e)}")
            
    def validate_config(self, config_type: str) -> bool:
        """Validate configuration"""
        config_attr = f"{config_type}_config"
        if not hasattr(self, config_attr):
            print(f"Invalid config type: {config_type}")
            return False
            
        config = getattr(self, config_attr)
        
        # Add validation logic based on config type
        if config_type == 'tools':
            return self._validate_tools_config(config)
        elif config_type == 'scan':
            return self._validate_scan_config(config)
        elif config_type == 'exploit':
            return self._validate_exploit_config(config)
        elif config_type == 'post_exploit':
            return self._validate_post_exploit_config(config)
            
        return False
        
    def _validate_tools_config(self, config: Dict[str, Any]) -> bool:
        """Validate tools configuration"""
        required_fields = ['path', 'args']
        
        for tool_name, tool_config in config.items():
            if not all(field in tool_config for field in required_fields):
                print(f"Missing required fields in {tool_name} config")
                return False
                
            # Check if tool exists
            try:
                subprocess.run([tool_config['path'], '--version'], capture_output=True)
            except FileNotFoundError:
                print(f"Tool {tool_name} not found at {tool_config['path']}")
                return False
                
        return True
        
    def _validate_scan_config(self, config: Dict[str, Any]) -> bool:
        """Validate scan configuration"""
        required_fields = ['ports', 'timeouts']
        
        if not all(field in config for field in required_fields):
            print("Missing required fields in scan config")
            return False
            
        # Validate ports
        if not isinstance(config['ports'], dict):
            print("Invalid ports configuration")
            return False
            
        # Validate timeouts
        if not isinstance(config['timeouts'], dict):
            print("Invalid timeouts configuration")
            return False
            
        return True
        
    def _validate_exploit_config(self, config: Dict[str, Any]) -> bool:
        """Validate exploitation configuration"""
        required_os_types = ['windows', 'linux']
        
        if not all(os_type in config for os_type in required_os_types):
            print("Missing required OS types in exploit config")
            return False
            
        for os_type in required_os_types:
            os_config = config[os_type]
            if not isinstance(os_config, dict):
                print(f"Invalid {os_type} configuration")
                return False
                
            if not all(field in os_config for field in ['services', 'vulnerabilities']):
                print(f"Missing required fields in {os_type} config")
                return False
                
        return True
        
    def _validate_post_exploit_config(self, config: Dict[str, Any]) -> bool:
        """Validate post-exploitation configuration"""
        required_os_types = ['windows', 'linux']
        
        if not all(os_type in config for os_type in required_os_types):
            print("Missing required OS types in post-exploit config")
            return False
            
        for os_type in required_os_types:
            os_config = config[os_type]
            if not isinstance(os_config, dict):
                print(f"Invalid {os_type} configuration")
                return False
                
            if 'commands' not in os_config:
                print(f"Missing commands in {os_type} config")
                return False
                
        return True 